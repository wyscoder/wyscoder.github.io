<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wys&#39;blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wysblogs.top/"/>
  <updated>2020-08-13T03:44:55.333Z</updated>
  <id>http://wysblogs.top/</id>
  
  <author>
    <name>wys</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql范式和连接</title>
    <link href="http://wysblogs.top/2020/08/10/Mysql%E8%8C%83%E5%BC%8F%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://wysblogs.top/2020/08/10/Mysql范式和连接/</id>
    <published>2020-08-10T11:46:24.000Z</published>
    <updated>2020-08-13T03:44:55.333Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mysql范式和连接"><a href="#Mysql范式和连接" class="headerlink" title="Mysql范式和连接"></a>Mysql范式和连接</h1><h2 id="Mysql三大范式"><a href="#Mysql三大范式" class="headerlink" title="Mysql三大范式"></a>Mysql三大范式</h2><p>数据库设计都是依据范式来设计的，原因是为了规范逻辑结构，更好的解决数据冗余，数据的有效检查，提高存储效率。</p><ul><li>第一范式（1NF）的作用是要求每个关系的属性为原子性的，不可再分（列不可再分）。</li><li>第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一的区分（有唯一主键）。</li><li>第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息（列必须和主键直接相关）。</li></ul><h2 id="Mysql的连接查询"><a href="#Mysql的连接查询" class="headerlink" title="Mysql的连接查询"></a>Mysql的连接查询</h2><h3 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left join on / left outer join on</span><br></pre></td></tr></table></figure><p>left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。</p><p>左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</p><p><img src="https://pic3.zhimg.com/80/v2-7a272cde9f87d216a836d93ac9718b2a_720w.jpg" alt="img"></p><h3 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">right join on / right outer join on</span><br></pre></td></tr></table></figure><p>right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。</p><p>与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</p><p><img src="https://pic4.zhimg.com/80/v2-7830dfdbb63723adfc30513890e73440_720w.jpg" alt="img"></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inner join on</span><br></pre></td></tr></table></figure><p>组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p><p><img src="https://picb.zhimg.com/80/v2-1398fdcf77820b86fb352f608f1b231c_720w.jpg" alt="img"></p><h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><p>MySQL目前不支持此种方式，可以用其他方式替代解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>北森云计算一面</title>
    <link href="http://wysblogs.top/2020/08/10/%E5%8C%97%E6%A3%AE%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%80%E9%9D%A2/"/>
    <id>http://wysblogs.top/2020/08/10/北森云计算一面/</id>
    <published>2020-08-10T10:22:22.000Z</published>
    <updated>2020-08-10T11:54:06.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="北森云计算一面"><a href="#北森云计算一面" class="headerlink" title="北森云计算一面"></a>北森云计算一面</h1><p>上来就问我学java的对C#语言学习起来有困难吗？</p><p>我说我在学校接触过C#，还蛮好上手的，和java一样。。</p><p>然后让我介绍一下自己。我说了自己学校，姓名，然后介绍了两个项目。学校比赛报名系统和微信个人订阅号，</p><p>然后让我着重介绍了一下微信个人订阅号。我说用了 SpringBoot + redis + Jsoup + nginx 开发的</p><p>他说数据库用的啥 我说 mysql</p><p>然后就问我</p><p>1、 mysql三大范式。。我就记住了第一范式（字段不可再分，就是原子性）</p><ul><li><strong>第一范式(确保每列保持原子性)</strong></li><li><strong>第二范式(确保表中的每列都和主键相关)</strong></li><li><strong>第三范式(确保每列都和主键列直接相关,而不是间接相关)</strong></li></ul><p>2、之后问我连接分为什么种类，什么是左连接，什么是右连接。。</p><p>我直接懵逼，完全都没关注过这个是个啥。。。</p><p><strong>mysql连接查询：</strong></p><p><strong>左连接、右连接、内连接、全连接</strong></p><ul><li>左连接</li><li>右连接</li><li>内连接</li><li>全连接</li></ul><p>具体的内容都总结在我的博客里。</p><p>3、接下来问了mysql索引种类有哪些</p><p>我少说了普通索引。。。一共有5类</p><ul><li>普通索引</li><li>主键索引</li><li>唯一索引</li><li>组合索引</li><li>全文索引</li></ul><p>至少得把每种作用说一说。</p><p>4、说给你一个sql语句，你怎么去优化</p><p>我先说了 用explain查看一下效率和运行情况</p><p>然后我说了加索引，或者优化一下sql语句，或者把mysql所在的服务器进行优化。减少磁盘IO，也可以使用redis把结果缓存。</p><p>5、然后问了我nginx，说用了负载均衡。到底是怎么在使用的</p><p>我说配置了nginx.conf文件。把项目的ip地址给添加上去进行映射</p><p>然后问了我用过<strong>反代</strong>吗。。我说没有。。（反向代理）</p><p>6、问了问redis的缓存穿透和缓存预热。。</p><p>我说了缓存穿透和缓存预热的特点。和解决方法。顺便把缓存雪崩也说了说</p><p>他让我把缓存预热解决方法说一说。我说用setnx()加锁。每次访问都进行阻塞，然后防止数据库负载过大</p><p>7、然后问我了解过微服务架构吗。</p><p>我说没有，我只了解过dubbo的RPC远程调用服务原理。</p><p>就说了说远程服务暴露的过程。先暴露在本地。然后暴露到zookeeper上面，作为提供者，还有个消费者。就是从zookeeper上面进行消费，调用过程就像调用本地方法一样，安全透明，没有外来api侵入。</p><p>8、然后问我bootstrap框架了解吗。</p><p>我说了解，告诉他这个就是人家把样式全部写好，然后自己想用那一部分直接拷贝粘贴过来，修改一下中间的文字。</p><p>他说水平栅格了解过吗，讲讲实现原理。。我说不知道。我用的是可视化界面进行拖拽生成的。根本不去了解这些底层原理。</p><p>9、问我webapi了解过吗</p><p>我说前后端假如在一个项目中，后端使用RequestMapping()提供api接口，前端使用ajax进行访问。这种接口就是webapi接口</p><p>10、接下来问的都是计算机网络和操作系统了。</p><p>首先问我HTTP是什么。。我说是超文本传输协议。。然后原理也不是很了解</p><p>他问我TCP了解过吗。我结合了UDP说了说，大概就是TCP是一个可靠的面向连接的协议，UDP是一种无状态无连接的协议。</p><p>TCP传输内容可能多一点，如果传输内容少的话。UDP可能会更快一些。TCP通信需要建立连接才能通信，UDP只管发送不管对面在不在。。</p><p>之后问我TCP三次握手，我说第一次握手是客户端发送给服务器，然后告诉服务器说我要和你连接了，服务器收到后发送数据包给客户端，说收到了，我同意和你连接，然后客户端最后发送一个包告诉服务器说开始连接了。</p><p>TCP三次握手要检查客户端和服务器是否接受和发送都没问题，第一次发送检查的是客户端的发送，第二次检查的是服务器的发送和服务器的接受，最后一次就是客户端的接受，如果都没问题就可以开始连接了。</p><p>11、最后问了我进程和线程区别</p><p>我说进程时资源调度的最小单位，线程是依赖进程存在的，负责进程的操作，单线程也可以看作一个进程。（答得不好）</p><p><strong>进程和线程区别：</strong></p><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><ul><li>线程在进程下执行</li><li>一个进程可以包含多个线程</li><li>不同进程间数据很难共享</li><li>同一进程下不同线程间数据很易共享</li><li>进程要比线程消耗更多的计算机资源</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li></ul><p><strong>感悟</strong></p><p>我觉得这次答得太水了。。大概率挂掉了，专心复习然后找其他公司把。还是面试可以检测自己到底哪里有问题。要针对薄弱的地方进行复习了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面经" scheme="http://wysblogs.top/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://wysblogs.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>IP地址范围</title>
    <link href="http://wysblogs.top/2020/08/09/IP%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4/"/>
    <id>http://wysblogs.top/2020/08/09/IP地址范围/</id>
    <published>2020-08-09T03:18:10.000Z</published>
    <updated>2020-08-09T03:21:21.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IP地址范围"><a href="#IP地址范围" class="headerlink" title="IP地址范围"></a>IP地址范围</h1><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来<strong>屏蔽物理地址的差异</strong>。</p><h2 id="1、A类IP地址"><a href="#1、A类IP地址" class="headerlink" title="1、A类IP地址"></a>1、A类IP地址</h2><p>一个A类IP地址是指， 在IP地址的四段du号码中，第一段号码为网zhi络号码，剩下的三dao段号码为本地计算机的号码。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。</p><p><strong>A类IP地址 地址范围1.0.0.1到127.255.255.254。</strong></p><h2 id="2、B类IP地址"><a href="#2、B类IP地址" class="headerlink" title="2、B类IP地址"></a>2、B类IP地址</h2><p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。</p><p><strong>B类IP地址地址范围128.0.0.1-191.255.255.254。</strong></p><h2 id="3、C类IP地址"><a href="#3、C类IP地址" class="headerlink" title="3、C类IP地址"></a>3、C类IP地址</h2><p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p><p><strong>C类IP地址范围192.0.0.1-223.255.255.254。</strong></p><h2 id="4、D类IP地址"><a href="#4、D类IP地址" class="headerlink" title="4、D类IP地址"></a>4、D类IP地址</h2><p>D类IP地址在历史上被叫做多播地址，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，<strong>范围从224.0.0.0到239.255.255.255。</strong></p><h2 id="5、E类IP地址"><a href="#5、E类IP地址" class="headerlink" title="5、E类IP地址"></a>5、E类IP地址</h2><p><strong>E类IP地址中是以“11110”开头</strong>，E类IP地址都保留用于将来和实验使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wysblogs.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://wysblogs.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap详解</title>
    <link href="http://wysblogs.top/2020/08/05/LinkedHashMap%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/08/05/LinkedHashMap详解/</id>
    <published>2020-08-05T02:45:31.000Z</published>
    <updated>2020-08-05T02:45:31.509Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Security学习</title>
    <link href="http://wysblogs.top/2020/08/05/Spring-Security%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wysblogs.top/2020/08/05/Spring-Security学习/</id>
    <published>2020-08-05T02:05:41.000Z</published>
    <updated>2020-08-05T02:05:41.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis基础知识</title>
    <link href="http://wysblogs.top/2020/07/30/Mybatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://wysblogs.top/2020/07/30/Mybatis基础知识/</id>
    <published>2020-07-30T01:48:38.000Z</published>
    <updated>2020-08-13T03:56:51.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mybatis基础知识"><a href="#Mybatis基础知识" class="headerlink" title="Mybatis基础知识"></a>Mybatis基础知识</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</p><p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>基于Sql语句编程，解耦合，SQL全部写在XML中，方便管理，而且不会对应用程序或者数据库设计造成任何影响</li><li>兼容性好，支持各类数据库</li><li>支持对象和数据库的ORM字段关系映射</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>sql语句编写工作量大。</li><li>sql语句依赖于数据库，移植性差。</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><strong>1、#{}和${}的区别是什么？</strong></p><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><p><strong>2、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</strong></p><p>1、在查询的sql语句中定义字段名的别名，让字段名的别名和实体类属性名一致。</p><p>2、 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mybatis" scheme="http://wysblogs.top/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://wysblogs.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>对象头大小分配</title>
    <link href="http://wysblogs.top/2020/07/30/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D/"/>
    <id>http://wysblogs.top/2020/07/30/对象头大小分配/</id>
    <published>2020-07-30T01:47:56.000Z</published>
    <updated>2020-07-31T03:38:13.342Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对象头大小分配"><a href="#对象头大小分配" class="headerlink" title="对象头大小分配"></a>对象头大小分配</h1><p><strong>1、在32位系统下，存放Class指针的空间大小是4字节，MarkWord是4字节，对象头为8字节。</strong></p><p><strong>2、在64位系统下，存放Class指针的空间大小是8字节，MarkWord是8字节，对象头为16字节。</strong></p><p><strong>3、在64位开启指针压缩的情况下 -XX:+UseCompressedOops，存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节。</strong></p><p><strong>4、如果对象是数组，那么额外增加4个字节</strong></p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>最后一块对齐填充空间并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。这是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="jvm" scheme="http://wysblogs.top/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://wysblogs.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>MVCC详解</title>
    <link href="http://wysblogs.top/2020/07/30/MVCC%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/30/MVCC详解/</id>
    <published>2020-07-30T01:47:16.000Z</published>
    <updated>2020-07-31T03:45:18.645Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MVCC详解"><a href="#MVCC详解" class="headerlink" title="MVCC详解"></a>MVCC详解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MVCC,多版本的并发控制，就是当我们在修改数据的时候，可以为这条数据创建一个快照，后面就可以直接读取这个快照。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号。</p><h2 id="MVCC优缺点"><a href="#MVCC优缺点" class="headerlink" title="MVCC优缺点"></a>MVCC优缺点</h2><p>MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。</p><ul><li>MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。</li><li>Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</li><li>原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。</li><li>串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。</li><li>通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>AQS详解</title>
    <link href="http://wysblogs.top/2020/07/30/AQS%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/30/AQS详解/</id>
    <published>2020-07-30T01:41:48.000Z</published>
    <updated>2020-08-09T16:53:57.909Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AQS详解"><a href="#AQS详解" class="headerlink" title="AQS详解"></a>AQS详解</h1><p>AQS(AbstractQueuedSynchronizer类)是JUC并发包中一个很关键的存在。</p><p>AQS是一个队列同步器，这是一个用来构建锁和同步器的框架，在内部定义了一个<code>int</code>类型的<code>state</code>变量，用来表示同步状态。</p><p>lock包中的锁并没有直接继承AQS，而是定义了一个<strong>Sync类</strong>去继承AQS，原因是<strong>为了解耦合，锁是面向用户的，同步器是线程控制，通过聚合，两者相互隔离，可以有效地关注各自的事情</strong>。</p><p>AQS是通过<strong>FIFO双向的同步队列</strong>进行同步状态的管理，当有线程获取锁失败后，就被放在<strong>队列的末尾</strong>。</p><p><img src="https://pic3.zhimg.com/80/v2-a8ed401aa4ce0f7d93ff6d777400aff7_720w.png" alt="img"></p><p><strong>头节点是持有锁的节点。</strong></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://wysblogs.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://wysblogs.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>LRU机制与实现</title>
    <link href="http://wysblogs.top/2020/07/30/LRU%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wysblogs.top/2020/07/30/LRU机制与实现/</id>
    <published>2020-07-30T01:40:09.000Z</published>
    <updated>2020-08-05T13:35:24.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LRU机制与实现"><a href="#LRU机制与实现" class="headerlink" title="LRU机制与实现"></a>LRU机制与实现</h1><p><strong>LRU是一种缓存淘汰策略</strong></p><p><strong>LRU 最近最久未使用<br>LFU  最近最少使用（最不常用）</strong></p><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><p>它应该支持以下操作： 获取数据<code>get</code>和 写入数据<code>put</code>。</p><p>获取数据<code>get(key)</code>- 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><blockquote><p>LeetCode <a href="https://leetcode-cn.com/problems/lru-cache-lcci/" target="_blank" rel="noopener">面试题 16.25. LRU缓存</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/8/5 10:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: LRUCache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">           Integer value = map.remove(key);</span><br><span class="line">           map.put(key, value);</span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        <span class="keyword">if</span>(map.size()&gt;capacity)&#123;</span><br><span class="line">            map.remove(map.entrySet().iterator().next().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wysblogs.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://wysblogs.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线程池详解</title>
    <link href="http://wysblogs.top/2020/07/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/30/线程池详解/</id>
    <published>2020-07-30T01:38:50.000Z</published>
    <updated>2020-08-10T02:35:54.486Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程池详解"><a href="#线程池详解" class="headerlink" title="线程池详解"></a>线程池详解</h1><p>首先我们来了解一下什么是线程池</p><p>顾名思义，我们之前了解过JDBC连接池，就应该明白，线程池也是一样的，都是预先创建好一堆对象来进行重复使用。</p><p><strong>池化技术能够减少资源的创建次数，提高程序性能</strong></p><p><strong>池化技术针对的对象特点</strong>：</p><ul><li>对象创建时间长</li><li>对象创建需要消耗大量的资源</li><li>对象创建后可以被重复使用</li></ul><h2 id="线程池注意"><a href="#线程池注意" class="headerlink" title="线程池注意"></a>线程池注意</h2><p><img src="/upload/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="image-20200730164919632"></p><h2 id="创建线程池的几种形式"><a href="#创建线程池的几种形式" class="headerlink" title="创建线程池的几种形式"></a>创建线程池的几种形式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">//创建固定数量的线程</span></span><br><span class="line">Executors.newSingleThreadExecutor(); <span class="comment">//单个线程</span></span><br><span class="line">Executors.newCachedThreadPool(); <span class="comment">//可伸缩的线程池</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">5</span>); <span class="comment">//线程调度池</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*在任务执行时间小于间隔时间的情况下，程序以起始时间为准则，每隔指定时间执行一次，不受任务执行时间影响</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以上都是提供的几种形式，如果不满足的话，那么可以自己定义一个数据池来供自己使用</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>在定义自己的数据池之前要了解线程池的每个参数作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> corePoolSize <span class="comment">//核心线程数量</span></span><br><span class="line"><span class="keyword">int</span> maximumPoolSize <span class="comment">//最大线程数量</span></span><br><span class="line"><span class="keyword">long</span> keepAliveTime <span class="comment">//保持存活的时间</span></span><br><span class="line">TimeUnit unit     <span class="comment">//时间计算的规则</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue <span class="comment">//阻塞队列</span></span><br><span class="line">ThreadFactory threadFactory   <span class="comment">//线程工厂模式</span></span><br><span class="line">RejectedExecutionHandler handler <span class="comment">//四种拒绝策略</span></span><br></pre></td></tr></table></figure><p>我们可以把线程池抽象出来，比作一个银行运作模式</p><p><strong>核心线程</strong>就是默认开启的窗口数量</p><p><strong>最大线程数量</strong>就是银行能够提供的最大窗口数量</p><p><strong>保持存活的时间</strong>：就是如果线程数量大于核心线程数，但是线程如果空闲等待时间大于保持存活的时间，就会销毁这些线程。</p><p><strong>时间计算的规则</strong>：就是TImeUnit类的规则</p><p><strong>阻塞队列</strong>：就是银行等待区的最大人数</p><p><strong>线程工厂模式</strong>：负责生产线程的工厂，一般是不用改变的，使用默认的就行</p><p><strong>拒绝策略</strong>：</p><p><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常</code></p><p><code>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</code></p><p><code>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</code> <code>ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务</code></p><p>拒绝策略可以理解为 如果银行窗口和等待区全部占满之后，银行对新进来的人进行的安排策略。</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><p>如果了解以上参数的话，我们就可以来编写自己的线程池了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        Executors.newSingleThreadExecutor();</span><br><span class="line">        Executors.newCachedThreadPool();</span><br><span class="line">        Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"执行了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果线程池用完了。。记得关闭就行。</p><h2 id="线程池的几个队列"><a href="#线程池的几个队列" class="headerlink" title="线程池的几个队列"></a>线程池的几个队列</h2><p>（1）<strong>ArrayBlockingQueue</strong>：规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</p><p>（2）<strong>LinkedBlockingQueue</strong>：大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</p><p>（3）<strong>PriorityBlockingQueue</strong>：类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</p><p>（4）<strong>SynchronizedQueue</strong>：特殊的BlockingQueue，对其的操作必须是放和取交替完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://wysblogs.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://wysblogs.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器详解</title>
    <link href="http://wysblogs.top/2020/07/30/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/30/垃圾回收器详解/</id>
    <published>2020-07-30T01:35:29.000Z</published>
    <updated>2020-07-31T03:33:30.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="垃圾收集器详解"><a href="#垃圾收集器详解" class="headerlink" title="垃圾收集器详解"></a>垃圾收集器详解</h1><p>垃圾收集器是垃圾回收算法的实现。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>这是一个最基础，最久远的收集器，是一个单线程的收集器，在工作的时候会暂停其他线程，来进行垃圾回收。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器实质上是Serial收集器的多线程并发版本。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>这个收集器是一个新生代收集器。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p>看上去似乎和ParNew差不多，实际上这个收集器的特点是它的关注点与其他的不同，比如CMS等其他收集器都是以缩短用户线程停顿时间为主要目标，而Parallel Scavenge收集器是为了<strong>达到一个可控制的吞吐量</strong>，能够有效的提高用户体验。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>Serial Old收集器是Serial收集器的老年版本，同样也是一个单线程收集器。</p><p>采用的是<strong>标记整理算法</strong>。</p><p>一般是和Parallel Scavenge收集器搭配使用。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年版本。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS收集器是为了获取最短回收停顿时间为目标的收集器。</p><p><strong>运作过程</strong>：</p><ul><li>1、初始标记</li><li>2、并发标记</li><li>3、重新标记</li><li>4、并发清除</li></ul><p><strong>优点：</strong>并发收集，低停顿</p><p><strong>缺点：</strong></p><ul><li><strong>对处理器资源敏感</strong>，会占用CPU资源，导致应用变慢，降低总吞吐量。处理器不足四个就会使处理器负载变大。</li><li><strong>无法处理 “浮动垃圾”</strong>，标记结束后，没有办法一次性清除完毕的垃圾。</li><li><strong>产生资源碎片</strong>，因为采用标记清除，所以会产生大量空间碎片</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1收集器是一款面向服务端应用的垃圾收集器。</p><p>在新生代，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World的暂停。新生代的清理会带上old区已标记好的region。</p><p><strong>G1运作过程：</strong></p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p><strong>特点：</strong></p><ul><li>并行与并发：充分利用了CPU资源</li><li>分代收集：可以更好地进行管理分代区</li><li>空间整合：不会产生内存碎片</li><li>可预测停顿：能够让使用者明确指定消耗在垃圾收集器上的时间</li></ul><p><strong>缺点</strong></p><p>region大小和对象很难保持一致，导致空间的浪费。</p><p><strong>CMS只是针对老年代的，而G1是针对两者的</strong></p><p><strong>G1可以不需要其它收集器配合就能独立管理整个GC堆</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="http://wysblogs.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://wysblogs.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>创建线程的几种方式</title>
    <link href="http://wysblogs.top/2020/07/30/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://wysblogs.top/2020/07/30/创建线程的几种方式/</id>
    <published>2020-07-30T01:31:56.000Z</published>
    <updated>2020-07-30T08:24:28.638Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h1><blockquote><p>继承Thread类</p><p>实现Runnable接口</p><p>通过Callable和FutureTask创建线程</p><p>通过线程池创建线程</p></blockquote><h2 id="1、继承Thread类"><a href="#1、继承Thread类" class="headerlink" title="1、继承Thread类"></a>1、继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(threadDemo,<span class="string">"A"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程启动了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、实现Runnable接口"><a href="#2、实现Runnable接口" class="headerlink" title="2、实现Runnable接口"></a>2、实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunnableDemo demo = <span class="keyword">new</span> RunnableDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(demo,<span class="string">"A"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程启动了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Callable和FutureTask"><a href="#3、Callable和FutureTask" class="headerlink" title="3、Callable和FutureTask"></a>3、Callable和FutureTask</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CallableDemo demo = <span class="keyword">new</span> CallableDemo();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(demo);</span><br><span class="line">        <span class="keyword">new</span> Thread(task,<span class="string">"A"</span>).start();</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"线程启动了！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"启动了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable是可以有返回值的，通过线程执行完毕调用<code>get()</code>方法获得</p><h2 id="4、通过线程池启动"><a href="#4、通过线程池启动" class="headerlink" title="4、通过线程池启动"></a>4、通过线程池启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/30 10:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: ThreadPoolDemo</span></span><br><span class="line"><span class="comment"> *     int corePoolSize, 核心线程数量</span></span><br><span class="line"><span class="comment"> *     int maximumPoolSize, 最大线程数量</span></span><br><span class="line"><span class="comment"> *     long keepAliveTime,  保持存活的时间</span></span><br><span class="line"><span class="comment"> *     TimeUnit unit,      时间计算的规则</span></span><br><span class="line"><span class="comment"> *     BlockingQueue&lt;Runnable&gt; workQueue, 阻塞队列</span></span><br><span class="line"><span class="comment"> *     ThreadFactory threadFactory,   线程工厂模式</span></span><br><span class="line"><span class="comment"> *     RejectedExecutionHandler handler 四种拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"执行了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池核心就是。。上面的7中参数。。一定要记住</p><p><strong>四种拒绝策略：</strong></p><ul><li><strong>AbortPolicy</strong>：如果满了就报错</li><li><strong>CallerRunsPolicy</strong>：哪来的就回拿去，意思就是让本来的线程去执行</li><li><strong>DiscardOldestPolicy</strong>：如果满了就与第一个执行的线程竞争一下cpu资源，如果成功就执行，不成功就拒绝掉，不会报错</li><li><strong>DiscardPolicy</strong>：如果满了就直接拒绝掉，不会报错</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://wysblogs.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://wysblogs.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>面试场景题</title>
    <link href="http://wysblogs.top/2020/07/30/%E9%9D%A2%E8%AF%95%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
    <id>http://wysblogs.top/2020/07/30/面试场景题/</id>
    <published>2020-07-30T01:30:17.000Z</published>
    <updated>2020-07-30T01:56:05.350Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面试场景题"><a href="#面试场景题" class="headerlink" title="面试场景题"></a>面试场景题</h1><p><strong>1、一个是用户信息文件, 保存了1亿的用户信息, 一个是用户浏览商品的记录的文件, 保存了500万的用户浏览记录, 怎么合并这两个文件? (内存为1G)</strong></p><p><strong>文件中怎么快速找出浏览记录大于5的数据?</strong></p><p>暂空</p><p><strong>2、现有1T的数据，内存只有1G，该怎么对他们排序</strong></p><p>外部排序。多路归并</p><p><strong>3、不知道大小的数据流取其中100个数，怎样的取法能最随机</strong></p><p>暂空</p><p><strong>4、n个物品每个物品都有一定价值，分给2个人，怎么分两个人的价值差最小</strong></p><p>暂空</p><p><strong>5、假设百度每个页面能放100个网页，每个页面都有一个评分，怎样快速找到第8页的所有网页</strong></p><p>暂空</p><p><strong>6、如果一个sql执行慢，可能是什么原因造成的，你说说如果是你碰到了，你打算怎么排查?</strong></p><p>暂空</p><p><strong>7、两个数字 int a=10 int b=20 如何不经过第三个变量来交换，结果为 a=20 b=10</strong></p><p>使用位运算</p><p>a = a^b</p><p>b = a^b</p><p>a = a^b</p><p><strong>8、假如有上亿条数据，你如何快速找到其中一条你想要的数据（几种简单的算法）</strong></p><p>暂空</p><p><strong>9、每秒几十万并发的秒杀系统为什么会频繁发生GC？</strong></p><p>暂空</p><p><strong>10、日均百万级交易系统如何优化JVM？</strong></p><p>暂空</p><p><strong>11、如何从含有100亿个整数的文件中找出其中最大的100个？</strong></p><p>暂空</p><p><strong>12、tomcat在并发场景中，应该如何优化tomcat，比如再下次8g内存的服务器上，部署4个tomcat，怎么做可以合理调优</strong></p><p>暂空</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面试" scheme="http://wysblogs.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://wysblogs.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁详解</title>
    <link href="http://wysblogs.top/2020/07/25/mysql%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/25/mysql锁详解/</id>
    <published>2020-07-24T18:19:16.000Z</published>
    <updated>2020-07-26T01:51:15.220Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql锁详解"><a href="#mysql锁详解" class="headerlink" title="mysql锁详解"></a>mysql锁详解</h1><p>mysql的锁可以用两种情况区分</p><p>按粒度分为 行锁,页锁,表锁 </p><p>按用法有共享锁和排他锁</p><h2 id="按粒度来分"><a href="#按粒度来分" class="headerlink" title="按粒度来分"></a>按粒度来分</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行锁是锁粒度最细的一个锁了,表示只对自己当前操作的行加锁.</p><p>行锁操作可以大大的减少数据库操作带来的冲突,但是加速开销太大</p><p>行锁分为共享锁和排他锁.</p><p>特点: 开销大,可能会出现死锁,并发程度高,锁冲突概率最低.</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁是mysql锁粒度最大的一个锁, 表示对当前操作的整张表都加锁, 资源消耗大, 被大部分引擎都支持.</p><p>表锁分为 共享锁 和 排他锁</p><p>特点: 开销小, 加锁快, 不会出现死锁, 锁粒度大, 发生冲突的概率最大, 并发性最低.</p><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><p>页级锁是mysql中锁粒度一般的锁, 一般都是在行锁和表锁之间.</p><p>表锁速度快,但是冲突多, 行锁冲突少, 但是速度慢, 于是采用 页锁的比较多.</p><p>页锁是一次锁定相邻的一组记录开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁是一种悲观的并发控制线程访问的一个方法.</p><p>它可以阻止一个事务以影响其他用户的方式来修改数据.</p><p>如果一个事务的操作的某行数据加了锁, 那么只有当这个事务把锁释放了, 其他事物才能够执行和该锁冲突的操作.</p><p>悲观锁主要用于数据竞争比较激烈的环境 还有 并发冲突时维护锁的成本低于回滚成本的环境中.</p><p><strong>使用:</strong>如果要对数据修改,先给这个数据添加排他锁,如果添加失败,那么说明正在被使用, 因此要等待或者抛异常.</p><p>优点: 保证了数据的安全和完整性</p><p>缺点: 效率低,会让数据库产生额外开销,还有可能出现死锁, 在只读的事务中不会产生冲突, 这样做会增加系统开销, 降低了并行.</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁是一种乐观的并发控制线程访问的一个方法.</p><p>它假设在并发处理事务时,都不会相互影响, 各事务能够在不产生锁的情况下处理各自影响的那部分数据.</p><p>就是只在提交的时候进行判断是否冲突</p><p>提交数据时判断有没有其他事务修改数据, 如果数据被修改了,那么就回滚.</p><p>乐观锁不会使用数据库提供的锁机制, 一般的实现乐观锁的方式就是记录数据版本, 即添加一行字段 version , 如果提交时发现字段一致, 就更新数据 , 否则就回滚.</p><p>实现乐观锁两种方式: 版本号 和 时间戳</p><p>乐观锁原理就是 CAS 操作</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>innodb 支持行锁 和 表锁 默认是支持行锁</p><p>innodb行锁是个索引加锁实现的, 意思就是只有通过索引条件检索数据, InnoDB才使用行级锁, 否则 InnoDB使用表锁 , 实际中我们要注意这种情况, 不然会产生大量冲突.</p><p>当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。</p><p>即便 在 数据库设置了索引, 但是是否用索引 还是根据mysql 通过判断不同 执行计划代价来决定的, 如果 mysql 认为全表扫描效率高, 例如一些很小的表, 他就不会使用索引, 这种情况下 就会使用 表锁.</p><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>在mysql中, 行锁不是直接锁记录, 而是锁的时索引.</p><p>索引分为主键索引和非主键索引, 如果mysql操作了主键索引, 那么就锁主键索引, 如果走的索引是 非主键索引, 那么先锁非主键索引, 再锁相关的主键索引.</p><p><strong>死锁:</strong>一个事务锁了主键索引, 另一个事务锁了非主键索引, 在等主键索引, 就造成了死锁.</p><p>死锁后 InnoDB都可以检查到, 并使一个事务释放锁并回退, 另一个获取锁完成事务.</p><p>*<em>避免死锁: *</em></p><ul><li>尽量有序访问表</li><li>尽量一次锁定所需要的所有资源</li><li>也可以升级锁粒度</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>百度一面面经</title>
    <link href="http://wysblogs.top/2020/07/24/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>http://wysblogs.top/2020/07/24/百度一面面经/</id>
    <published>2020-07-24T07:26:05.000Z</published>
    <updated>2020-07-24T14:13:52.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="百度一面面经"><a href="#百度一面面经" class="headerlink" title="百度一面面经"></a>百度一面面经</h1><p><strong>1、介绍自己。</strong></p><p><strong>2、说说面向对象的几个特点</strong></p><p><strong>3、然后出了几个 <code>==</code>条件 让我进行判断（Integer缓冲池）</strong></p><p><strong>4、然后一个剑指Offer原题。</strong></p><p>一开始没有暴力，后来用hashmap进行优化时间</p><p><strong>5、int的最大值，为什么？</strong></p><p><strong>6、ArrayList和LinkedArrayList区别</strong></p><p><strong>6、mysql索引（B+树原理）</strong></p><p><strong>7、innodb的原理（回表操作）</strong></p><p><strong>8、给了几个索引查询语句，判断可以不可以走索引进行查询</strong></p><p><strong>9、最后让编写一个各科平均分数的sql语句（没写出来，太菜了）</strong></p><p><strong>10、需要问什么问题？</strong></p><p>我问的是，我有些地方答得不是很好，希望你能给我讲讲我现在需要提升的地方。</p><p><strong>基础知识都是靠记得，理解上面有些不好，sql语句也不是很好，需要多去理解理解，知识不能靠死记硬背，把sql语句也练一练</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面经" scheme="http://wysblogs.top/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://wysblogs.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat原理</title>
    <link href="http://wysblogs.top/2020/07/24/Tomcat%E5%8E%9F%E7%90%86/"/>
    <id>http://wysblogs.top/2020/07/24/Tomcat原理/</id>
    <published>2020-07-24T00:51:33.000Z</published>
    <updated>2020-07-27T02:14:04.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat原理"><a href="#Tomcat原理" class="headerlink" title="Tomcat原理"></a>Tomcat原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tomcat是一个JSP/Servlet容器，其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器、进程外的Servlet容器。</p><p>Tomcat也是一个中间件，运行在JVM上，是一个在JAVA项目和JVM之间的中间容器。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/upload/tomcat/20180518194004378.png" alt="img"></p><p>核心容器和<code>Connector</code>和<code>Container</code></p><ul><li>Connector：处理连接相关内容，并提供Socket的Request和Response相关的转换。</li><li>Container：核心容器，封装和管理Servlet，处理Request请求。</li></ul><h2 id="三种Connector运行模式"><a href="#三种Connector运行模式" class="headerlink" title="三种Connector运行模式"></a>三种Connector运行模式</h2><ul><li><strong>BIO</strong>：同步阻塞IO，一个线程处理一个请求，同时把其他线程阻塞，并发量高时，线程多，导致性能严重下降</li><li><strong>NIO</strong>：异步非阻塞IO，一个线程处理多个Connection，多路复用，使用较少的线程执行较多的请求。</li><li><strong>APR</strong>：异步非阻塞IO，和NIO在操作系统层面不同，不需要关注进度问题。</li></ul><h2 id="Tomcat工作模式"><a href="#Tomcat工作模式" class="headerlink" title="Tomcat工作模式"></a>Tomcat工作模式</h2><p>Tomcat作为servlet容器，有三种工作模式：</p><ul><li>1、<strong>独立的servlet容器</strong>，servlet容器是web服务器的一部分；</li><li>2、<strong>进程内的servlet容器</strong>，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足；</li><li>3、<strong>进程外的servlet容器</strong>，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优；</li></ul><p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p><ul><li>Tomcat作为<strong>应用程序服务器</strong>：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li><li>Tomcat作为<strong>独立服务器</strong>：请求来自于web浏览器；</li></ul><h2 id="Tomcat违背双亲委派模型"><a href="#Tomcat违背双亲委派模型" class="headerlink" title="Tomcat违背双亲委派模型"></a>Tomcat违背双亲委派模型</h2><p>首先谈一下Tomcat要实现的目的：</p><ul><li>运行多个web程序，并且各个依赖的类库相互独立，相互隔离。</li><li>部署在同一个web容器下的相同类库可以共享。</li><li>web容器自己类库不能与程序冲突。</li><li>需要更改jsp后不用重启。</li></ul><p><strong>Tomcat类加载器</strong></p><p><img src="/upload/tomcat/4236553-89bacc3467d513f0.webp" alt="img"></p><p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。</p><p>tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器</p><p>、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="tomcat" scheme="http://wysblogs.top/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="http://wysblogs.top/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>UnSafe类详解</title>
    <link href="http://wysblogs.top/2020/07/23/UnSafe%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/23/UnSafe类详解/</id>
    <published>2020-07-23T06:55:17.000Z</published>
    <updated>2020-07-26T09:22:17.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UnSafe类详解"><a href="#UnSafe类详解" class="headerlink" title="UnSafe类详解"></a>UnSafe类详解</h1><p>Unsafe是位于sun.misc包下的一个类</p><p>主要是提供一些用于执行级别低，不安全操作的方法，如直接访问系统的一些资源，这些方法对提高java运行效率，增强java语言底层资源操作能力方面起到了很大的作用。</p><p>但是因为底层是直接操作内存来实现功能的，所以可能会发生内存上的一些问题，比如内存泄漏，如果不正当使用的话，可能使java变得不再那么安全。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://picb.zhimg.com/80/v2-f0570d67d15e6157e2723687b77aee15_720w.jpg" alt="img"></p><p>如上图可看出，Unsafe类在多个方面都有使用：</p><ul><li>内存操作<ul><li>主要是<strong>堆外内存</strong>的分配、拷贝、释放、给定地址值等操作。</li><li>因为是堆外内存，所以不归JVM管，得自己进行内存的管理</li><li>使用堆外内存的原因：对GC停顿进行改善，减少停顿带来的影响，提高IO操作性能，不需要再次进行拷贝。</li></ul></li><li>CAS操作<ul><li>比较并交换，轻量级无锁并发，执行CAS操作时，首先拿地址中的值和原值作比较，如果一样就把内存值更新为新值，否则就不做任何操作。</li><li>CAS在很多方面都有应用，比如Atomic原子类，还有AQS，ConcurrentHashMap等地方都有体现。</li></ul></li><li>Class相关的一些操作<ul><li>此部分主要提供<strong>Class</strong>和它的<strong>静态字段</strong>的操作相关方法，包含<strong>静态字段内存定位</strong>、<strong>定义类</strong>、<strong>定义匿名类</strong>、<strong>检验&amp;确保初始化</strong>等</li></ul></li><li>对象操作<ul><li>此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。</li><li>常规分配内存是使用<code>new</code>关键字，然后交给JVM来管理</li><li>但是Unsafe有分配内存的方法，不需要通过JVM进行操作，</li></ul></li><li>线程调度<ul><li>线程挂起，恢复，锁机制等操作。</li></ul></li><li>系统信息获取<ul><li>这部分包含两个获取系统相关信息的方法。</li></ul></li><li>内存屏障<ul><li>在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。</li></ul></li><li>数组操作<ul><li>这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://wysblogs.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://wysblogs.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>面对对象三大特点</title>
    <link href="http://wysblogs.top/2020/07/23/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/"/>
    <id>http://wysblogs.top/2020/07/23/面对对象三大特点/</id>
    <published>2020-07-23T04:19:47.000Z</published>
    <updated>2020-07-25T13:07:55.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面向对象三大特点"><a href="#面向对象三大特点" class="headerlink" title="面向对象三大特点"></a>面向对象三大特点</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>就是把自己的类给封装起来，只暴露出想让外界访问的接口和数据，保证了类的安全性。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>OOP的一个主要功能，通过继承来实现代码的复用。                                                                                                                                                                                                                                                        </p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个操作，作用于不同的对象，会产生不同的结果。</p><p>多态的好处是可以解耦合，灵活，面向接口编程，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引底层原理</title>
    <link href="http://wysblogs.top/2020/07/22/mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://wysblogs.top/2020/07/22/mysql索引底层原理/</id>
    <published>2020-07-22T11:12:51.000Z</published>
    <updated>2020-07-23T04:09:11.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql索引底层原理"><a href="#mysql索引底层原理" class="headerlink" title="mysql索引底层原理"></a>mysql索引底层原理</h1><p>我们都知道索引可以提高查询效率，那么为什么会提高查询效率呢？</p><p>我们可以从底层进行分析，因为mysql索引的底层是基于数据结构的。</p><p>假入我们没有索引，那么如果有5个数据，mysql在查询的时候就会比较5次，如果有1000w数据，那么就要比较100w次，很显然，这样的速度，我们肯定不能接受，所以就必须使用索引来进行优化查询速度。</p><p>mysql底层有以下几种数据结构：</p><ul><li><strong>Hash表</strong></li><li><strong>二叉搜索树</strong></li><li><strong>AVL和红黑树</strong></li><li><strong>B树</strong></li><li><strong>B+树</strong></li></ul><p>mysql引擎也有两种常用的：</p><ul><li><strong>InnoDB</strong></li><li><strong>MyiSam</strong></li></ul><h2 id="Mysql底层数据结构"><a href="#Mysql底层数据结构" class="headerlink" title="Mysql底层数据结构"></a>Mysql底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p><img src="https://pic1.zhimg.com/80/v2-7805f7b4bab4c98adc045e3667046398_1440w.jpg" alt="img"></p><p><strong>哈希表</strong>也叫散列表，是根据key和value直接进行访问的数据结构，是快速检索的好方法。</p><p><strong>哈希算法：</strong>也叫散列算法，就是把任意的key值通过哈希函数变换成固定长度的key地址，然后通过这个地址存放数据的算法。</p><p><strong>哈希碰撞：</strong>比如hash(7)和hash(199)值一样，如果只存放一个数据的话，会冲突，解决这种情况最常用的方法是<strong>链地址法</strong>，把碰撞的数据通过链表连接起来，但是计算完hash值之后还需要判断有没有产生hash碰撞，还得重新遍历一边链表，直到找到真正的key对应的数值。</p><p>hash算法的时间复杂度是O(1)，但是考虑到数据检索有一个范围性，hash算法对查询一个数据很高效，但是没办法做到高效查询范围，因此哈希索引不适合做Mysql底层索引。</p><p><img src="https://pic4.zhimg.com/80/v2-4deae667d7d5c9a1a166cb0e8bac9dd6_1440w.jpg" alt="img"></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="https://pic2.zhimg.com/80/v2-032790aff0ddf52b676413573acce776_1440w.jpg" alt="img"></p><p>二叉搜索树也是一支持数据快速检索的数据结构。</p><p>二叉搜索树左子树所有值小于根节点的值，右节点所有值大于根节点的值。</p><p>二叉搜索树的时间复杂度是O(logn)，二叉搜索树还能解决高效范围性查找数据。</p><p>普通的二叉搜索树有个致命缺点，在极端情况下会退化成线性链表，二分查找会变成线性查找，性能严重下降。</p><p><img src="https://pic2.zhimg.com/80/v2-1cc416d59d4c44cf029e9e2103347bb8_1440w.jpg" alt="img"></p><p>例如主键索引，因为一般情况下主键索引都是自增的，采用二叉搜索树作为底层索引的话会导致查询性能严重下降。</p><h3 id="AVL树和红黑树"><a href="#AVL树和红黑树" class="headerlink" title="AVL树和红黑树"></a>AVL树和红黑树</h3><p>由于二叉搜索树极端不平衡的情况，就提出了让树节点自动旋转和调整，以便于随时处于平衡的状态，也就能保证二叉搜索树的查询性能。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>假入二叉搜索树处于一个严重不平衡的状态，那么红黑树就会自动调整节点，通过自动左旋右旋以及节点变色来调整树的形态，使其保持基本的平衡状态（时间复杂度O(logn)）。</p><p>红黑树保证了二叉搜索树不会处于一种极端情况（O(n)），但是又会引出一种新的问题，假入当我们顺序插入1~16个节点后，树形态会产生右倾，但是并没有像二叉搜索树那样的线性夸张，不过如果数据有几百万条的话，查询效率也会变得特别慢，对性能影响也是巨大的。</p><p><img src="https://pic3.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_1440w.jpg" alt="img"></p><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>由于红黑树会产生右倾趋势，所以又引出了一种更为严格的二叉平衡树（AVL树），这个树是一个绝对平衡的二叉树，因此在调整形态上会花费更多的性能。</p><p>比如我们插入1~16个节点，最后AVL树的结构会如下：</p><p><img src="https://pic3.zhimg.com/80/v2-0dad51645707e973b152e44e4b7479c5_1440w.jpg" alt="img"></p><p>从树的形态我们可以看出来，AVL树不会产生右倾的状态，我们查询16号节点，AVL树会比较四次，而红黑树会比较6次，这样就从根本上解决了红黑树的问题。</p><p>所以AVL树的优点有以下几点：</p><ul><li>查找性能好（O(logn)），不会产生极端情况，严重降低性能</li><li>可以实现范围查找和数据排序</li></ul><p>但是AVL树并不适合作为Mysql的底层索引的数据结构，主要是因为数据库查询的瓶颈在于磁盘IO，如果使用AVL树，每个节点只存放一个数据，我们一次磁盘IO只能把一个数据加载到内存中，比如查找节点7，就要进行三次IO，这样会特别耗时间，所以如果要设计数据库索引就要考虑很多情况，首先肯定是每个节点都存放多个数据，而且一次IO就可以加载多个数据到内存中，这就引出了B+树的设计原理。</p><p>磁盘IO有个特点，就是磁盘读取1K的数据和读取1B的数据所消耗的时间是一样的。</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>每个节点可以限制存放的key值数量，如果超过了这个约定的key值数量就自动分裂，比如我们继续插入1~16个节点，如果限制一个节点存放2个key的数量的话，结构如下</p><p><img src="https://pic3.zhimg.com/80/v2-f335bdb3e922a5f334416f557df20848_1440w.jpg" alt="img"></p><p>我们不难看出查询节点16的性能和AVL树一样了，也是经过四次磁盘IO，我们可以考虑每次IO可以读取更多的数据到内存中，可以增加限制的key的数量为6个</p><p><img src="https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_1440w.jpg" alt="img"></p><p>这样对于磁盘IO的次数就可以降低一半，只需要两次就可以读取到。</p><p><strong>B树的优点：</strong></p><ul><li>优秀的检索速度，差查找性能等于O(h*logn)，h是树高，n为每个节点关键词的个数。</li><li>尽可能地减少了磁盘IO的次数，提高了性能。</li><li>可以支持范围查找。</li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>首先看一下B树和B+树的区别：</p><ul><li><p>B树一个节点里存放的是数据，而B+树存放的是索引（地址），所以B树里一个节点    存不了很多数据，但是B+树可以存放很多数索引，B+树叶子节点存放所有数据。</p></li><li><p>B+树叶子节点使用链表串联了起来，便于范围查找。</p><p>对比可以看出，B+树存放的是索引，在单个节点容量有限的情况下，单节点也可以存放大量索引，使得整体树的高度降低，减少了磁盘IO，其次叶子节点是存放真正数据的地方，叶子节点用链表连起来，而且还是有序的，在范围查找中更占有优势。所以mysql索引用的就是B+树，在查找效率和范围查找都有不错的性能。</p></li></ul><p>例如插入1~16个节点：</p><p><img src="https://pic3.zhimg.com/80/v2-bda6661499c51dcff63eb12fd4b3795d_1440w.png" alt="img"></p><h2 id="Mysql引擎"><a href="#Mysql引擎" class="headerlink" title="Mysql引擎"></a>Mysql引擎</h2><p>mysql底层数据引擎以插件的形式设计，最常见的就是<strong>InnoDB</strong>和<strong>Myisam</strong>引擎，用户可以根据个人需求来选择不同的引擎作为mysql底层引擎。</p><p>首先来分析一下两者的区别：</p><ul><li>MyISAM查找性能好，但是不支持事务处理，InnoDB最大特色就是支持ACID兼容的事务功能，而且还支持行级锁</li><li>InnoDB创建表后生成的文件有：<ul><li>frm:创建表的语句</li><li>idb:表里面的数据+索引文件</li></ul></li><li>MyISAM创表后生成的文件有：<ul><li>frm:创建表的语句</li><li>MYD:表里面的数据文件（myisam data）</li><li>MYI:表里面的索引文件（myisam index）</li></ul></li></ul><p>InnoDB把数据和索引放在一起，称为聚集索引，而MyISAM把数据和索引分开，称为非聚集索引。</p><h3 id="MyISAM底层实现"><a href="#MyISAM底层实现" class="headerlink" title="MyISAM底层实现"></a>MyISAM底层实现</h3><p>MyISAM采用非聚集索引，建表时以主键作为key来建立B+树，树的叶子节点存放的是对应数据的物理地址，我们拿到这个物理地址后，就可以到MyISAM数据文件中直接定位到具体的数据记录。</p><p><img src="https://pic1.zhimg.com/80/v2-d9a03627e8e1319e46f42e6963c35e30_1440w.jpg" alt="img"></p><p>当我们为某个字段添加索引时，也会生出该字段的索引树，该字段的索引树的叶子节点同样记录了数据文件中的物理地址，根据这个地址同样可以定位到具体的数据记录。</p><h3 id="InnoDB底层实现"><a href="#InnoDB底层实现" class="headerlink" title="InnoDB底层实现"></a>InnoDB底层实现</h3><p>InnoDB是聚集索引，数据和索引都在一个文件中，建表时，InnoDB会根据主键ID作为key建立索引B+树，B+树叶子节点存放的是主键ID对应的数据。</p><p>我们为某个字段添加索引时，会根据这个字段去建立索引树，索引树节点中存放的是字段的值，根节点存放的是主键的值，拿到主键的key值之后会到主键索引创建的B+树查找对应的数据。</p><p><img src="https://pic2.zhimg.com/80/v2-6e16b355e3d0f05ed8bfb0f7c71de8f1_1440w.jpg" alt="img"></p><p>InnoDB只在主键索引的叶节点存放具体的数据原因是需要节省空间，一个表可能有多个索引，如果每个都创建一个索引树存放具体数据，就会导致数据文件变得十分巨大，数据冗杂，因此采用上面那种方式就可以牺牲较少的查询性能节省巨大的磁盘空间，还是蛮好的。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>由上面可以得知，MyISAM查询性能更好，因为MyISAM查询一次就能获取到数据，查询到物理地址就直接去数据文件中寻找。</p><p>而InnoDB两次才行，第一次查询到叶子节点的主键索引，第二次根据主键索引去主键索引创建的B+树中去寻找。</p><h2 id="什么时候需要创建索引呢？"><a href="#什么时候需要创建索引呢？" class="headerlink" title="什么时候需要创建索引呢？"></a>什么时候需要创建索引呢？</h2><ul><li>查询频繁的字段</li><li>唯一性太差的字段不适合创建索引，即使这个字段频繁作为查询条件。</li><li>更新频繁的字段不适合创建索引，因为每次都需要维护B+树，导致性能差。</li></ul><h2 id="最终选择B-树的原因？"><a href="#最终选择B-树的原因？" class="headerlink" title="最终选择B+树的原因？"></a>最终选择B+树的原因？</h2><ul><li>hash特别快，但是只能针对一个值</li><li>AVL和红黑树，在大数据的情况下，磁盘IO操作过多</li><li>B树每个节点存放的是数据，节点存放的分支太少了。</li><li>B+树节点存储的索引是索引和指针（引用指向下一个地址），可以存储大量索引，同时最终数据在叶子节点上，并且有引用横向链接，可以在2~3次的IO操作中完成千万级别表的操作。</li><li>建议索引为主键索引，有自增操作，适合范围查找。</li></ul><blockquote><p>文章参考自：<a href="https://zhuanlan.zhihu.com/p/113917726" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113917726</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
</feed>
