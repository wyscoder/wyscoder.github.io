<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wys&#39;blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wysblogs.top/"/>
  <updated>2020-07-11T13:13:58.809Z</updated>
  <id>http://wysblogs.top/</id>
  
  <author>
    <name>wys</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM虚拟机知识点</title>
    <link href="http://wysblogs.top/2020/07/11/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://wysblogs.top/2020/07/11/JVM虚拟机知识点/</id>
    <published>2020-07-11T00:50:51.000Z</published>
    <updated>2020-07-11T13:13:58.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM虚拟机知识点"><a href="#JVM虚拟机知识点" class="headerlink" title="JVM虚拟机知识点"></a>JVM虚拟机知识点</h1><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>运行时数据区就是jvm运行java文件时，会把管理的内存分为好几个部分，每一个部分就是一个运行时数据区。</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="%5Cupload%5Cjvm%5C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区"></p><h3 id="线程共享的区域"><a href="#线程共享的区域" class="headerlink" title="线程共享的区域"></a>线程共享的区域</h3><p><strong>方法区：</strong>存放类信息，静态变量，常量，运行时常量池 的区域</p><p><strong>堆：</strong>几乎所有的对象存放的地方，同时也是GC的主要区域</p><p>​    数组也存放在堆中</p><ul><li><strong>分代处理：</strong>目的是为了更好的回收内存和分配内存<ul><li><strong>新生代：</strong>Eden空间，From Survivor空间，To Survivor空间</li><li><strong>老年代：</strong>存活周期特别长的对象</li></ul></li><li><strong>空间结构：</strong>逻辑连续，物理不连续</li><li><strong>TLAB（线程本地分配缓存）：</strong>线程私有，空间小，避免同步带来的效率问题，从而提高分配效率</li><li><strong>OOM：</strong>内存没有办法分配，堆也无法扩展，就会报出OOM异常</li></ul><p>​    <strong>扩展：</strong>一般用逃逸分析法来判断对象是否分配在堆中或者是栈中，如果一个对象是随着方法的运行而出现，方法结束，对象也结束的话，就可以认为这个对象没有逃逸出方法，因此会分配在栈中</p><h3 id="线程私有的区域"><a href="#线程私有的区域" class="headerlink" title="线程私有的区域"></a>线程私有的区域</h3><p><strong>栈：</strong>    </p><ul><li>生命周期与线程相同</li><li>描述的<strong>java方法执行的内存模型</strong><ul><li><strong>栈帧：</strong>每执行一个方法就装入一个栈帧，每运行一个方法弹出<ul><li><strong>局部变量表：</strong>基本单位是变量槽，一个变量槽是四字节，如果遇到大于四字节的变量，就需要分成多部份来装。<ul><li>基本数据类型</li><li>对象句柄</li><li>方法参数</li><li>方法的局部变量</li></ul></li><li>操作数栈</li><li>动态链接</li><li>方法返回地址</li><li>……</li></ul></li></ul></li><li>可能产生的异常：OutofMemoryError，StackOverflowError</li></ul><p><strong>本地方法栈：</strong>为navice方法服务</p><p><strong>程序计数器：</strong>就是字节码执行的指令行号，如果是native方法就为空</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>从JVM角度来说：</p><ul><li><p>检查类是否被加载</p></li><li><p>为对象分配内存空间</p></li><li><p>初始化对象字段</p></li><li><p>设置对象头</p><ul><li><p><strong>对象头</strong></p><ul><li><strong>MarkWork</strong>：记录了对象和锁有关的信息</li></ul><p><img src="%5Cupload%5Cjvm%5Cmarkword.png" alt="markword"></p><ul><li><strong>指向类的指针：</strong></li><li><strong>数组长度：</strong></li></ul></li></ul></li><li><p>执行构造方法</p></li></ul><p><img src="%5Cupload%5Cjvm%5C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="对象创建过程"></p><h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。</p><p><img src="%5Cupload%5Cjvm%5C%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="img"></p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>如果使用指针访问访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。</p><p><img src="%5Cupload%5Cjvm%5C%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="指针访问对象"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="%5Cupload%5Cjvm%5C%E7%B1%BB%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F.png" alt="类的生存周期"></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>1、通过全限定类名获取此类的二进制字节流</p><p>2、将字节流所代表的静态存储结构转换为方法去的运行时数据结构</p><p>3、在内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口</p><p><strong>加载阶段是可控性最强的，可以重写loadClass()方法，数组类型不通过类加载器加载，而是由虚拟机直接创建的。</strong></p><p><strong>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就开始了</strong></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="%5Cupload%5Cjvm%5C%E9%AA%8C%E8%AF%81.png" alt="验证"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>这个阶段是为了给类变量分配内存并且设置初始值的阶段，内存都在 <strong>方法区中分配</strong></p><p>1、这个阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化的时候跟着对象一起分配到java堆中。</p><p>2、初始值默认都是0或者是null，如果用final修饰的话，初始值可以指定成想要的样子。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个阶段是把符号引用解析成直接引用的过程，解析动作主要针对 <strong>接口、字段、类方法】接口方法、方法类型、方法句柄、调用限定符等7类符号引用进行：</strong></p><p><strong>符号引用：</strong>就是用一组符号描述目标，可以是任意字面量。</p><p><strong>直接引用：</strong>只有符号引用是不够的，还需要明确知道方法所在的位置，java虚拟机存在一个方法表，调用类方法是，只需要根据符号引用找到方法表中偏移量就能直接调用该方法。</p><p>总的来说，解析过程就是把符号引用替换成直接引用的过程，也就是获得方法、字段指针或者偏移量的过程。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也就是执行字节码，初始化过程是执行类构造器<code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code>自带锁，线程安全，并且可能会造成死锁，而且这种死锁很难被发现</p><p>初始化阶段，有五种情况，必须对类进行初始化：</p><ul><li>第一种情况：<ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用，例如Class.forname()，newInstance()等等情况下，如果没有初始化，就会触发初始化。</li><li>初始化一个类的时候，父类没初始化，先初始化父类</li><li>虚拟机启动时，先初始化用户必须定义的主类</li><li>MethodHandle和VarHandle可以看作轻量级反射调用机制，而想要使用这两个调用就必须先使用findStaticVarHandle来初始化调用的类</li><li>JDK8新加入默认方法，被default关键字修饰接口方法时，如果这个实现类发生了初始化，接口要在其之前被初始化。</li></ul><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载表示这个类的Class对象被GC</p><p>卸载类需要满足三个条件：</p><p>1、该类的所有实例对象都被GC。也就是堆里面没有这个对象，</p><p>2、该类没有在其他任何地方被引用</p><p>3、该类的类加载器的实例已被GC</p><p>自定义类的加载器可能被卸载，但是jdk自带的类加载器不会被卸载，比如</p><p>BootstrapClassLoader，PlatformClassstrapClassLoader，AppClassLoader，肯定不会被回收，因此使用我们自定义加载器加载的类是可以被卸载的。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="JVM内存分配与回收"><a href="#JVM内存分配与回收" class="headerlink" title="JVM内存分配与回收"></a>JVM内存分配与回收</h3><p>java自动内存管理主要是针对对象内存的回收和对象内存的分配。</p><p>堆是垃圾收集器主要管理的地方。因此也被称为GC堆。</p><p>JAVA堆的结构</p><p><img src="%5Cupload%5Cjvm%5C%E5%A0%86%E7%BB%93%E6%9E%84.png" alt="堆结构"></p><p>分为 <strong>新生代：Eden，From Survivor0，To Survivo1</strong>，<strong>老年代：Old Memeory</strong></p><p>进一步划分的目的 <strong>是为了更好的回收和分配内存</strong></p><h4 id="常见的分配策略"><a href="#常见的分配策略" class="headerlink" title="常见的分配策略"></a>常见的分配策略</h4><p>GC之后，Eden区和幸存区都被清空， from 和 to 交换角色，不管怎么样都要保证to的幸存区为空， to 被填满后，会将所有对象移动到老年代中。</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><p>新生代和老年代有着不同的回收算法，根据每个区域的特点不同选择合适的垃圾收集算法，</p><p>一般情况下，对象在eden区分配，当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><ul><li>新生代GC（Minor GC）：指发生新生代的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快</li><li>老年代GC（Major GC/Full GC）：只发生在老年代GC，出现Major GC经常会伴随至少一次的 Minor GC（不一定），Major GC的速度一半回避Minor GC慢10倍以上。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test08</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] a,b;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">        b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p><strong>大对象是需要大量连续内存空间的对象</strong>（比如：字符串，数组等）</p><p>原因是为了避免分配内存时，分配担保机制带来的复制而降低效率。</p><p><strong>长期存活的对象进入老年代</strong>，在eden出生并经过1次存活后，会进入到幸存区，在幸存区经过多次存活（默认是15次），就会进入老年代。</p><p>可以通过<code>-XX:MaxTenuringThreshold</code>进行设置</p><h3 id="对象存活"><a href="#对象存活" class="headerlink" title="对象存活"></a>对象存活</h3><p>堆中几乎存放着所有的对象实例，对堆垃圾回收之前必须要先判断是否存活</p><p><img src="%5Cupload%5Cjvm%5C%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB.png" alt="对象是否存活"></p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给每个对象实例添加一个引用计数器，引用时加1，引用失效时减一，当计数器为0时，就判断这个对象已经不再使用，就回收掉。</p><p>这种方法实现简单，效率高，但是目前主流的虚拟机并没有用这种方法，主要是没办法解决循环引用问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test09</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test09 t1 = <span class="keyword">new</span> Test09();</span><br><span class="line">        Test09 t2 = <span class="keyword">new</span> Test09();</span><br><span class="line">        t1.instance = t2;</span><br><span class="line">        t2.instance = t1;</span><br><span class="line">        t1 = <span class="keyword">null</span>;</span><br><span class="line">        t2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>思想就是通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象不可用。</p><p><img src="%5Cupload%5Cjvm%5C%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="可达性分析"></p><p>可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈（Native方法）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ul><h4 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h4><ul><li><p>强引用</p><ul><li>最普遍的引用，垃圾回收器绝不会回收它，当内存空间不足，jvm宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会考随意回收。</li></ul></li><li><p>软引用</p><ul><li>可有可无，内存足够就不回收，内存不够就会回收</li></ul></li><li><p>弱引用</p><ul><li>可有可无，这个生命周期特别短，如果垃圾回收器发现了它，不管内存够不够，都会回收。但是垃圾回收器优先级很低，不一定很快就发现。</li></ul></li><li><p>虚引用</p><ul><li><p>与其他几种不同，这个不会决定对象的生命周期，如果一个对象持有虚引用，那么在任何时候都有可能被垃圾回收。</p></li><li><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p></li><li><p>与其他几种引用的区别：回收一个对象前，发现它还有虚引用，就会在回收对象内存之前，把它加入到引用队列，可以在内存回收之前来对这个对象进行操作</p><p><strong>使用软引用情况多，软引用可以加速JVM对垃圾的回收速度，客户以维护系统的运行安全，防止内存溢出等问题的发生。</strong></p></li></ul></li></ul><h4 id="不可达对象不一定会被GC掉"><a href="#不可达对象不一定会被GC掉" class="headerlink" title="不可达对象不一定会被GC掉"></a>不可达对象不一定会被GC掉</h4><p>要宣告一个对象死亡必须经过两次标记，第一次标记的时候只是判断是否有必要执行finalize方法，当对象没有覆盖finalize方法，或者finalize方法已经被调用过时，就没必要GC掉，除非第二次GC时候还是没有和引用链有关联。</p><h4 id="怎么判断一个常量是废弃常量"><a href="#怎么判断一个常量是废弃常量" class="headerlink" title="怎么判断一个常量是废弃常量"></a>怎么判断一个常量是废弃常量</h4><p>当常量池中存在的字符串“abc”没有任何对象引用的时候，就说明它是废弃常量，下次GC，就会回收掉。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><strong>标记-清除算法</strong></li><li><strong>复制算法</strong></li><li><strong>标记-整理算法</strong></li><li><strong>分代收集算法</strong></li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>就是标记和清除阶段，首先比较出所有需要回收的对象，都打上标记，再进行清除</p><p><strong>会造成两种问题：</strong></p><ul><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决这个效率问题，就出现了复制算法，将内存分为大小相同的两部分，每次就只用一半，用完就清理掉，然后把剩下的放到另一块中。</p><ul><li>空间问题（花销太大）</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>过程和标记清除算法一样，后面会增加一个整理过程。</p><ul><li>效率问题很大</li></ul><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>就是把堆分为新生代和老年代，然后根据不同的特点进行不同的算法。</p><h4 id="为什么要分为新生代和老年代？"><a href="#为什么要分为新生代和老年代？" class="headerlink" title="为什么要分为新生代和老年代？"></a>为什么要分为新生代和老年代？</h4><p>因为每个对象的存活时间不一样，有的特别长，有的特别短，因此需要用不同的分区来进行分别管理。</p><h4 id="为什么要用两个Survivor？"><a href="#为什么要用两个Survivor？" class="headerlink" title="为什么要用两个Survivor？"></a>为什么要用两个Survivor？</h4><p>因为要管理内存碎片，而其中对象存活时间一般很短，用复制算法比较有效率</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul><li><strong>Serial收集器</strong></li><li><strong>ParNew收集器</strong></li><li><strong>Parallel Scavenge收集器</strong></li><li><strong>CMS收集器</strong></li><li><strong>G1收集器</strong></li></ul><p>如果说收集算法是理论，那么这个垃圾收集器就是内存回收的具体实现。</p><p><strong>我们需要根据具体应用场景选择合适自己的垃圾收集器</strong></p><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>很古老的收集齐了，历史悠久，他是个单线程垃圾收集器，收集垃圾的时候还必须暂停其他所有的工作进程，直到他收集完成。</p><p><strong>新生代采用复制算法，老年代采用标记整理算法。</strong></p><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>就是Serial收集器的多线程版本，除了使用多线程收集垃圾外，其余行为和Serial收集器完全一样。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p><p>只有这个收集器能与CMS收集器配合工作</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器也是使用复制算法的多线程收集器，他看上去几乎和ParNew一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC <span class="comment">//使用Parallel 收集器 + 老年代串行</span></span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC <span class="comment">//使用Parallel收集器 + 老年代并行</span></span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge收集器 关注点是吞吐量（高效率的利用CPU）。</strong></p><p><strong>CMS等垃圾收集器的关注点更多的是用户现成的停顿时间（提高用户体验）。</strong></p><p><strong>所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><strong>Serial收集器的老年代版本</strong></p><ul><li>jdk1.5版本之前和Parallel Old 搭配使用</li><li>作为CMS收集器的后备方案</li></ul><h4 id="Parallel-Old收集"><a href="#Parallel-Old收集" class="headerlink" title="Parallel Old收集"></a>Parallel Old收集</h4><p>Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”，注重吞吐量以及CPU资源，可以优先考虑。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p><strong>G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="jvm" scheme="http://wysblogs.top/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://wysblogs.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存穿透，缓存击穿，缓存雪崩</title>
    <link href="http://wysblogs.top/2020/07/10/redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    <id>http://wysblogs.top/2020/07/10/redis缓存穿透，缓存击穿，缓存雪崩/</id>
    <published>2020-07-10T07:11:43.000Z</published>
    <updated>2020-07-10T07:53:32.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis缓存穿透，缓存击穿，缓存雪崩"><a href="#Redis缓存穿透，缓存击穿，缓存雪崩" class="headerlink" title="Redis缓存穿透，缓存击穿，缓存雪崩"></a>Redis缓存穿透，缓存击穿，缓存雪崩</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><strong>缓存穿透：</strong>key对应的数据源不存在，每次针对这个key的请求从缓存中获取不到，请求都会到数据源，从而可能压垮数据源。比如使用一个数据库和redis都不存在的用户id获取该用户信息，若有人利用此漏洞进行攻击，可能会压垮数据库。</li><li><strong>缓存击穿：</strong>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并缓存在redis中，这时候大并发请求可能瞬间会把后端DB压垮。</li><li><strong>缓存雪崩：</strong>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，也会给后端DB带来很大压力。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="缓存穿透解决方案"><a href="#缓存穿透解决方案" class="headerlink" title="缓存穿透解决方案"></a>缓存穿透解决方案</h3><p>最常用的就是布隆过滤器，将所有可能的数据hash到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免s对底层存储系统的查询压力。</p><p>其次，还有一个更简单的方法，如果一个查询返回的数据为空，仍然把这个空结果缓存下在，但是时间很短，最长不超过5分钟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">GetProductListNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line"></span><br><span class="line">    String cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//数据库查询不到，为空</span></span><br><span class="line">        cacheValue = GetProductListFromDB();</span><br><span class="line">        <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果发现为空，设置个默认值，也缓存起来</span></span><br><span class="line">            cacheValue = string.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存击穿解决方案"><a href="#缓存击穿解决方案" class="headerlink" title="缓存击穿解决方案"></a>缓存击穿解决方案</h3><p>key可能会在某些时间段被超高并发的去访问，是一种非常“热点”的数据。这时候，需要考虑的到缓存击穿。</p><p><strong>使用互斥锁(mutex key)</strong></p><p>常用的做法，简单来说，就是在缓存时效的时候，不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，在进行load db的操作并回设缓存；否则就重试整个get缓存的方法。00</p><p><strong>setnx当键key不存在的情况下，将键的key值设置为value，若已经存在就不做任何操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;</span><br><span class="line">      String value = redis.get(key);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期</span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">      <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功</span></span><br><span class="line">               value = db.get(key);</span><br><span class="line">                      redis.set(key, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                      sleep(<span class="number">50</span>);</span><br><span class="line">                      get(key);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;      </span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="缓存雪崩解决方案"><a href="#缓存雪崩解决方案" class="headerlink" title="缓存雪崩解决方案"></a>缓存雪崩解决方案</h3><p>这个对底层系统的冲击特别可怕，大多数设计者都是通过加锁或者队列的方式来保证不会有大量线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开，在原有的失效时间上增加一个随机值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">GetProductListNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    String lockKey = cacheKey;</span><br><span class="line"></span><br><span class="line">    String cacheValue = CacheHelper.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockKey) &#123;</span><br><span class="line">            cacheValue = CacheHelper.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cacheValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cacheValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//这里一般是sql查询数据</span></span><br><span class="line">                cacheValue = GetProductListFromDB(); </span><br><span class="line">                CacheHelper.Add(cacheKey, cacheValue, cacheTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁只是减轻数据库压力，并没有提高系统吞吐量，假设在高并发下，缓存重建期间key是锁着的，来10000个请求，9999个都在阻塞，会导致用户请求超时，治标不治本。</p><p><strong>随机值代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">GetProductListNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cacheTime = <span class="number">30</span>;</span><br><span class="line">    String cacheKey = <span class="string">"product_list"</span>;</span><br><span class="line">    <span class="comment">//缓存标记</span></span><br><span class="line">    String cacheSign = cacheKey + <span class="string">"_sign"</span>;</span><br><span class="line"></span><br><span class="line">    String sign = CacheHelper.Get(cacheSign);</span><br><span class="line">    <span class="comment">//获取缓存值</span></span><br><span class="line">    String cacheValue = CacheHelper.Get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (sign != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue; <span class="comment">//未过期，直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHelper.Add(cacheSign, <span class="string">"1"</span>, cacheTime);</span><br><span class="line">        ThreadPool.QueueUserWorkItem((arg) -&gt; &#123;</span><br><span class="line">      <span class="comment">//这里一般是 sql查询数据</span></span><br><span class="line">            cacheValue = GetProductListFromDB(); </span><br><span class="line">          <span class="comment">//日期设缓存时间的2倍，用于脏读</span></span><br><span class="line">          CacheHelper.Add(cacheKey, cacheValue, cacheTime * <span class="number">2</span>);                 </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于缓存雪崩的解决办法，有三种：</p><ul><li>使用锁或队列，不过不建议，会降低用户体验</li><li>设置过期标志更新缓存</li><li>为key设置不同的缓存失效时间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://wysblogs.top/categories/redis/"/>
    
    
      <category term="redis" scheme="http://wysblogs.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模式</title>
    <link href="http://wysblogs.top/2020/07/10/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wysblogs.top/2020/07/10/生产者消费者模式/</id>
    <published>2020-07-10T04:52:39.000Z</published>
    <updated>2020-07-10T08:51:28.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>生产者消费者问题是线程模型中的经典问题；<strong>生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据</strong>。</p><h3 id="保证同一时刻只有一个线程读或者写："><a href="#保证同一时刻只有一个线程读或者写：" class="headerlink" title="保证同一时刻只有一个线程读或者写："></a>保证同一时刻只有一个线程读或者写：</h3><ul><li>用synchronized对存储加锁，然后用object原生的wait()和notify()做同步</li><li>用concurrent.locks.Lock，然后用condition的await()和signal()做同步</li><li>使用信号量semaphore</li></ul><h3 id="保证存储内部的读写唯一"><a href="#保证存储内部的读写唯一" class="headerlink" title="保证存储内部的读写唯一"></a>保证存储内部的读写唯一</h3><ul><li>直接使用concurrent.BlockingQueue</li><li>使用PipedInputStream/PipedOutputStream</li></ul><h2 id="synchronized、wait-、nofity"><a href="#synchronized、wait-、nofity" class="headerlink" title="synchronized、wait()、nofity()"></a>synchronized、wait()、nofity()</h2><ul><li>wait()：当缓冲区已满或者为空时，生产者/消费者线程停止自己的执行，放弃锁，让自己处于等待状态，让其他线程执行。</li><li>notify()：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。</li></ul><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.test_wys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/10 16:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: Test_05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_05 tt = <span class="keyword">new</span> Test_05();</span><br><span class="line">        tt.new Producter(<span class="string">"producter[1]"</span>).start();</span><br><span class="line">        tt.new Producter(<span class="string">"producter[2]"</span>).start();</span><br><span class="line">        tt.new Consumer(<span class="string">"consumer[1]"</span>).start();</span><br><span class="line">        tt.new Consumer(<span class="string">"consumer[2]"</span>).start();</span><br><span class="line">        tt.new Consumer(<span class="string">"consumer[3]"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(queue.size()==size)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"满了！"</span>+name+<span class="string">"等待"</span>);</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(name+<span class="string">" product===&gt;production_"</span>+i);</span><br><span class="line">                    queue.offer(<span class="string">"production_"</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(queue.isEmpty())&#123;</span><br><span class="line">                        System.out.println(<span class="string">"空的！"</span>+name+<span class="string">"等待"</span>);</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String s = queue.poll();</span><br><span class="line">                    System.out.println(name+<span class="string">": consume=====&gt;"</span>+s);</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lock、Condition、await-、signal"><a href="#Lock、Condition、await-、signal" class="headerlink" title="Lock、Condition、await()、signal()"></a>Lock、Condition、await()、signal()</h2><p>实现起来和上面一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.test_wys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/10 16:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: Test_06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_06</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//可重入锁</span></span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_06 tt = <span class="keyword">new</span> Test_06();</span><br><span class="line">        tt.new Producter(<span class="string">"producter[1]"</span>).start();</span><br><span class="line">        tt.new Producter(<span class="string">"producter[2]"</span>).start();</span><br><span class="line">        tt.new Consumer(<span class="string">"consumer[1]"</span>).start();</span><br><span class="line">        tt.new Consumer(<span class="string">"consumer[2]"</span>).start();</span><br><span class="line">        tt.new Consumer(<span class="string">"consumer[3]"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(queue.size()==size    )&#123;</span><br><span class="line">                    System.out.println(<span class="string">"满了！"</span>+name+<span class="string">"等待"</span>);</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(name+<span class="string">" product===&gt;production_"</span>+i);</span><br><span class="line">                queue.offer(<span class="string">"production_"</span>+i);</span><br><span class="line">                i++;</span><br><span class="line">                condition.signalAll();;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">while</span>(queue.isEmpty())&#123;</span><br><span class="line">                    System.out.println(<span class="string">"空的！"</span>+name+<span class="string">"等待"</span>);</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String s = queue.poll();</span><br><span class="line">                System.out.println(name+<span class="string">": consume=====&gt;"</span>+s);</span><br><span class="line">                condition.signalAll();</span><br><span class="line">                lock.unlock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>在并发编程中，JUC中有一个接口BlockingQueue，有以下几个实现的阻塞队列：</p><ul><li><strong>java.util.concurrent.ArrayBlockingQueue</strong></li><li><strong>java.util.concurrent.LinkedBlockingQueue</strong></li><li><strong>java.util.concurrent.SynchronousQueue</strong></li><li><strong>java.util.concurrent.PriorityBlockingQueue</strong></li></ul><p>我们可以使用FIFO队列，来实现生产消费者模型</p><p>在队列的基础上，使用Lock实现了同步队列，主要是两种方法，</p><ul><li>put()方法，容量达到最大时，自动阻塞。</li><li>take()方法，容量为0时，自动阻塞。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: wys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者消费者模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/7/10 12:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: Test_04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_04 m = <span class="keyword">new</span> Test_04();</span><br><span class="line">        m.new Producter(<span class="string">"producter[1]"</span>).start();</span><br><span class="line">        m.new Producter(<span class="string">"producter[2]"</span>).start();</span><br><span class="line">        m.new Consumer(<span class="string">"consumer[1]"</span>).start();</span><br><span class="line">        m.new Consumer(<span class="string">"consumer[2]"</span>).start();</span><br><span class="line">        m.new Consumer(<span class="string">"consumer[3]"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(blockingQueue) &#123;</span><br><span class="line">                        blockingQueue.put(<span class="string">"producter_"</span>+i);</span><br><span class="line">                        System.out.println(name+<span class="string">" product =====&gt; production_"</span>+i);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    System.out.println(name+<span class="string">" consumer ====&gt;"</span>+blockingQueue.take());</span><br><span class="line">                    sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore信号量，可以控制对互斥资源的访问的线程数。</p><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    Semaphore notFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);<span class="comment">//可以生产的数量，生产一个少一个 permit</span></span><br><span class="line">    Semaphore notEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);<span class="comment">//可以消费的数量，消费一个多一个 permit</span></span><br><span class="line">    Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);<span class="comment">//控制 queue 的互斥访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">notFull.acquire();</span><br><span class="line">mutex.acquire();</span><br><span class="line">queue.offer(<span class="string">"production_"</span>+i);</span><br><span class="line">System.out.println(name+<span class="string">"：product====&gt;production_"</span>+i);</span><br><span class="line">i++;</span><br><span class="line">mutex.release();</span><br><span class="line">notEmpty.release();</span><br><span class="line">sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">notEmpty.acquire();</span><br><span class="line">mutex.acquire();</span><br><span class="line">String s = queue.poll();</span><br><span class="line">System.out.println(name+<span class="string">"：consume====&gt;"</span>+s);</span><br><span class="line">mutex.release();</span><br><span class="line">notFull.release();</span><br><span class="line">sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Main main = <span class="keyword">new</span> Main();</span><br><span class="line">main.new Producter(<span class="string">"producter[1]"</span>).start();</span><br><span class="line">main.new Producter(<span class="string">"producter[2]"</span>).start();</span><br><span class="line">main.new Consumer(<span class="string">"consumer[1]"</span>).start();</span><br><span class="line">main.new Consumer(<span class="string">"consumer[2]"</span>).start();</span><br><span class="line">main.new Consumer(<span class="string">"consumer[3]"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PipedInputStream、PipedOutputStream"><a href="#PipedInputStream、PipedOutputStream" class="headerlink" title="PipedInputStream、PipedOutputStream"></a>PipedInputStream、PipedOutputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">PipedInputStream pis = <span class="keyword">new</span> PipedInputStream(size);</span><br><span class="line">PipedOutputStream pos = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pis.connect(pos);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Main main = <span class="keyword">new</span> Main();</span><br><span class="line">main.new Producter(<span class="string">"producter[1]"</span>).start();</span><br><span class="line">main.new Producter(<span class="string">"producter[2]"</span>).start();</span><br><span class="line">main.new Consumer(<span class="string">"consumer[1]"</span>).start();</span><br><span class="line">main.new Consumer(<span class="string">"consumer[2]"</span>).start();</span><br><span class="line">main.new Consumer(<span class="string">"consumer[3]"</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producter</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (pos) &#123;<span class="comment">//避免产生相同名称的产品，如果不在意可以去掉</span></span><br><span class="line">pos.write(i);</span><br><span class="line">pos.flush();</span><br><span class="line">System.out.println(name+<span class="string">"：product====&gt;production_"</span>+i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(name+<span class="string">"：consume====&gt;production_"</span>+pis.read());</span><br><span class="line">sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">3500</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wysblogs.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wysblogs.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>dubbo基础</title>
    <link href="http://wysblogs.top/2020/07/09/dubbo%E5%9F%BA%E7%A1%80/"/>
    <id>http://wysblogs.top/2020/07/09/dubbo基础/</id>
    <published>2020-07-08T23:21:36.000Z</published>
    <updated>2020-07-11T13:16:14.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dubbo基础"><a href="#Dubbo基础" class="headerlink" title="Dubbo基础"></a>Dubbo基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</p><p>dubbo是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。</p><p>使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。</p><h2 id="Dubbo通信协议"><a href="#Dubbo通信协议" class="headerlink" title="Dubbo通信协议"></a>Dubbo通信协议</h2><p>Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p><p>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低</p><h2 id="与spring-cloud区别"><a href="#与spring-cloud区别" class="headerlink" title="与spring cloud区别"></a>与spring cloud区别</h2><p><img src="%5Cupload%5Cdubbo%5Cdubbo%E4%B8%8Espringcloud%E5%8C%BA%E5%88%AB.jpg" alt="dubbo与springcloud区别"></p><h2 id="协议支持类型"><a href="#协议支持类型" class="headerlink" title="协议支持类型"></a>协议支持类型</h2><ul><li>dubbo://（推荐）</li><li>rmi://</li><li>hessian://</li><li>http://</li><li>webservice://</li><li>thrift://</li><li>memcached://</li><li>redis://</li><li>rest://</li></ul><h2 id="需要web容器吗"><a href="#需要web容器吗" class="headerlink" title="需要web容器吗"></a>需要web容器吗</h2><p>不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。</p><h2 id="内置了几种服务容器"><a href="#内置了几种服务容器" class="headerlink" title="内置了几种服务容器"></a>内置了几种服务容器</h2><ul><li>Spring Container</li><li>Jetty Container</li><li>Log4j Container</li></ul><p>Dubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。</p><h2 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h2><p><img src="%5Cupload%5Cdubbo%5Cdubbo%E8%8A%82%E7%82%B9.jpg" alt="dubbo节点"></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="%5Cupload%5Cdubbo%5Cdubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="dubbo服务注册与发现的流程图"></p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</p><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><p>1）Spring 配置方式<br>2）Java API 配置方式</p><h2 id="Dubbo启动时如果依赖的服务不可用会怎样？"><a href="#Dubbo启动时如果依赖的服务不可用会怎样？" class="headerlink" title="Dubbo启动时如果依赖的服务不可用会怎样？"></a>Dubbo启动时如果依赖的服务不可用会怎样？</h2><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=”true”，可以通过 check=”false” 关闭检查。</p><h2 id="Dubbo支持服务多协议吗？"><a href="#Dubbo支持服务多协议吗？" class="headerlink" title="Dubbo支持服务多协议吗？"></a>Dubbo支持服务多协议吗？</h2><p>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</p><h2 id="当一个服务接口有多种实现时怎么做？"><a href="#当一个服务接口有多种实现时怎么做？" class="headerlink" title="当一个服务接口有多种实现时怎么做？"></a>当一个服务接口有多种实现时怎么做？</h2><p>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</p><h2 id="Dubbo优点"><a href="#Dubbo优点" class="headerlink" title="Dubbo优点"></a>Dubbo优点</h2><ul><li>透明的远程化调用，就像调用本地方法一样调用远程方法，只需要简单的配置，没有任何api侵入</li><li>软负载均衡及容错机制</li><li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li><li>Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</li></ul><h2 id="Dubbo核心组件"><a href="#Dubbo核心组件" class="headerlink" title="Dubbo核心组件"></a>Dubbo核心组件</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="dubbo" scheme="http://wysblogs.top/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://wysblogs.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>如何开始阅读框架源码？</title>
    <link href="http://wysblogs.top/2020/07/02/%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%EF%BC%9F/"/>
    <id>http://wysblogs.top/2020/07/02/如何开始阅读框架源码？/</id>
    <published>2020-07-01T16:31:47.000Z</published>
    <updated>2020-07-04T03:27:28.469Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何开始阅读框架源码？"><a href="#如何开始阅读框架源码？" class="headerlink" title="如何开始阅读框架源码？"></a>如何开始阅读框架源码？</h1><blockquote><p>1、首先学习阅读中所需要的基础的知识</p><p>2、要带着目的去阅读</p><p>3、看一看官方文档</p><p>4、要学会使用这个框架</p><p>5、了解整体模块架构设计</p><p>6、从高到底梳理每一个模块</p><p>7、一直到可以运行起来</p></blockquote><h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><p>在学习某种框架之前，一定要确保自己掌握了部分基础知识，例如这个java基础，设计模式等等，确保自己能够理解这个框架最深层所隐藏的知识或者技术。</p><h2 id="2、确定目的"><a href="#2、确定目的" class="headerlink" title="2、确定目的"></a>2、确定目的</h2><p>一定要清楚自己阅读源码是为了干什么，是为了解决工作中出现的问题，还是为了学习框架的中所蕴含的知识，亦或是想了解这个框架所需要应用的业务场景。</p><h2 id="3、官方文档"><a href="#3、官方文档" class="headerlink" title="3、官方文档"></a>3、官方文档</h2><p>官方文档很重要，它能让你对这个框架有个大概的了解，以及每个模块的各个作用与联系，之后再把整体框架架构。</p><h2 id="4、学会使用"><a href="#4、学会使用" class="headerlink" title="4、学会使用"></a>4、学会使用</h2><p>了解一下这个框架的基本用法，官网都应该有 Quick Start，先运行运行demo，再测试一些其他高级功能，知道这个框架究竟是怎么使用的。</p><h2 id="5、框架架构"><a href="#5、框架架构" class="headerlink" title="5、框架架构"></a>5、框架架构</h2><p>了解框架的设计模式，和设计思路，然后思考思考去猜一猜这样写有什么用，之后顺着思路往下走。</p><h2 id="6、从顶至下"><a href="#6、从顶至下" class="headerlink" title="6、从顶至下"></a>6、从顶至下</h2><p>学框架一定要从上往下分析各个模块的作用和功能，分清各个主次关系，理清逻辑。</p><h2 id="7、运行起来"><a href="#7、运行起来" class="headerlink" title="7、运行起来"></a>7、运行起来</h2><p>最后一点一点的运行出来，至此，大概就可以很大程度上的去理解这个框架的思想。</p><h2 id="8、不懂就问"><a href="#8、不懂就问" class="headerlink" title="8、不懂就问"></a>8、不懂就问</h2><p>如果遇到不明白的地方，可以去各个论坛，各个帖子去百度，去询问，也可以去查看官方文档，把搞懂，才能受益匪浅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="经验" scheme="http://wysblogs.top/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="经验" scheme="http://wysblogs.top/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>并发知识点</title>
    <link href="http://wysblogs.top/2020/07/01/%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://wysblogs.top/2020/07/01/并发知识点/</id>
    <published>2020-07-01T13:44:31.000Z</published>
    <updated>2020-07-10T14:58:47.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Serializable知识点</title>
    <link href="http://wysblogs.top/2020/07/01/Serializable%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://wysblogs.top/2020/07/01/Serializable知识点/</id>
    <published>2020-07-01T00:26:24.000Z</published>
    <updated>2020-07-01T06:49:37.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Serializable知识点"><a href="#Serializable知识点" class="headerlink" title="Serializable知识点"></a>Serializable知识点</h1><h2 id="Serializable接口简介"><a href="#Serializable接口简介" class="headerlink" title="Serializable接口简介"></a>Serializable接口简介</h2><p>一个对象序列化接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</p><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>序列化是对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以很容易的去存储和传输数据。</p><p><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化</p><p><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的返序列化</p><h2 id="什么情况下需要序列化"><a href="#什么情况下需要序列化" class="headerlink" title="什么情况下需要序列化"></a>什么情况下需要序列化</h2><p>1、网络进行传输</p><p>2、需要对象的状态信息持久化</p><h2 id="为什么要定义serialversionUID变量"><a href="#为什么要定义serialversionUID变量" class="headerlink" title="为什么要定义serialversionUID变量"></a>为什么要定义serialversionUID变量</h2><p>1、如果我们没有自己声明一个serialVersionUID变量,接口会默认生成一个serialVersionUID</p><p>2、建议用户自定义一个UID，默认的UID对class细节很敏感，反序列化时可能会导致InvalidClassException</p><p>3、序列化后的数据中UID与当前类中的UID一直才能被反序列化成功，否则可能是成员变量的数量或者类型发生了变化，反序列化时就会发生crash，可能就会发生异常</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Serializable" scheme="http://wysblogs.top/categories/Serializable/"/>
    
    
      <category term="Serializable" scheme="http://wysblogs.top/tags/Serializable/"/>
    
  </entry>
  
  <entry>
    <title>java基础面试知识</title>
    <link href="http://wysblogs.top/2020/05/11/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
    <id>http://wysblogs.top/2020/05/11/java基础面试知识/</id>
    <published>2020-05-11T02:36:58.000Z</published>
    <updated>2020-07-09T14:01:10.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java基础面试知识（持续更新）"><a href="#Java基础面试知识（持续更新）" class="headerlink" title="Java基础面试知识（持续更新）"></a>Java基础面试知识（持续更新）</h1><h2 id="HashMap，ConcurrentHashMap，Hashtable的数据结构"><a href="#HashMap，ConcurrentHashMap，Hashtable的数据结构" class="headerlink" title="HashMap，ConcurrentHashMap，Hashtable的数据结构"></a><strong>HashMap，ConcurrentHashMap，Hashtable的数据结构</strong></h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>介绍</strong></p><p>HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null　值，　因为key不允许重复，因此只能有一个键为null,另外HashMap不能保证放入元素的顺序，它是无序的，和放入的顺序并不能相同。HashMap是线程不安全的。</p><p>HashMap扩容特别耗时，如果能估算大小，最好给它一个默认的初始值，避免进行多次扩容，HashMap线程不安全，多线程状态下应使用ConcurrentHashMap。</p><p>如果在多线程状态下想要使用HashMap需要使用Conllections.synchronizedMap()方法获取一个线程安全的Map集合，就是在操作HashMap的时候会自动给方法添加synchronized 关键字来保证线程安全性。</p><p><strong>数据结构</strong></p><p>HashMap在1.8之前使用的是 <strong>数组+链表</strong>，1.8之后使用的是 <strong>数组+链表+红黑树</strong>，当链表长度超过<strong>阈值8</strong>的时候，将链表转换为红黑树，性能得到提升。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p><strong>介绍</strong></p><p>和HashMap基本一样。</p><p><strong>对比HashMap</strong></p><ul><li>Hashtable线程安全，HashMap线程不安全</li><li>Hashtable不能使用null作为key，HashMap可以用null作为key</li><li>HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。</li><li>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</li><li>HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1。</li><li>Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模</li><li>HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸。</li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h3><p><strong>介绍</strong></p><p>在1.8之前采用锁分段技术来保证性能，锁分段技术就是把存储空间分为许多段，然后给每个段都上锁，这样确保在访问某一段的代码时，不会阻塞其他段的访问，提高了性能。</p><p>1.8之后，抛弃了锁分段技术，采用了CAS + synchronized 来保证并发更新的安全性。</p><p>CAS：Compare and Swap，即比较再交换。</p><p>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p><p><strong>CAS的缺点：</strong><br>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p><p><strong>循环时间长开销很大。</strong><br>只能保证一个变量的原子操作。<br>ABA问题。</p><p><strong>循环时间长开销很大：</strong><br>CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。</p><p><strong>只能保证一个变量的原子操作：</strong><br>当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。</p><p><strong>什么是ABA问题？ABA问题怎么解决？</strong><br>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？</p><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><p><strong>总结</strong></p><p>Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。<br> ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。<br> 应该根据具体的应用场景选择合适的HashMap。</p><h2 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h2><ol><li><p>加法Hash</p></li><li><p>位运算Hash</p></li><li><p>乘法Hash</p></li><li><p>除法Hash</p></li><li><p>查表Hash</p></li><li><p>混合Hash</p></li><li><p>数组Hash</p></li></ol><h2 id="equals和hashcode"><a href="#equals和hashcode" class="headerlink" title="equals和hashcode"></a>equals和hashcode</h2><p>1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</p><p>2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p><p><strong>equals</strong></p><p>它的性质有：</p><ul><li><strong>自反性</strong>（reflexive）。对于任意不为<code>null</code>的引用值x，<code>x.equals(x)</code>一定是<code>true</code>。</li><li><strong>对称性</strong>（symmetric）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>是<code>true</code>时，<code>y.equals(x)</code>也是<code>true</code>。</li><li><strong>传递性</strong>（transitive）。对于任意不为<code>null</code>的引用值<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>是<code>true</code>，同时<code>y.equals(z)</code>是<code>true</code>，那么<code>x.equals(z)</code>一定是<code>true</code>。</li><li><strong>一致性</strong>（consistent）。对于任意不为<code>null</code>的引用值<code>x</code>和<code>y</code>，如果用于equals比较的对象信息没有被修改的话，多次调用时<code>x.equals(y)</code>要么一致地返回<code>true</code>要么一致地返回<code>false</code>。</li><li>对于任意不为<code>null</code>的引用值<code>x</code>，<code>x.equals(null)</code>返回<code>false</code>。</li></ul><p>对于<code>Object</code>类来说，<code>equals()</code>方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非<code>null</code>的引用值<code>x</code>和<code>y</code>，当且仅当<code>x</code>和<code>y</code>引用的是同一个对象，该方法才会返回<code>true</code>。</p><p><strong>需要注意的是当<code>equals()</code>方法被override时，<code>hashCode()</code>也要被override。按照一般<code>hashCode()</code>方法的实现来说，相等的对象，它们的hash code一定相等。</strong></p><p><strong>hashcode</strong></p><p>1.如果两个对象相同，那么它们的hashCode值一定要相同；<br>2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。  如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。<br>3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。　　反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。</p><h2 id="String为什么是final修饰"><a href="#String为什么是final修饰" class="headerlink" title="String为什么是final修饰"></a>String为什么是final修饰</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面试" scheme="http://wysblogs.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://wysblogs.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>redis面试知识</title>
    <link href="http://wysblogs.top/2020/05/11/redis%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
    <id>http://wysblogs.top/2020/05/11/redis面试知识/</id>
    <published>2020-05-11T02:36:49.000Z</published>
    <updated>2020-07-11T13:18:07.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis面试知识（持续更新）"><a href="#Redis面试知识（持续更新）" class="headerlink" title="Redis面试知识（持续更新）"></a>Redis面试知识（持续更新）</h1><blockquote><p>参考如下：</p><p><a href="https://blog.csdn.net/chenyao1994/article/details/79491337" target="_blank" rel="noopener">https://blog.csdn.net/chenyao1994/article/details/79491337</a></p><p><a href="https://blog.csdn.net/u012240455/article/details/81843714" target="_blank" rel="noopener">https://blog.csdn.net/u012240455/article/details/81843714</a></p><p><a href="https://www.jianshu.com/p/3677afe376ee" target="_blank" rel="noopener">https://www.jianshu.com/p/3677afe376ee</a></p></blockquote><h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>Redis 是一个c语言编写，开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p><h2 id="redis为什么那么快"><a href="#redis为什么那么快" class="headerlink" title="redis为什么那么快"></a>redis为什么那么快</h2><ul><li><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速，数据存在内存中，类似于HashMap，查找和操作时间复杂度都是O(1)</p></li><li><p>数据结构简单，对数据操作也比较简单</p></li><li><p>采用单线程，避免了上下文切换和竞争条件，不存在多线程切换导致消耗cpu，不用去考虑各种锁的问题，避免了因锁产生的性能消耗</p></li><li><p>使用多路I/O复用模型，非阻塞IO</p></li><li><p>使用底层模型不同，它们之间底层实现方式以及客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用函数的话，会浪费一定的时间去移动和请求</p><ul><li>多路I/O复用模型</li></ul><p>多路I/O复用模型是利用select，poll，epoll可以同时监察多个流的I/O事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p></li></ul><h2 id="redis为什么是单线程"><a href="#redis为什么是单线程" class="headerlink" title="redis为什么是单线程"></a>redis为什么是单线程</h2><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了</p><h2 id="redis哨兵机制"><a href="#redis哨兵机制" class="headerlink" title="redis哨兵机制"></a>redis哨兵机制</h2><h3 id="什么是哨兵机制"><a href="#什么是哨兵机制" class="headerlink" title="什么是哨兵机制"></a>什么是哨兵机制</h3><p>redis哨兵机制(sentinel)系统用于管理多个redis服务器，主要执行三个任务：</p><p><strong>监控(Monitoring)：</strong>哨兵会不断的检查你的Master和Slave是否运作正常</p><p><strong>提醒(Notification)：</strong>当被监控的某个redis出现问题，哨兵可以通过api向管理员或者其他应用程序发送通知</p><p><strong>自动故障迁移(Automatic failover)：</strong>当一个Master不能正常工作时，哨兵会开始一次自动故障迁移操作，他会将失效Master的其中一个Slave升级成为新的Master，并让失效的Master的其他Slave改为复制新的Master，当客户端试图连接失效的Master时，集群也会向客户端返回新的Master的地址，使得集群可以使用Master代替失效的Master。</p><p><strong>哨兵是一个分布式系统，你可以在一个架构中运行多个哨兵进程</strong>，这些进程使用流言协议(gossipprotocols)来接收关于Master是否下线的信息,并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。</p><p>每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave<strong>定时</strong>发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).<br>若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master”彻底死亡”(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。<br>      虽然哨兵(sentinel) 释出为一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动哨兵(sentinel)。<br>      哨兵(sentinel) 的一些设计思路和zookeeper非常类似</p><p><img src="/upload/redis/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>哨兵是redis集群架构中非常重要的一个组件，作用如下：</strong></p><ul><li><strong>集群监控：</strong>负责监控redis master和slave进程是否正常工作</li><li><strong>消息通知：</strong>如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li><strong>故障转移：</strong>如果master node，会自动转移到slave node上</li><li><strong>配置中心：</strong>如果故障转移发生了，通知client客户端新的master地址</li></ul><p><strong>哨兵本身也是分布式的，作为一个哨兵集群去运行的，相互协同工作</strong></p><p>(1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。<br>(2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。</p><h2 id="redis内存淘汰机制"><a href="#redis内存淘汰机制" class="headerlink" title="redis内存淘汰机制"></a>redis内存淘汰机制</h2><h3 id="volatile-lru"><a href="#volatile-lru" class="headerlink" title="volatile-lru"></a>volatile-lru</h3><p>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。redis并不是保证取得所有数据集中最近最少使用的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。</p><h3 id="volatile-ttl"><a href="#volatile-ttl" class="headerlink" title="volatile-ttl"></a>volatile-ttl</h3><p>从已设置过期时间的数据集中挑选将要过期的数据淘汰。redis 并不是保证取得所有数据集中最近将要过期的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。</p><h3 id="volatile-random"><a href="#volatile-random" class="headerlink" title="volatile-random"></a>volatile-random</h3><p>从已设置过期时间的数据集中任意选择数据淘汰。当内存达到限制的时候无法写入非过期时间的数据集。</p><h3 id="allkeys-lru"><a href="#allkeys-lru" class="headerlink" title="allkeys-lru"></a>allkeys-lru</h3><p>从数据集中挑选最近最少使用的数据淘汰。当内存达到限制的时候，对所有数据集挑选最近最少使用的数据淘汰，可写入新的数据集。</p><h3 id="allkeys-random"><a href="#allkeys-random" class="headerlink" title="allkeys-random"></a>allkeys-random</h3><p>从数据集中任意选择数据淘汰，当内存达到限制的时候，对所有数据集挑选随机淘汰，可写入新的数据集。</p><h3 id="no-enviction"><a href="#no-enviction" class="headerlink" title="no-enviction"></a>no-enviction</h3><p>当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错。</p><h2 id="redis集群的CAP"><a href="#redis集群的CAP" class="headerlink" title="redis集群的CAP"></a>redis集群的CAP</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><ul><li>C:consistency(一致性)</li><li>A:avalibility(可用性)</li><li>P:Partition(分区)-tolerence to partition(分区容忍度)</li></ul><p><strong>CAP理论的核心是</strong>：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，<br>最多只能同时较好的满足两个。<br>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：<br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。<br>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。<br>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p><h2 id="redis发布订阅"><a href="#redis发布订阅" class="headerlink" title="redis发布订阅"></a>redis发布订阅</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>PUBLISH channel message</td><td>将信息发送到指定的频道。</td></tr><tr><td>SUBSCRIBE channel [channel …]</td><td>订阅给定的一个或多个频道的信息</td></tr><tr><td>PSUBSCRIBE pattern [pattern …]</td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td>UNSUBSCRIBE [channel [channel …]]</td><td>指退订给定的频道。</td></tr><tr><td>PUNSUBSCRIBE [pattern [pattern …]]</td><td>退订所有给定模式的频道。</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、构建实时消息系统，比如普通的即时聊天，群聊等功能。</p><p>2、微信的公共号订阅消息推送等</p><h2 id="redis和Mysql同步"><a href="#redis和Mysql同步" class="headerlink" title="redis和Mysql同步"></a>redis和Mysql同步</h2><p>一、对强一致要求比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存的设置过期(建议不要去更新缓存内容，直接设置缓存过期)。</p><p>二、对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。</p><p>三、使用阿里的同步工具canal，canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。</p><p>四、采用UDF自定义函数的方式，面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++语言实现，学习成本高。</p><h2 id="redis分布式session"><a href="#redis分布式session" class="headerlink" title="redis分布式session"></a>redis分布式session</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/upload/redis/%E5%88%86%E5%B8%83%E5%BC%8Fsession.png" alt="分布式session"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由于Http连接是无状态的，所以使用Tomcat做服务器的时候Tomcat内部会维护一个Session用来保存客户端的状态，一般情况下每个客户端都有一个cookie里面保存着叫jsessionid的cookie，每次访问tomcat的时候都会携带上，Tomcat可以根据这个jsessionid找到对应的session。</p><p>使用Redis作为session存储容器，登录时将session信息存储至cookie客户端，同时服务端将session信息存至redis缓存，双重保障，接下来的接口调用直接可以获取到cookie中的token信息作为参数传递进来即可，如果发现token为空，则再从redis中获取，如果两者都为空，则说明session已过期。</p><h2 id="redis集群如何部署"><a href="#redis集群如何部署" class="headerlink" title="redis集群如何部署"></a>redis集群如何部署</h2><p><img src="/upload/redis/redis%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2.png" alt="redis集群部署"></p><h2 id="gossip协议"><a href="#gossip协议" class="headerlink" title="gossip协议"></a>gossip协议</h2><p>Gossip是一种去中心化、容错并保证最终一致性的协议。</p><p>redis集群使用的服务</p><p>Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播</p><p><strong>引用</strong></p><blockquote><p><a href="https://blog.csdn.net/renooon/article/details/73834598" target="_blank" rel="noopener">https://blog.csdn.net/renooon/article/details/73834598</a></p></blockquote><h2 id="redis和memcache的区别"><a href="#redis和memcache的区别" class="headerlink" title="redis和memcache的区别"></a>redis和memcache的区别</h2><p><strong>1、数据操作不同</strong></p><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能。Redis支持服务器端的数据操作相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，支持list、set、sorted set、hash等众多数据结构，还同时提供了持久化和复制等功能。</p><p>而通常在Memcached里，使用者需要将数据拿到客户端来进行类似的修改再set回去，这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作， Redis会是更好的选择。</p><p><strong>2、内存管理机制不同</strong></p><p>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。</p><p>而Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。</p><p>从内存利用率来讲，使用简单的key-value存储的话，Memcached的内存利用率更高。而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。</p><p><strong>3、性能不同</strong></p><p>由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。</p><p><strong>4、集群管理不同</strong></p><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。</p><blockquote><p><a href="https://www.php.cn/redis/423024.html" target="_blank" rel="noopener">https://www.php.cn/redis/423024.html</a></p></blockquote><h2 id="Redis持久化操作"><a href="#Redis持久化操作" class="headerlink" title="Redis持久化操作"></a>Redis持久化操作</h2><p>redis是基于内存的数据库，提供了两种形式进行持久化</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB是redis默认的持久化形式，本质就是把redis的数据以快照的形式保存到磁盘中。</p><p>RDB持久化是指在指定的时间间隔内，将内存中的数据快照写入磁盘，本质是将内存中的数据写入到二进制文件中，默认的文件名是dump.rdb</p><h4 id="RDB机制的三种触发方式"><a href="#RDB机制的三种触发方式" class="headerlink" title="RDB机制的三种触发方式"></a>RDB机制的三种触发方式</h4><h5 id="1、save触发方式"><a href="#1、save触发方式" class="headerlink" title="1、save触发方式"></a>1、save触发方式</h5><p>该命令会阻塞当前的redis服务器，执行save命令期间，redis不能处理其他命令，知道rdb过程完成之后，执行过程中，如果遇到老的rdb文件，就用新的替代掉旧的，但是这种方法一般不可取。</p><h5 id="2、bgsave触发方式"><a href="#2、bgsave触发方式" class="headerlink" title="2、bgsave触发方式"></a>2、bgsave触发方式</h5><p>执行该命令后，redis会在后台异步进行快照操作，进行快照操作的同时还能响应客户端请求</p><p>具体操作就是redis进行fork时候创建一个子进程，rdb持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一半时间很短，redis大多数采用的都是这样的触发方式。</p><h5 id="3、自动触发"><a href="#3、自动触发" class="headerlink" title="3、自动触发"></a>3、自动触发</h5><p>一般在配置文件中配置，主要还是使用上面两种触发方式</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h5 id="1、持久化原理"><a href="#1、持久化原理" class="headerlink" title="1、持久化原理"></a>1、持久化原理</h5><p>由于全量备份总是特别耗时，这时候就需要用到AOF了，AOF工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中，通俗来说就是日志记录。</p><h5 id="2、文件重写原理"><a href="#2、文件重写原理" class="headerlink" title="2、文件重写原理"></a>2、文件重写原理</h5><p>redis提供了bgrewriteof命令，将内存中的数据以命令的形式保存到临时文件中，同时fork出一条新的子线程来将文件重写。</p><p>而且，重写操作没有读取旧的aof文件，而是重写了一个新的aof文件</p><h5 id="3、三种触发方式"><a href="#3、三种触发方式" class="headerlink" title="3、三种触发方式"></a>3、三种触发方式</h5><ul><li>每次修改都同步写入(always)，同步持久化，性能差，数据完整性好。</li><li>每秒同步(everysec)，异步操作，每秒记录，如果发生宕机，会丢失数据。</li><li>不同步(no)，从不同步。</li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><p><img src="/upload/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%AF%B9%E6%AF%94.jpg" alt="img"></p><p>一般来说，通常都是两者一起使用会比较好</p><p>根据需求来判断是最合适的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面试" scheme="http://wysblogs.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://wysblogs.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试知识</title>
    <link href="http://wysblogs.top/2020/05/08/Spring%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
    <id>http://wysblogs.top/2020/05/08/Spring面试知识/</id>
    <published>2020-05-08T00:57:50.000Z</published>
    <updated>2020-05-17T12:20:46.615Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring面试知识（持续更新）"><a href="#Spring面试知识（持续更新）" class="headerlink" title="Spring面试知识（持续更新）"></a>Spring面试知识（持续更新）</h1><h2 id="1、Spring是什么"><a href="#1、Spring是什么" class="headerlink" title="1、Spring是什么"></a>1、Spring是什么</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面试" scheme="http://wysblogs.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://wysblogs.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Netty面试知识</title>
    <link href="http://wysblogs.top/2020/05/05/Netty%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
    <id>http://wysblogs.top/2020/05/05/Netty面试知识/</id>
    <published>2020-05-05T05:03:30.000Z</published>
    <updated>2020-05-05T15:24:00.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Netty面试知识"><a href="#Netty面试知识" class="headerlink" title="Netty面试知识"></a>Netty面试知识</h1><h2 id="Netty是什么"><a href="#Netty是什么" class="headerlink" title="Netty是什么"></a>Netty是什么</h2><p>Netty是一个基于NIO的网络通信框架</p><p>NIO是从java1.4版本开始引入的一个新的IO API</p><h2 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h2><p>SelectableChannel 是 jdk1.4引入的nio包中一个有用的抽象类，SelectableChannel可以让程序员避免编写大量阻塞式的代码，特别是在高并发的交互式网络编程中，作用尤其明显。</p><h2 id="BIO、NIO、AIO的区别？"><a href="#BIO、NIO、AIO的区别？" class="headerlink" title="BIO、NIO、AIO的区别？"></a>BIO、NIO、AIO的区别？</h2><ul><li><p><strong>BIO</strong>：一个连接一个线程，客户端有连接请求时服务器就需要启动一个线程，线程开销大。</p></li><li><p><strong>NIO</strong>：一个请求一个线程，但客户端发送的连接请求都会注册到<strong>多路复用器上</strong>，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><ul><li><p><strong>通道（Channel）</strong>：负责传输Buffer</p></li><li><p><strong>缓冲区（Buffer）</strong>：负责数据的存取</p><p><strong>多路复用器（selector）</strong>：</p><p>多路复用器，用于监控SelectableChannel的IO状况</p><p>与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel类和ServerSocketChannel两种不同的套接字实现，都支持阻塞和非阻塞模式，阻塞模式简单，但是性能和可靠性不行，非阻塞模式与此相反，一般低负载，低并发使用同步阻塞IO降低复杂度，对于高负载，高并发还是要用NIO的非阻塞模式。</p><p>简单来说，Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生了读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取到就绪Channel的集合，进行后续操作；</p><p><strong>SocketChannel</strong>是一个连接到TCP网络套接字的通道</p><p><strong>ServerSocketChannel</strong>是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。</p><p><strong>DatagramChannel</strong>主要针对UDP</p></li><li><p><strong>管道（Pipe）</strong>：</p><p>JAVA NIO 管道是两个线程之间的单向数据连接</p><p>Pipe有一个<strong>source</strong>通道和一个<strong>sink</strong>通道，数据会被写到sink通道，从source通道读取。</p></li><li><p><strong>NIO编程的优点</strong>:</p><p>1、<strong>客户端发起的连接操作是异步的</strong>，可以通过在多路复用器注册OP_CONNECTION等待后续结果，不需要像之前的客户端那样被同步阻塞。</p><p>2、<strong>SocketChannel的读写操作都是异步的</strong>，如果没有可读写的数据它不会同步等待，直接返回，这样IO通信线程就可以处理其他的链路，不需要同步等待这个链路可用了。</p><p>3、<strong>线程模型的优化</strong>，由于JDK的Selector在Linux等主流操作系统上通过<strong>epoll</strong>实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者对单个进程的句柄限制），意味着Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降，因此，它非常适合做高性能，高负载的网络服务器。</p></li><li><p><strong>epoll</strong>：</p><p>epoll是为处理大批量句柄而作了改进的poll，是性能最好的多路I/O就绪通知方法</p><p><strong>只有三个系统调用：</strong></p><p>1、<strong>epoll_create</strong>：创建一个poll实例，文件描述符</p><p>2、<strong>epoll_ctl</strong>：将监听的文件描述符添加到epoll实例中，实例代码为将标准输入文件描述符添加到epoll中</p><p>3、<strong>epoll_wait</strong>：等待epoll事件从epoll实例中发生，并返回事件以及对应文件描述符</p><p><strong>两种事件模型：</strong></p><p><strong>1、水平触发：</strong></p><ul><li>socket接受缓冲区不为空，有数据可读，读事件一直触发</li><li>socket发送缓冲区不满，可以继续写入数据，写事件一直触发</li></ul><p><strong>2、边沿触发</strong></p><ul><li>socket的接受缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发事件</li><li>socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出时间时触发读事件</li></ul><p>边沿触发仅触发一次，水平触发会一直触发</p><p><strong>高效原理：</strong></p><p>当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以epoll_wait非常高效</p><p><strong>高效本质：</strong></p><ul><li>减少了用户态和内核态的文件句柄拷贝</li><li>减少了可读可写文件句柄的遍历</li><li>mmap加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝</li><li>I/O性能不会随着监听的文件描述的数量增长而下降</li><li>使用红黑树存储<strong>fd</strong>，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多空间。</li></ul></li></ul></li></ul><ul><li><p><strong>AIO</strong>：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p>JDK1.7升级了NIO类库，升级后的NIO类库被称为NIO2.0，这个版本中Java正式提供了异步文件IO操作，同时提供了与UNIX网络编程事件驱动IO对应的AIO；</p></li><li><p><strong>BIO和NIO区别</strong></p><p>1、BIO是面向流的，NIO是面向缓冲区的</p><p>2、BIO的各种流是阻塞的，而NIO是非阻塞的；</p><p>3、BIO的Stream是单向的，而NIO的Channel是双向的</p></li><li><p><strong>NIO的特点：</strong></p><p>1、事件驱动模型</p><p>2、单线程处理多任务</p><p>3、非阻塞I/O，I/O读写不在阻塞，而是返回0</p><p>4、基于block的传输比基于流的传输更高效</p><p>5、更高级的IO函数zero_copy</p><p>6、IO多路复用大大提高了java网络应用的可伸缩性和实用性</p><p>7、基于Reactor线程模型</p></li><li><p><strong>Reactor模式</strong></p><p><strong>1、Reactor模式是什么？</strong></p><p>Reactor模式也叫反应器模式，是一种典型的事件驱动的编程模型</p><p>Reactor模式逆置了程序处理流程</p><p><strong>Reactor组件：</strong></p><p>负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包括连接建立就绪，都就绪，写就绪</p><p><strong>Handler组件</strong></p><p>将自身与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel</p><p><strong>2、Reactor事件处理机制：</strong></p><p>1、主程序将事件以及对应事件处理的方法在Reactor上进行注册，如果相应的事件发生，Reactor将会主动调用事件注册的接口，即回调函数</p><p>2、Redis中基于I/O多路复用开发Reactor事件处理机制，读事件绑定读操作和具体执行命令的操作函数，写事件绑定命令自动回复的操作函数</p><p><strong>3、Reactor编程优点</strong></p><p>1、响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</p><p>2、编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</p><p>3、可扩展性，可以方便的通过增加Reactor实例个数来充分利用cpu资源</p><p>4、可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性</p><p><strong>4、Reactor编程缺点</strong></p><p>1、相比传统的简单模型，Reactor增加了一定的复杂性，因而具有一定门槛，并且不易于调试</p><p>2、Reactor模式需要底层的多路复用支持，比如java中的selector，操作系统的select系统调用支持</p><p>3、Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，共享Reactor的Channel如果有一个出现长时间的数据读写，还会影响其这个Reactor中其他的Channel，这时候就需要使用改进版的Reactor模式，<strong>Proactor模式</strong>。</p><p><strong>5、Reactor三种角色</strong></p><ul><li><strong>Reactor</strong>，将I/O事件分派给对应的Handler</li><li><strong>Acceptor</strong>，处理客户端新连接，并分派请求到处理链中</li><li><strong>Handlers</strong>，执行非阻塞 读/写 任务</li></ul></li></ul><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><ul><li><p>传统IO流都是阻塞的</p><p>当一个线程调用read()或者write()时，该线程被阻塞，直到一些数据被读取，或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO操作时，由于线程会被阻塞，所以服务器端必须为每个客户端提供一个独立的线程进行处理，当服务端要处理大量客户端时，性能就会下降的严重。</p></li><li><p>NIO 是非阻塞模式的</p><p>当线程从某通道进行读写数据时，若没有数据可用时，该线程可以处理其他事，线程通常将非阻塞IO的空闲时间用于其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道，因此NIO可以使用一个或几个线程来同时处理连接到服务器端的所有客户端</p></li></ul><h2 id="NIO的组成"><a href="#NIO的组成" class="headerlink" title="NIO的组成"></a>NIO的组成</h2><ul><li>Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的<ul><li>flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式</li><li>clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。</li><li>rewind方法 ： 重绕此缓冲区，将position置为0</li></ul></li><li>DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。</li><li>Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！</li><li>Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。</li><li>Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。</li><li>fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。</li><li>Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取</li><li>NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件</li></ul><h2 id="Netty的特点"><a href="#Netty的特点" class="headerlink" title="Netty的特点"></a>Netty的特点</h2><ul><li>一个高性能，异步事件驱动的NIO框架，它提供了对TCP，UDP和文件传输的支持</li><li>使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式</li><li>采用多种decoder/encoder支持，对TCP粘包/分包进行了自动化处理</li><li>可使用接受/处理线程池，提高连接效率，对重连，心跳检测的简单支持</li><li>可配置IO线程数，TCP参数，TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuff</li><li>通过引用计数器及时申请释放不在引用的对象，降低了GC频率</li><li>使用单线程串行化的方式，搞笑的Reactor线程模型</li><li>大量使用了volitale、使用了CAS和源自类、线程安全类的使用、读写锁的使用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Netty" scheme="http://wysblogs.top/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://wysblogs.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>常用算法模板</title>
    <link href="http://wysblogs.top/2020/05/02/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <id>http://wysblogs.top/2020/05/02/常用算法模板/</id>
    <published>2020-05-02T08:02:12.000Z</published>
    <updated>2020-05-02T08:03:50.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用算法模板整理"><a href="#常用算法模板整理" class="headerlink" title="常用算法模板整理"></a>常用算法模板整理</h1><h2 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h2><p><img src="/upload/%E7%AE%97%E6%B3%95/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="img"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">将大数交换到右边 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">bubble_sort(arr,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果左边大于右边说明已经找不到可以互换的了，排序结束 </span></span><br><span class="line"><span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基准 </span></span><br><span class="line"><span class="keyword">int</span> temp = arr[left];</span><br><span class="line"><span class="comment">//i,j分别等于边界值，t用来交换值 </span></span><br><span class="line"><span class="keyword">int</span> i=left,j=right,t;</span><br><span class="line"><span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line"><span class="comment">//判断左右是否大于或者小于基准 </span></span><br><span class="line"><span class="keyword">while</span>(arr[j]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(arr[i]&lt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">t = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序结束进行基准归位</span></span><br><span class="line"><span class="comment">//基准和最左边的数交换位置 </span></span><br><span class="line">arr[left] = arr[i]; </span><br><span class="line">arr[i] = temp;</span><br><span class="line"><span class="comment">//归位后进行排除头和尾进行下次交换</span></span><br><span class="line">quick_sort(arr,left,j<span class="number">-1</span>);</span><br><span class="line">quick_sort(arr,i+<span class="number">1</span>,right); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">quick_sort(arr,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：在第i个元素开始向右查找，遇到左边大于右边的就交换位置</span></span><br><span class="line"><span class="comment">每次循环都需要把一个最小元素移动到数组左边 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>&amp;&amp;arr[j<span class="number">-1</span>]&gt;arr[j];j--)&#123;</span><br><span class="line">swap(arr[j<span class="number">-1</span>],arr[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">insert_sort(arr,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">希尔排序思路：</span></span><br><span class="line"><span class="comment"> 根据增量把数组分成几个小数组</span></span><br><span class="line"><span class="comment"> 插入排序完成后慢慢减小增量</span></span><br><span class="line"><span class="comment"> 使得数组在有一定顺序的基础上继续排序</span></span><br><span class="line"><span class="comment"> 提高排序效率 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> N = length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最外层的控制增量 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> gap=N/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个组进行插入排序 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;N;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将arr[i]插入到正确的位置 </span></span><br><span class="line"><span class="keyword">int</span> v = arr[i];</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">//插入的时候按组进行插入（组内元素两两相隔gap） </span></span><br><span class="line"><span class="keyword">for</span>(j=i-gap;j&gt;=<span class="number">0</span>&amp;&amp;v&lt;arr[j];j-=gap)&#123;</span><br><span class="line">arr[j+gap] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+gap] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">8</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">8</span>;</span><br><span class="line">shell_sort(arr,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">选择排序思路：</span></span><br><span class="line"><span class="comment">每次把最小的选出来放到前边 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> minn = i; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[minn])&#123;</span><br><span class="line">minn = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr[minn],arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">select_sort(arr,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立父节点和子节点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父节点指标和子节点指标 </span></span><br><span class="line"><span class="keyword">int</span> f = start;</span><br><span class="line"><span class="keyword">int</span> s = f*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//若子节点指标在范围内才做比较 </span></span><br><span class="line"><span class="keyword">while</span>(s&lt;=end)&#123;</span><br><span class="line"><span class="comment">//先比较两个子节点大小，选择最大的 </span></span><br><span class="line"><span class="keyword">if</span>(s+<span class="number">1</span>&lt;=end&amp;&amp;arr[s]&lt;arr[s+<span class="number">1</span>])&#123; </span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果父节点大于子节点则表示调整完毕，直接跳出循环 </span></span><br><span class="line"><span class="keyword">if</span>(arr[f]&gt;arr[s])&#123;  </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//佛瑞泽交换父子内容再继续子节点和孙节点比较 </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">swap(arr[f],arr[s]);</span><br><span class="line">f = s;</span><br><span class="line">s = f*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//堆排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">max_heapify(arr,i,len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再重新调整，直到排序完成 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">swap(arr[<span class="number">0</span>],arr[i]);</span><br><span class="line">max_heapify(arr,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">heap_sort(arr,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">归并排序思路：</span></span><br><span class="line"><span class="comment">一直分隔，直到剩最后一个然后归并进行排序 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aux[r-l+<span class="number">1</span>],i,j,k;</span><br><span class="line"><span class="keyword">for</span>(k=l;k&lt;=r;k++) &#123;</span><br><span class="line">aux[k-l] = arr[k];</span><br><span class="line">&#125;</span><br><span class="line">i = l;</span><br><span class="line">j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(k=l;k&lt;=r;k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">arr[k] = aux[j-l];</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;r) &#123;</span><br><span class="line">arr[k] = aux[i-l];</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i-l]&gt;aux[j-l])&#123;</span><br><span class="line">arr[k] = aux[j-l];</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr[k] = aux[i-l];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">merge_sort(arr,l,mid);</span><br><span class="line">merge_sort(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">merge(arr,l,r,mid);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">merge_sort(arr,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//迭代运算，把值转化成二进制进行迭代 </span></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求(a^b)%mod次方 </span></span><br><span class="line">ll ans = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//如果b为奇数 </span></span><br><span class="line"><span class="comment">//类似于 b % 2 == 1 </span></span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">ans = ans * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a的平方 </span></span><br><span class="line">a = a * a % mod;</span><br><span class="line"><span class="comment">//b右移相当于b/2 </span></span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,pow_mod(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1000</span>)); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长递增子序列和"><a href="#最长递增子序列和" class="headerlink" title="最长递增子序列和"></a>最长递增子序列和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">&#125; </span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]&gt;num[j]) &#123;</span><br><span class="line">ans = max(dp[j],ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = ans + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[i]&gt;x) x = dp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> x[<span class="number">1005</span>],y[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line">x[<span class="number">0</span>] = y[<span class="number">0</span>] = <span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(x)&gt;<span class="built_in">strlen</span>(y)?<span class="built_in">strlen</span>(x):<span class="built_in">strlen</span>(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j,i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(x);i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="built_in">strlen</span>(y);j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(x[i] == y[j]) &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]&gt;dp[i][j<span class="number">-1</span>]?dp[i<span class="number">-1</span>][j]:dp[i][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="built_in">strlen</span>(x)<span class="number">-1</span>][<span class="built_in">strlen</span>(y)<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll p[<span class="number">1005</span>],q[<span class="number">1005</span>],ans,dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;q[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">ll cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;q[j]&amp;&amp;dp[i<span class="number">-1</span>][j]&gt;cur) cur = dp[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span>(p[i]==q[j]) dp[i][j] = cur+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans=max(ans,dp[n][i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x]!=x)&#123;</span><br><span class="line">        pre[x] = find(pre[x]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> pre[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS遍历图"><a href="#DFS遍历图" class="headerlink" title="DFS遍历图"></a>DFS遍历图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> Ne,Nv;</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">visited[n] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Nv;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>((visited[i]!=<span class="number">1</span>&amp;&amp;<span class="built_in">map</span>[n][i]!=INF))&#123;</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="comment">//先输入点，在输入边 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Nv,&amp;Ne);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Nv;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line"><span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Nv;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试数据</span></span><br><span class="line"><span class="comment">8 6</span></span><br><span class="line"><span class="comment">0 7</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">0 1 4 2 7 3 5 6 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="DFS全排列"><a href="#DFS全排列" class="headerlink" title="DFS全排列"></a>DFS全排列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">11</span>],num[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth&gt;n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num[j]&lt;&lt;<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[i])&#123;</span><br><span class="line">visit[i] = <span class="number">1</span>;</span><br><span class="line">num[depth] = i;</span><br><span class="line">dfs(depth+<span class="number">1</span>);</span><br><span class="line">visit[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">visit[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS遍历图"><a href="#BFS遍历图" class="headerlink" title="BFS遍历图"></a>BFS遍历图</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 65535</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> Nv,Ne;</span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> que[Nv];</span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">que[tail++] = n;</span><br><span class="line">visited[n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(head!=tail) &#123;</span><br><span class="line"><span class="keyword">int</span> m = que[head++];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[i]!=<span class="number">1</span>&amp;&amp;<span class="built_in">map</span>[m][i]!=INF)&#123;</span><br><span class="line">que[tail++] = i;</span><br><span class="line">visited[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;Nv&gt;&gt;Ne;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">visited[i] = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">map</span>[a][b] = <span class="built_in">map</span>[b][a] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">BFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试用例</span></span><br><span class="line"><span class="comment">8 6</span></span><br><span class="line"><span class="comment">0 7</span></span><br><span class="line"><span class="comment">0 1</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">结果</span></span><br><span class="line"><span class="comment">0 1 2 7 4 3 5 6 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="BFS最短迷宫路径"><a href="#BFS最短迷宫路径" class="headerlink" title="BFS最短迷宫路径"></a>BFS最短迷宫路径</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 65535</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//路径长度 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>];<span class="comment">//迷宫地图 </span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P; <span class="comment">//节点坐标 </span></span><br><span class="line">P p; </span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sx = <span class="number">0</span>,sy = <span class="number">0</span>; <span class="comment">//起始坐标 </span></span><br><span class="line"><span class="keyword">int</span> ex = <span class="number">4</span>,ey = <span class="number">4</span>; <span class="comment">//出口坐标</span></span><br><span class="line"><span class="keyword">int</span> N,M; <span class="comment">//迷宫大小</span></span><br><span class="line"><span class="built_in">queue</span>&lt;P&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++) &#123;</span><br><span class="line">vis[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[sx][sy] = <span class="number">1</span>;<span class="comment">//表示起始路径长度</span></span><br><span class="line">que.push(P(sx,sy));</span><br><span class="line"><span class="keyword">while</span>(que.size())&#123;</span><br><span class="line">p = que.front();</span><br><span class="line">que.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = p.first + dx[i];</span><br><span class="line"><span class="keyword">int</span> y = p.second + dy[i];</span><br><span class="line"><span class="comment">//在范围内，并且没有被访问过，而且是通路 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;N&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;M&amp;&amp;<span class="built_in">map</span>[x][y]!=<span class="number">1</span>&amp;&amp;vis[x][y]==INF)&#123;</span><br><span class="line">que.push(P(x,y));</span><br><span class="line">vis[x][y] = vis[p.first][p.second] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(p.first==ex&amp;&amp;p.second==ey)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">N = <span class="number">5</span>; M = <span class="number">5</span>;<span class="comment">//初始化迷宫大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,vis[N<span class="number">-1</span>][M<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">/*printf("%d",vis[N-1][M-1]);</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;5;i++) &#123;</span></span><br><span class="line"><span class="comment">for(int j=0;j&lt;5;j++)&#123;</span></span><br><span class="line"><span class="comment">printf("%d ",vis[i][j]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("\n");</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*测试用例</span></span><br><span class="line"><span class="comment">0 1 0 0 0</span></span><br><span class="line"><span class="comment">0 1 0 1 0</span></span><br><span class="line"><span class="comment">0 0 0 0 0</span></span><br><span class="line"><span class="comment">0 1 1 1 0</span></span><br><span class="line"><span class="comment">0 0 0 1 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="最小生成树（克鲁斯卡尔算法）"><a href="#最小生成树（克鲁斯卡尔算法）" class="headerlink" title="最小生成树（克鲁斯卡尔算法）"></a>最小生成树（克鲁斯卡尔算法）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Kruskal算法|</span></span><br><span class="line"><span class="comment">    |适用于 稀疏图 求最小生成树|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx thanks to wangqiqi|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一步：点、边、加入vector，把所有边按从小到大排序</span></span><br><span class="line"><span class="comment">    第二步：并查集部分 + 下面的code</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    ans = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (Find(edge[i].a) != Find(edge[i].b)) &#123;    </span><br><span class="line">            Union(edge[i].a, edge[i].b);    </span><br><span class="line">            ans += edge[i].len;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪杰斯特拉算法（单源最短路径）"><a href="#迪杰斯特拉算法（单源最短路径）" class="headerlink" title="迪杰斯特拉算法（单源最短路径）"></a>迪杰斯特拉算法（单源最短路径）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 65535</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,min;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dist[i] = <span class="built_in">map</span>[<span class="number">1</span>][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">min = INF;</span><br><span class="line"><span class="comment">//先找最短的路，要求该点没有被访问过，而且是距离的最小值 </span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j]==<span class="number">0</span>&amp;&amp;dist[j]&lt;min)&#123;</span><br><span class="line">min = dist[j];</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[k] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[j] == <span class="number">0</span>&amp;&amp;dist[j]&gt;dist[k]+<span class="built_in">map</span>[k][j])&#123;</span><br><span class="line">dist[j] = dist[k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,a,b,c;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t&gt;&gt;n) &#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)<span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">map</span>[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(c&lt;<span class="built_in">map</span>[a][b])&#123;</span><br><span class="line"><span class="built_in">map</span>[b][a] = <span class="built_in">map</span>[a][b] = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">poj 2387</span></span><br><span class="line"><span class="comment">样例： </span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">1 2 20</span></span><br><span class="line"><span class="comment">2 3 30</span></span><br><span class="line"><span class="comment">3 4 20</span></span><br><span class="line"><span class="comment">4 5 20</span></span><br><span class="line"><span class="comment">1 5 100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结果 </span></span><br><span class="line"><span class="comment">90</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">dis[i][j] = min(dis[i][j],dis[i][k)+dis[k][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传递闭包 判断两点是否联通 </span></span><br><span class="line"><span class="keyword">void</span> Floyd() &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">dis[i][j] |= dis[i][k] &amp; dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解将哪些物品装入背包可使价值总和最大 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nmax=<span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> v[nmax];<span class="comment">//v[i]表示第i个物品的价值value </span></span><br><span class="line"><span class="keyword">int</span> w[nmax];<span class="comment">//w[i]表示第i个物品的重量weight </span></span><br><span class="line"><span class="keyword">int</span> dp[nmax];<span class="comment">//总价值 </span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示物品数量，m表示背包容量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">//一维数组实现的01背包模板 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//遍历n个物品 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//01背包容量 逆序遍历</span></span><br><span class="line">  <span class="keyword">if</span>(j&gt;=w[i])&#123;</span><br><span class="line">  dp[j]=max(dp[j],(dp[j-w[i]]+v[i]));</span><br><span class="line">  &#125;<span class="comment">//第i个物体不选，dp[j]=dp[j];</span></span><br><span class="line">   <span class="comment">//第i个物体若选dp[j]=dp[j-w[i]]+v[i]</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nmax=<span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> v[nmax];<span class="comment">//v[i]表示第i个物品的价值value </span></span><br><span class="line"><span class="keyword">int</span> w[nmax];<span class="comment">//w[i]表示第i个物品的重量weight </span></span><br><span class="line"><span class="keyword">int</span> dp[nmax];<span class="comment">//总价值 </span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">//n表示物品数量，m表示背包容量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">//一维数组实现的完全背包模板 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//遍历n个物品 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;<span class="comment">//完全背包容量 顺序遍历</span></span><br><span class="line">  <span class="keyword">if</span>(j&gt;=w[i])&#123;</span><br><span class="line">  dp[j]=max(dp[j],(dp[j-w[i]]+v[i]));</span><br><span class="line">  &#125;<span class="comment">//第i个物体不选，dp[j]=dp[j];</span></span><br><span class="line">   <span class="comment">//第i个物体若选dp[j]=dp[j-w[i]]+v[i]</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="算法" scheme="http://wysblogs.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://wysblogs.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>阿里Redis规范</title>
    <link href="http://wysblogs.top/2020/04/22/%E9%98%BF%E9%87%8CRedis%E8%A7%84%E8%8C%83/"/>
    <id>http://wysblogs.top/2020/04/22/阿里Redis规范/</id>
    <published>2020-04-22T02:47:35.000Z</published>
    <updated>2020-04-24T10:49:49.731Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阿里云Redis规范"><a href="#阿里云Redis规范" class="headerlink" title="阿里云Redis规范"></a>阿里云Redis规范</h1><h2 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h2><h3 id="1、key名设计"><a href="#1、key名设计" class="headerlink" title="1、key名设计"></a><strong>1、key名设计</strong></h3><p><strong>(1)【建议】: 可读性和可管理性</strong></p><blockquote><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p></blockquote><p>ugc:video:1</p><p><strong>(2)【建议】：简洁性</strong></p><blockquote><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p></blockquote><p>user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。</p><p><strong>(3)【强制】：不要包含特殊字符</strong></p><p>反例：包含空格、换行、单双引号以及其他转义字符</p><p>2、value设计</p><p><strong>(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)</strong></p><p>string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p><p>反例：一个包含200万个元素的list。</p><p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p><p><strong>(2)【推荐】：选择适合的数据类型。</strong></p><p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)</p><p>反例：</p><blockquote><p>setuser:1:nametom</p><p>setuser:1:age19</p><p>setuser:1:favor football</p></blockquote><p>正例:</p><blockquote><p>hmsetuser:1nametomage19favorfootball</p></blockquote><p>3、【推荐】：控制key的生命周期，redis不是垃圾桶。</p><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p><h2 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h2><p><strong>1.【推荐】 O(N)命令关注N的数量</strong></p><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p><p><strong>2.【推荐】：禁用命令</strong></p><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><p><strong>3.【推荐】合理使用select</strong></p><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><p><strong>4.【推荐】使用批量操作提高效率</strong></p><blockquote><p>原生命令：例如mget、mset。</p><p>非原生命令：可以使用pipeline提高效率。</p></blockquote><p>但要注意控制一次批量操作的<strong>元素个数</strong>(例如500以内，实际也和元素字节数有关)。</p><p>注意两者不同：</p><blockquote><p>1、原生是原子操作，pipeline是非原子操作。</p><p>2、pipeline可以打包不同的命令，原生做不到</p><p>3、pipeline需要客户端和服务端同时支持。</p></blockquote><p><strong>5.【建议】Redis事务功能较弱，不建议过多使用</strong></p><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p><p><strong>6.【建议】Redis集群版本在使用Lua上有特殊要求：</strong></p><p>1.所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn”</p><p>2.所有key，必须在1个slot上，否则直接返回error, “-ERR eval/evalsha command keys must in same slotrn”</p><p><strong>7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。</strong></p><h2 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h2><p><strong>1.【推荐】</strong></p><p>避免多个应用使用一个Redis实例</p><p>正例：不相干的业务拆分，公共数据做服务化。</p><p><strong>2.【推荐】</strong></p><p>使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p><p><strong>3.【建议】</strong></p><p>高并发下建议客户端添加熔断功能(例如netflix hystrix)</p><p><strong>4.【推荐】</strong></p><p>设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p><p><strong>5.【建议】</strong></p><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p>其他策略如下：</p><p>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</p><p>allkeys-random：随机删除所有键，直到腾出足够空间为止。</p><p>volatile-random:随机删除过期键，直到腾出足够空间为止。</p><p>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</p><p>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</p><h2 id="四、相关工具"><a href="#四、相关工具" class="headerlink" title="四、相关工具"></a>四、相关工具</h2><p><strong>1.【推荐】：数据同步</strong></p><p>redis间数据同步可以使用：redis-port</p><p><strong>2.【推荐】：big key搜索</strong></p><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F117042" target="_blank" rel="noopener">redis大key搜索工具</a></p><p><strong>3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)</strong></p><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ffacebookarchive%2Fredis-faina" target="_blank" rel="noopener">facebook的redis-faina</a></p><blockquote><p>阿里云Redis已经在内核层面解决热点key问题，欢迎使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://wysblogs.top/categories/redis/"/>
    
    
      <category term="redis" scheme="http://wysblogs.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis初探</title>
    <link href="http://wysblogs.top/2020/04/21/Redis%E5%88%9D%E6%8E%A2/"/>
    <id>http://wysblogs.top/2020/04/21/Redis初探/</id>
    <published>2020-04-21T02:49:52.000Z</published>
    <updated>2020-04-21T02:50:32.745Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis初探"><a href="#Redis初探" class="headerlink" title="Redis初探"></a>Redis初探</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>下载压缩包</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.9.tar.gz</span><br></pre></td></tr></table></figure><p><strong>解压压缩包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-5.0.9.tar.gz</span><br><span class="line">#解压好感觉最好改个名字</span><br><span class="line">mv redis-5.0.9 redis</span><br></pre></td></tr></table></figure><p><strong>进入文件夹进行安装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis</span><br><span class="line">make MALLOC=libc</span><br></pre></td></tr></table></figure><p><strong>完成后进入src目录进行安装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>启动服务</strong></p><p>刚开始运行是不支持后台的，得在配置文件中进行修改，然后读取配置文件运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/bin/redis/redis.conf</span><br><span class="line">#修改下面这个配置为yes</span><br><span class="line">daemonize no</span><br><span class="line">#然后指定配置文件运行</span><br><span class="line">./redis-server /usr/local/bin/redis/redis.conf</span><br></pre></td></tr></table></figure><p><strong>关闭进程</strong></p><p>如果想关闭的话得先找到pid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#找PID有很多方法，我是习惯了这种从端口寻找的方法</span><br><span class="line">lsof -i:6379</span><br></pre></td></tr></table></figure><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>整合是整合到springboot中</p><p>首先导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<strong>application.yml</strong>中进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    redis:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">6379</span> <span class="comment">#端口号</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span> <span class="comment">#自己设置的密码</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">1000</span> <span class="comment">#连接超时时间</span></span><br><span class="line"><span class="attr">      jedis:</span></span><br><span class="line"><span class="attr">        pool:</span></span><br><span class="line"><span class="attr">          max-active:</span> <span class="number">10</span> <span class="comment">#最大连接数</span></span><br><span class="line"><span class="attr">          max-wait:</span> <span class="bullet">-1</span> <span class="comment">#最大阻塞等待时间</span></span><br><span class="line"><span class="attr">          max-idle:</span> <span class="number">500</span> <span class="comment">#最大空闲数量</span></span><br><span class="line"><span class="attr">          min-idle:</span> <span class="number">0</span> <span class="comment">#最小空闲数量</span></span><br></pre></td></tr></table></figure><p>之后就可以写配置类进行测试了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回查找到的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回布尔类型表示是否写入成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key,value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 更新的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 更新的value值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回是否更新成功的布尔类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            redisTemplate.opsForValue().getAndSet(key,value);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 要删除的缓存的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回是否删除成功的布尔类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在测试类中进行测试，我是测试之后没问题的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://wysblogs.top/categories/redis/"/>
    
    
      <category term="redis" scheme="http://wysblogs.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="http://wysblogs.top/2020/03/26/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://wysblogs.top/2020/03/26/Redis基础/</id>
    <published>2020-03-26T00:15:44.000Z</published>
    <updated>2020-03-26T00:19:55.343Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库/103728" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在<a href="https://redis.io/" target="_blank" rel="noopener">官网</a>下载，然后用ftp工具把下载的压缩包放到服务器上，解压缩</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>redis.conf 配置项说明如下：</p><table><thead><tr><th align="left">序号</th><th align="left">配置项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>daemonize no</code></td><td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="left">2</td><td align="left"><code>pidfile /var/run/redis.pid</code></td><td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="left">3</td><td align="left"><code>port 6379</code></td><td align="left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td align="left">4</td><td align="left"><code>bind 127.0.0.1</code></td><td align="left">绑定的主机地址</td></tr><tr><td align="left">5</td><td align="left"><code>timeout 300</code></td><td align="left">当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能</td></tr><tr><td align="left">6</td><td align="left"><code>loglevel notice</code></td><td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="left">7</td><td align="left"><code>logfile stdout</code></td><td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td align="left">8</td><td align="left"><code>databases 16</code></td><td align="left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td align="left">9</td><td align="left"><code>save &lt;seconds&gt; &lt;changes&gt;</code>Redis 默认配置文件中提供了三个条件：<strong>save 900 1</strong> <strong>save 300 10</strong> <strong>save 60 10000</strong>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td><td align="left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td align="left">10</td><td align="left"><code>rdbcompression yes</code></td><td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="left">11</td><td align="left"><code>dbfilename dump.rdb</code></td><td align="left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="left">12</td><td align="left"><code>dir ./</code></td><td align="left">指定本地数据库存放目录</td></tr><tr><td align="left">13</td><td align="left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td align="left">设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td align="left">14</td><td align="left"><code>masterauth &lt;master-password&gt;</code></td><td align="left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td align="left">15</td><td align="left"><code>requirepass foobared</code></td><td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</password></td></tr><tr><td align="left">16</td><td align="left"><code>maxclients 128</code></td><td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="left">17</td><td align="left"><code>maxmemory &lt;bytes&gt;</code></td><td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td align="left">18</td><td align="left"><code>appendonly no</code></td><td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="left">19</td><td align="left"><code>appendfilename appendonly.aof</code></td><td align="left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="left">20</td><td align="left"><code>appendfsync everysec</code></td><td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="left">21</td><td align="left"><code>vm-enabled no</code></td><td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td align="left">22</td><td align="left"><code>vm-swap-file /tmp/redis.swap</code></td><td align="left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="left">23</td><td align="left"><code>vm-max-memory 0</code></td><td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="left">24</td><td align="left"><code>vm-page-size 32</code></td><td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="left">25</td><td align="left"><code>vm-pages 134217728</code></td><td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="left">26</td><td align="left"><code>vm-max-threads 4</code></td><td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td align="left">27</td><td align="left"><code>glueoutputbuf yes</code></td><td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td align="left">28</td><td align="left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td><td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td align="left">29</td><td align="left"><code>activerehashing yes</code></td><td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td align="left">30</td><td align="left"><code>include /path/to/local.conf</code></td><td align="left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><h2 id="常用的数据类型及应用场景"><a href="#常用的数据类型及应用场景" class="headerlink" title="常用的数据类型及应用场景"></a>常用的数据类型及应用场景</h2><table><thead><tr><th align="left">类型</th><th align="left">简介</th><th align="left">特性</th><th align="left">场景</th></tr></thead><tbody><tr><td align="left">String(字符串)</td><td align="left">二进制安全</td><td align="left">可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td align="left">—</td></tr><tr><td align="left">Hash(字典)</td><td align="left">键值对集合,即编程语言中的Map类型</td><td align="left">适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td align="left">存储、读取、修改用户属性</td></tr><tr><td align="left">List(列表)</td><td align="left">链表(双向链表)</td><td align="left">增删快,提供了操作某一段元素的API</td><td align="left">1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td align="left">Set(集合)</td><td align="left">哈希表实现,元素不重复</td><td align="left">1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td align="left">1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td align="left">Sorted Set(有序集合)</td><td align="left">将Set中的元素增加一个权重参数score,元素按score有序排列</td><td align="left">数据插入集合时,已经进行天然排序</td><td align="left">1、排行榜 2、带权重的消息队列</td></tr></tbody></table><h2 id="待更新。。。"><a href="#待更新。。。" class="headerlink" title="待更新。。。"></a>待更新。。。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://wysblogs.top/categories/redis/"/>
    
    
      <category term="redis" scheme="http://wysblogs.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>多模块开发踩坑</title>
    <link href="http://wysblogs.top/2020/03/17/%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91/"/>
    <id>http://wysblogs.top/2020/03/17/多模块开发踩坑/</id>
    <published>2020-03-17T08:57:32.000Z</published>
    <updated>2020-03-18T07:32:07.156Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多模块开发踩坑"><a href="#多模块开发踩坑" class="headerlink" title="多模块开发踩坑"></a>多模块开发踩坑</h1><h2 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h2><p><img src="/upload/%E5%A4%9A%E6%A8%A1%E5%9D%97/%E5%A4%9A%E6%A8%A1%E5%9D%97.png" alt="多模块"></p><h2 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h2><p>1、 父pom文件内容，该写什么，什么部分不需要</p><p>2、 子pom文件内容，怎么去继承父模块</p><p>3、 怎么规范版本号，以及怎么统一包的版本</p><p>4、 怎么启动项目，怎么打包，怎么发布</p><p>5、 每个模块之前的packaging怎么填，谁需要打包，谁需要war，谁需要jar</p><p>6、 模块的子模块中还有子模块，这样的情况怎么调用和使用。</p><p>7、 application的配置到底属于哪一个模块</p><p>8、 relativePath到底需不需要（大坑）</p><p>9、 如果出现模块不一致怎么办</p><p>10、dependencyManagement和dependencies区别</p><p>11、多模块中怎么给需要的bean注入值</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>1、 写自己的版本号，把需要用的包使用 &lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; 导入，如果子类继承父类后，如果需要包的话就直接导入不用指明版本号</p><p>2、 如果直接在父pom中使用 &lt;dependencies&gt;&lt;/dependencies&gt;  的话那么子类不管用不用都需要导入</p><p>3、 子pom文件直接导入父pom文件的版本号就行</p><p>4、 版本号写在父pom文件中，以及包的版本号统一在父pom文件中使用，而且不需要指定jar的version了</p><p>5、 启动项目，我感觉应该是web层进行启动项目</p><p>6、 打包问题，如果项目没有问题直接对父项目 clean + package 即可，最后生成的包在web模块中</p><p>7、 一般来说父模块一般都是用pom聚合，子模块都要打成jar包，war包则一般都是web模块</p><p>8、 父模块需要指定所有子模块，子模块相互调用是通过相互依赖来实现的</p><p>9、 application的配置一般在web模块中</p><p>10、relativePath看情况来判断，首先relativePath默认值为../pom.xml ，查找顺序：relativePath元素中的地址–本地仓库–远程仓库，设定一个空值将始终从仓库中获取，不从本地路径获取，如&lt;relativePath /&gt;</p><p>11、如果模块不一致，那么就需要打开project Structure，在模块中把右边不一致的模块删除</p><p>12、如果用dependencyManagement来指定依赖，那么子模块中默认不会有，需要使用的时候只需要导入坐标就行，不需要指定版本号，默认使用的是父模块中的版本号，如果使用dependencies的话，不管子模块中用不用得到，都会在子模块中显示依赖。</p><p>13、如果想要注入值，那么需要在springbootApplication的注解中进行添加扫包，把其他模块中的类扫描进来</p><p>例如这种格式 <code>@SpringBootApplication(scanBasePackages = {&quot;com.guidinglight&quot;})</code></p><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><h3 id="parent模块"><a href="#parent模块" class="headerlink" title="parent模块"></a>parent模块</h3><p><strong>packaging</strong> 需要改成 pom，因为默认为jar类型，改成pom表示夫类型都是pom类型</p><p><strong>modules</strong> 把子模块全部添加进去</p><p><strong>dependencyManagement</strong> 把需要用到的依赖都给添加进去，如果需要使用直接导入依赖就行了</p><h3 id="child模块"><a href="#child模块" class="headerlink" title="child模块"></a><strong>child模块</strong></h3><p>就是正常使用即可，需要什么依赖直接添加</p><h2 id="待更新。。。"><a href="#待更新。。。" class="headerlink" title="待更新。。。"></a>待更新。。。</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/gdsgdh308227363/article/details/79722491" target="_blank" rel="noopener">https://blog.csdn.net/gdsgdh308227363/article/details/79722491</a></p><p><a href="https://blog.csdn.net/zwt0909/article/details/52218222" target="_blank" rel="noopener">https://blog.csdn.net/zwt0909/article/details/52218222</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发经验" scheme="http://wysblogs.top/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="开发经验" scheme="http://wysblogs.top/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>多模块项目理解</title>
    <link href="http://wysblogs.top/2020/03/17/%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E7%90%86%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/03/17/多模块项目理解/</id>
    <published>2020-03-17T01:44:13.000Z</published>
    <updated>2020-03-17T03:07:35.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多模块项目理解"><a href="#多模块项目理解" class="headerlink" title="多模块项目理解"></a>多模块项目理解</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>为什么要用多模块？</strong></p><p>1、 做项目首先讲究 “高内聚，低耦合”，因此传统的项目是将一个项目分为多个包，随着项目复杂，如果想复用一个模块的话，因为是包的形式，复用起来会很麻烦，耦合性很强，常用的方法就是复制代码修改，但是这样会做出很多无用功和增加出错几率。</p><p>2、 springboot多模块简单说，就是把包按分模块的模式，借助maven升级到jar方式，抽象性就更强了，假如jar再升级到war或者多个集合的jar，就成微服务了，在多模块jar模式下，可以将某个jar拿出来对外共用，能大大提高代码复用率和开发效率。</p><p>3、 开发者对自己或者别人负责的代码边界很模糊，这是复杂项目中最容易遇到的，导致结果就是开发者很容易修改别人代码，而且代码负责人还不知道，责任追踪很麻烦。</p><p>4、简单来说就是 高内聚，低耦合，容易维护，便于开发者确定自己负责的内容。</p><p>5、以上都是百度的。</p><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><p>1、首先确定项目开发结构</p><p>2、创建最基本的项目模块</p><p>3、理清楚各模块之间的依赖关系</p><p>4、修改pom文件，统一版本号和使用的jar包版本，如果在此期间觉得哪几个模块能够合并，就优化一下</p><h2 id="可能会存在的问题"><a href="#可能会存在的问题" class="headerlink" title="可能会存在的问题"></a>可能会存在的问题</h2><p><strong>（1） 划分模块的方式</strong></p><p>划分模块主要根据是职责单一性和耦合性，如果是项目创建初期就使用多模块来规划项目，那么职责单一性就应该是首先考虑的，也就是通常意义上的按照层次划分，如果是从一个十分复杂的项目开始拆分，那么在划分模块的石航就不仅仅是考虑职责单一性了，职责单一会造成大量的子模块产生导致pom文件臃肿且不容易识别，如果将耦合性考虑进去就应该将关系较为紧密的模块合并降低模块的数量提高实用性。</p><p><strong>（2） 公有依赖的抽象</strong></p><p>parent中的以来配置主要是有一些公有的依赖，例如log，apache，commons，spring等，怎么界定一个依赖是否属于公有呢？一般情况下如果这个依赖被超过2/3的子模块所依赖就可以将其认定为公有依赖，另外也可以将依赖的某些配置（例如版本号）以parent中pom的属性的形式加以声明，这样在升级某些依赖的时候只要改动一处就行了（很类似C语言中的#define）</p><p><strong>（3） 模块的存在与消亡</strong></p><p>模块的划分并不是一成不变的，模块的存在就是为了方便维护和提高生产效率，如果某些模块不合理并且影响了开发效率，那么这些模块就需要再好好斟酌一下，一般情况下这种情况出现不是为了模块过于庞大就是因为模块的碎片化，对于前者需要拆分更多模块以提高复用和去除冗余，后者则需要酌情合并一些耦合性较高的模块。</p><p><strong>（4） 子模块的子模块</strong></p><p>这种情况的出现往往就意味着这个项目本身就应该被分成多个项目，多个项目之间也可以继承同一个parent的pom.xml这主要是为了方便统一构建多个项目。所以子模块的子模块应该避免出现。</p><h2 id="待更新。。。"><a href="#待更新。。。" class="headerlink" title="待更新。。。"></a>待更新。。。</h2><p>引用如下:  </p><p><a href="https://blog.csdn.net/wuzhenwei0419/article/details/84029454" target="_blank" rel="noopener">https://blog.csdn.net/wuzhenwei0419/article/details/84029454</a></p><p><a href="https://www.cnblogs.com/ruanjianlaowang/p/11214271.html" target="_blank" rel="noopener">https://www.cnblogs.com/ruanjianlaowang/p/11214271.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开发经验" scheme="http://wysblogs.top/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="开发经验" scheme="http://wysblogs.top/tags/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Centos基本信息和ssh</title>
    <link href="http://wysblogs.top/2019/12/12/Centos%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%92%8Cssh/"/>
    <id>http://wysblogs.top/2019/12/12/Centos基本信息和ssh/</id>
    <published>2019-12-12T13:26:22.000Z</published>
    <updated>2019-12-12T17:02:07.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Centos-基本信息和SSH"><a href="#Centos-基本信息和SSH" class="headerlink" title="Centos 基本信息和SSH"></a>Centos 基本信息和SSH</h1><h2 id="Centos介绍"><a href="#Centos介绍" class="headerlink" title="Centos介绍"></a>Centos介绍</h2><p>CentOS Linux是一个社区支持的发行版，该发行版来自在<a href="ftp://ftp.redhat.com/pub/redhat/linux/enterprise/" target="_blank" rel="noopener">Red Hat</a>或<a href="https://git.centos.org/" target="_blank" rel="noopener">CentOS git</a>上免费提供给公众的资源适用于Red Hat Enterprise Linux（RHEL）。因此，CentOS Linux旨在与RHEL在功能上兼容。CentOS专案主要更改软件包以删除上游供应商的品牌和艺术品。CentOS Linux是免费的，可以免费重新分发。每个CentOS版本都会得到维护，直到等效的RHEL版本不再受到一般支持为止。一旦重建了新的RHEL版本，便会提供一个新的CentOS版本-大约每6-12个月发行一次次要点发布，几年则更新一次主要版本。重建所需的时间从点发布的几周到主要版本变更的几个月不等。这样就形成了一个安全，低维护，可靠，可预测和可再现的Linux环境。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><strong><a href="https://wiki.centos.org/Download" target="_blank" rel="noopener">下载地址</a></strong></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">cd /home</td><td align="left">进入 ‘/home’ 目录</td></tr><tr><td align="left">cd ..</td><td align="left">返回上一级目录</td></tr><tr><td align="left">cd ../..</td><td align="left">返回上两级目录</td></tr><tr><td align="left">cd -</td><td align="left">返回上次所在目录</td></tr><tr><td align="left">cp file1 file2</td><td align="left">将file1复制为file2</td></tr><tr><td align="left">cp -a dir1 dir2</td><td align="left">复制一个目录</td></tr><tr><td align="left">cp -a /tmp/dir1 .</td><td align="left">复制一个目录到当前工作目录（.代表当前目录）</td></tr><tr><td align="left">ls</td><td align="left">查看目录中的文件</td></tr><tr><td align="left">ls -a</td><td align="left">显示隐藏文件</td></tr><tr><td align="left">ls -l</td><td align="left">显示详细信息</td></tr><tr><td align="left">ls -lrt</td><td align="left">按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</td></tr><tr><td align="left">pwd</td><td align="left">显示工作路径</td></tr><tr><td align="left">mkdir dir1</td><td align="left">创建 ‘dir1’ 目录</td></tr><tr><td align="left">mkdir dir1 dir2</td><td align="left">同时创建两个目录</td></tr><tr><td align="left">mkdir -p /tmp/dir1/dir2</td><td align="left">创建一个目录树</td></tr><tr><td align="left">mv dir1 dir2</td><td align="left">移动/重命名一个目录</td></tr><tr><td align="left">rm -f file1</td><td align="left">删除 ‘file1’</td></tr><tr><td align="left">rm -rf dir1</td><td align="left">删除 ‘dir1’ 目录及其子目录内容</td></tr></tbody></table><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">cat file1</td><td align="left">从第一个字节开始正向查看文件的内容</td></tr><tr><td align="left">head -2 file1</td><td align="left">查看一个文件的前两行</td></tr><tr><td align="left">more file1</td><td align="left">查看一个长文件的内容</td></tr><tr><td align="left">tac file1</td><td align="left">从最后一行开始反向查看一个文件的内容</td></tr><tr><td align="left">tail -3 file1</td><td align="left">查看一个文件的最后三行</td></tr><tr><td align="left">vi file</td><td align="left">打开并浏览文件</td></tr></tbody></table><h3 id="文本内容处理"><a href="#文本内容处理" class="headerlink" title="文本内容处理"></a>文本内容处理</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">grep str /tmp/test</td><td align="left">在文件 ‘/tmp/test’ 中查找 “str”</td></tr><tr><td align="left">grep ^str /tmp/test</td><td align="left">在文件 ‘/tmp/test’ 中查找以 “str” 开始的行</td></tr><tr><td align="left">grep [0-9] /tmp/test</td><td align="left">查找 ‘/tmp/test’ 文件中所有包含数字的行</td></tr><tr><td align="left">grep str -r /tmp/*</td><td align="left">在目录 ‘/tmp’ 及其子目录中查找 “str”</td></tr><tr><td align="left">diff file1 file2</td><td align="left">找出两个文件的不同处</td></tr><tr><td align="left">sdiff file1 file2</td><td align="left">以对比的方式显示两个文件的不同</td></tr><tr><td align="left">vi file</td><td align="left">操作解析i进入编辑文本模式Esc退出编辑文本模式:w保存当前修改:q不保存退出vi:wq保存当前修改并退出vi</td></tr></tbody></table><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">find / -name file1</td><td align="left">从 ‘/’ 开始进入根文件系统查找文件和目录</td></tr><tr><td align="left">find / -user user1</td><td align="left">查找属于用户 ‘user1’ 的文件和目录</td></tr><tr><td align="left">find /home/user1 -name *.bin</td><td align="left">在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件</td></tr><tr><td align="left">find /usr/bin -type f -atime +100</td><td align="left">查找在过去100天内未被使用过的执行文件</td></tr><tr><td align="left">find /usr/bin -type f -mtime -10</td><td align="left">查找在10天内被创建或者修改过的文件</td></tr><tr><td align="left">locate *.ps</td><td align="left">寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令</td></tr><tr><td align="left">find -name ‘*.[ch]’ | xargs grep -E ‘expr’</td><td align="left">在当前目录及其子目录所有.c和.h文件中查找 ‘expr’</td></tr><tr><td align="left">find -type f -print0 | xargs -r0 grep -F ‘expr’</td><td align="left">在当前目录及其子目录的常规文件中查找 ‘expr’</td></tr><tr><td align="left">find -maxdepth 1 -type f | xargs grep -F ‘expr’</td><td align="left">在当前目录中查找 ‘expr’</td></tr></tbody></table><h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">bzip2 file1</td><td align="left">压缩 file1</td></tr><tr><td align="left">bunzip2 file1.bz2</td><td align="left">解压 file1.bz2</td></tr><tr><td align="left">gzip file1</td><td align="left">压缩 file1</td></tr><tr><td align="left">gzip -9 file1</td><td align="left">最大程度压缩 file1</td></tr><tr><td align="left">gunzip file1.gz</td><td align="left">解压 file1.gz</td></tr><tr><td align="left">tar -cvf archive.tar file1</td><td align="left">把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</td></tr><tr><td align="left">tar -cvf archive.tar file1 dir1</td><td align="left">把 file1，dir1 打包成 archive.tar</td></tr><tr><td align="left">tar -tf archive.tar</td><td align="left">显示一个包中的内容</td></tr><tr><td align="left">tar -xvf archive.tar</td><td align="left">释放一个包</td></tr><tr><td align="left">tar -xvf archive.tar -C /tmp</td><td align="left">把压缩包释放到 /tmp目录下</td></tr><tr><td align="left">zip file1.zip file1</td><td align="left">创建一个zip格式的压缩包</td></tr><tr><td align="left">zip -r file1.zip file1 dir1</td><td align="left">把文件和目录压缩成一个zip格式的压缩包</td></tr><tr><td align="left">unzip file1.zip</td><td align="left">解压一个zip格式的压缩包到当前目录</td></tr><tr><td align="left">unzip test.zip -d /tmp/</td><td align="left">解压一个zip格式的压缩包到 /tmp 目录</td></tr></tbody></table><h3 id="yum安装器"><a href="#yum安装器" class="headerlink" title="yum安装器"></a>yum安装器</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">yum -y install [package]</td><td align="left">下载并安装一个rpm包</td></tr><tr><td align="left">yum localinstall [package.rpm]</td><td align="left">安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</td></tr><tr><td align="left">yum -y update</td><td align="left">更新当前系统中安装的所有rpm包</td></tr><tr><td align="left">yum update [package]</td><td align="left">更新一个rpm包</td></tr><tr><td align="left">yum remove [package]</td><td align="left">删除一个rpm包</td></tr><tr><td align="left">yum list</td><td align="left">列出当前系统中安装的所有包</td></tr><tr><td align="left">yum search [package]</td><td align="left">在rpm仓库中搜寻软件包</td></tr><tr><td align="left">yum clean [package]</td><td align="left">清除缓存目录（/var/cache/yum）下的软件包</td></tr><tr><td align="left">yum clean headers</td><td align="left">删除所有头文件</td></tr><tr><td align="left">yum clean all</td><td align="left">删除所有缓存的包和头文件</td></tr></tbody></table><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">ifconfig eth0</td><td align="left">显示一个以太网卡的配置</td></tr><tr><td align="left">ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td align="left">配置网卡的IP地址</td></tr><tr><td align="left">ifdown eth0</td><td align="left">禁用 ‘eth0’ 网络设备</td></tr><tr><td align="left">ifup eth0</td><td align="left">启用 ‘eth0’ 网络设备</td></tr><tr><td align="left">iwconfig eth1</td><td align="left">显示一个无线网卡的配置</td></tr><tr><td align="left">iwlist scan</td><td align="left">显示无线网络</td></tr><tr><td align="left">ip addr show</td><td align="left">显示网卡的IP地址</td></tr></tbody></table><h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">su -</td><td align="left">切换到root权限（与su有区别）</td></tr><tr><td align="left">shutdown -h now</td><td align="left">关机</td></tr><tr><td align="left">shutdown -r now</td><td align="left">重启</td></tr><tr><td align="left">top</td><td align="left">罗列使用CPU资源最多的linux任务 （输入q退出）</td></tr><tr><td align="left">pstree</td><td align="left">以树状图显示程序</td></tr><tr><td align="left">man ping</td><td align="left">查看参考手册（例如ping 命令）</td></tr><tr><td align="left">passwd</td><td align="left">修改密码</td></tr><tr><td align="left">df -h</td><td align="left">显示磁盘的使用情况</td></tr><tr><td align="left">cal -3</td><td align="left">显示前一个月，当前月以及下一个月的月历</td></tr><tr><td align="left">cal 10 1988</td><td align="left">显示指定月，年的月历</td></tr><tr><td align="left">date –date ‘1970-01-01 UTC 1427888888 seconds’</td><td align="left">把一相对于1970-01-01 00:00的秒数转换成时间</td></tr></tbody></table><h2 id="XSheel-5相关操作"><a href="#XSheel-5相关操作" class="headerlink" title="XSheel 5相关操作"></a>XSheel 5相关操作</h2><h3 id="窗体快捷键"><a href="#窗体快捷键" class="headerlink" title="窗体快捷键"></a>窗体快捷键</h3><table><thead><tr><th align="left">命令</th><th align="left">解析</th></tr></thead><tbody><tr><td align="left">Ctrl + u</td><td align="left">删除光标之前到行首的字符</td></tr><tr><td align="left">Ctrl + k</td><td align="left">删除光标之前到行尾的字符</td></tr><tr><td align="left">Ctrl + c</td><td align="left">取消当前行输入的命令，相当于Ctrl + Break</td></tr><tr><td align="left">Ctrl + a</td><td align="left">光标移动到行首（ahead of line），相当于通常的Home键</td></tr><tr><td align="left">Ctrl + e</td><td align="left">光标移动到行尾（end of line）</td></tr><tr><td align="left">Ctrl + f</td><td align="left">光标向前（forward）移动一个字符位置</td></tr><tr><td align="left">Ctrl + b</td><td align="left">光标往回（backward）移动一个字符位置</td></tr><tr><td align="left">Ctrl + l</td><td align="left">清屏，相当于执行clear命令</td></tr><tr><td align="left">Ctrl + r</td><td align="left">显示:号提示，根据用户输入查找相关历史命令（reverse-i-search）</td></tr><tr><td align="left">Ctrl + w</td><td align="left">删除从光标位置前到当前所处单词（word）的开头</td></tr><tr><td align="left">Ctrl + t</td><td align="left">交换光标位置前的两个字符</td></tr><tr><td align="left">Ctrl + y</td><td align="left">粘贴最后一次被删除的单词</td></tr><tr><td align="left">Ctrl + Alt + d</td><td align="left">显示桌面</td></tr><tr><td align="left">Alt + b</td><td align="left">光标往回（backward）移动到前一个单词</td></tr><tr><td align="left">Alt + d</td><td align="left">删除从光标位置到当前所处单词的末尾</td></tr><tr><td align="left">Alt + F2</td><td align="left">运行</td></tr><tr><td align="left">Alt + F4</td><td align="left">关闭当前窗口</td></tr><tr><td align="left">Alt + F9</td><td align="left">最小化当前窗口</td></tr><tr><td align="left">Alt + F10</td><td align="left">最大化当前窗口</td></tr><tr><td align="left">Alt + Tab</td><td align="left">切换窗口</td></tr><tr><td align="left">Alt + 左键</td><td align="left">移动窗口（或在最下面的任务栏滚动鼠标滑轮）</td></tr></tbody></table><h2 id="SSH介绍"><a href="#SSH介绍" class="headerlink" title="SSH介绍"></a>SSH介绍</h2><p>SSH 为 [Secure Shell](<a href="https://baike.baidu.com/item/Secure" target="_blank" rel="noopener">https://baike.baidu.com/item/Secure</a> Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为<a href="https://baike.baidu.com/item/远程登录/1071998" target="_blank" rel="noopener">远程登录</a>会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括<a href="https://baike.baidu.com/item/HP-UX" target="_blank" rel="noopener">HP-UX</a>、<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>、<a href="https://baike.baidu.com/item/AIX" target="_blank" rel="noopener">AIX</a>、<a href="https://baike.baidu.com/item/Solaris/3517" target="_blank" rel="noopener">Solaris</a>、<a href="https://baike.baidu.com/item/Digital" target="_blank" rel="noopener">Digital</a> <a href="https://baike.baidu.com/item/UNIX" target="_blank" rel="noopener">UNIX</a>、<a href="https://baike.baidu.com/item/Irix" target="_blank" rel="noopener">Irix</a>，以及其他平台，都可运行SSH。</p><h2 id="SSH用法"><a href="#SSH用法" class="headerlink" title="SSH用法"></a>SSH用法</h2><h3 id="检查是否开启ssh"><a href="#检查是否开启ssh" class="headerlink" title="检查是否开启ssh"></a>检查是否开启ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>rpm -qa | grep ssh</span><br></pre></td></tr></table></figure><h3 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>yum install openssh-server</span><br></pre></td></tr></table></figure><h3 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /bin/systemctl start sshd.service</span><br></pre></td></tr></table></figure><h3 id="继续检查是否开启"><a href="#继续检查是否开启" class="headerlink" title="继续检查是否开启"></a>继续检查是否开启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>ps -e | grep sshd</span><br></pre></td></tr></table></figure><h3 id="将ssh添加自启动"><a href="#将ssh添加自启动" class="headerlink" title="将ssh添加自启动"></a>将ssh添加自启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>systemctl enable sshd.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="centos" scheme="http://wysblogs.top/categories/centos/"/>
    
    
      <category term="centos" scheme="http://wysblogs.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>centos mysql配置</title>
    <link href="http://wysblogs.top/2019/12/11/Centos7-mysql%E9%85%8D%E7%BD%AE/"/>
    <id>http://wysblogs.top/2019/12/11/Centos7-mysql配置/</id>
    <published>2019-12-11T01:16:07.000Z</published>
    <updated>2019-12-12T17:27:28.956Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Centos-7-Mysql配置"><a href="#Centos-7-Mysql配置" class="headerlink" title="Centos 7 Mysql配置"></a>Centos 7 Mysql配置</h1><h2 id="Yum安装"><a href="#Yum安装" class="headerlink" title="Yum安装"></a>Yum安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>安装</span><br><span class="line"><span class="meta">$</span>yum install mysql-server</span><br><span class="line"><span class="meta">#</span>启动</span><br><span class="line"><span class="meta">$</span>systemctl start mysqld </span><br><span class="line"><span class="meta">#</span>登录</span><br><span class="line"><span class="meta">$</span>mysql -u root -p</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>修改root密码</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">进入mysql系统表</span><br><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"></span><br><span class="line">对用户进行排序</span><br><span class="line">desc user;</span><br><span class="line"></span><br><span class="line">修改root密码</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">password</span> = <span class="keyword">password</span>(“root”) <span class="keyword">where</span> <span class="keyword">user</span> = ‘root’;</span><br><span class="line"></span><br><span class="line">刷新权限</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line">赋予其他机器可以访问的权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> . <span class="keyword">to</span> root@’%’ <span class="keyword">identified</span> <span class="keyword">by</span> ‘root’ <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure><p><strong>修改字符集</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p>修改成这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">user=mysql</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure><p>重启mysql服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>service mysqld restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在mysql中查看字符编码</span><br><span class="line">show variables like 'character_set%';</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="centos" scheme="http://wysblogs.top/categories/centos/"/>
    
    
      <category term="centos" scheme="http://wysblogs.top/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>centos7 防火墙优化</title>
    <link href="http://wysblogs.top/2019/12/11/Centos7-%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>http://wysblogs.top/2019/12/11/Centos7-防火墙/</id>
    <published>2019-12-11T01:14:40.000Z</published>
    <updated>2019-12-12T17:20:49.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Centos-7-防火墙优化"><a href="#Centos-7-防火墙优化" class="headerlink" title="Centos 7 防火墙优化"></a>Centos 7 防火墙优化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Centos 7 使用的防火墙是 firewall，可以允许哪些服务可用，哪些端口可用</p><h2 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>systemctl enable firewalld.service #启用 "开机启动"</span><br><span class="line"><span class="meta">$</span>systemctl disable firewalld.service #关闭 "开机启动"</span><br><span class="line"><span class="meta">$</span>systemctl start firewalld.service #启用防火墙</span><br><span class="line"><span class="meta">$</span>systemctl stop firewalld.service #关闭防火墙</span><br><span class="line"><span class="meta">$</span>systemctl status firewalld.service #查看防火墙状态</span><br><span class="line"></span><br><span class="line">【开机自启】</span><br><span class="line"><span class="meta">$</span>chkconfig firewalld on #"开机自启" 开启</span><br><span class="line"><span class="meta">$</span>chkconfig firewalld off  #"开机自启" 关闭</span><br></pre></td></tr></table></figure><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口其实就是 类似于门的东西，你只能通过这扇门来访问我的服务器，</p><p>因此对于服务器安全来说，这扇门还是很重要的。</p><p><strong>开放端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>firewall-cmd --zone=public --add-port=&#123;端口&#125;/tcp --permanent #开放端口</span><br><span class="line"><span class="meta">#</span>开放端口之后必须重新启动防火墙才可以生效</span><br><span class="line"><span class="meta">$</span>systemctl restart firewalld.service #重启防火墙</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> --zone 作用域</span><br><span class="line"><span class="meta">#</span> --add-port=&#123;端口&#125;/tcp 添加端口</span><br><span class="line"><span class="meta">#</span> --permanent 永久生效，没有这个重启之后就会失效</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看开启端口</span><br><span class="line"><span class="meta">$</span>firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p><strong>关闭端口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><strong>修改22端口</strong></p><p>1、打开 /etc/ssh/sshd_config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>2、将#Port 22 注释去掉，22改为你想设置的端口，如33881，保存</p><p>3、重启ssh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure><p>4)将该端口加入防火墙例外并重启防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>firewall-cmd --permanent --zone=public --add-port=33881/tcp</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span>sudo systemctl restart firewalld.service</span><br></pre></td></tr></table></figure><p><strong>密码长度与有效期</strong></p><p>默认配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>cat /etc/login.defs |grep PASS_ |grep -v '#'</span><br><span class="line"></span><br><span class="line">PASS_MAX_DAYS    99999</span><br><span class="line">PASS_MIN_DAYS    0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE    7</span><br></pre></td></tr></table></figure><p>加固方案:</p><p>1.备份配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cp -a /etc/login.defs /etc/login.defs.default</span><br></pre></td></tr></table></figure><p>2.编辑配置文件并将相关参数改成如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>vi /etc/login.defs</span><br><span class="line">PASS_MAX_DAYS 90</span><br><span class="line">PASS_MIN_DAYS 6</span><br><span class="line">PASS_MIN_LEN 8</span><br><span class="line">PASS_WARN_AGE 30</span><br></pre></td></tr></table></figure><p>备注:</p><p>/etc/login.defs文件的pass_min_len 参数并不具备强制性，测试仍然可以设置7位密码。最终需要cracklib来实现。</p><p>参数说明：</p><p>PASS_MAX_DAYS 密码有效期</p><p>PASS_MIN_DAYS 修改密码的最短期限</p><p>PASS_MIN_LEN 密码最短长度</p><p>PASS_WARN_AGE 密码过期提醒</p><p><strong>禁止root通过ssh远程登录</strong></p><p>默认配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>cat /etc/ssh/sshd_config |grep PermitRootLogin</span><br><span class="line"><span class="meta">#</span>PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>加固方案:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.备份配置文件</span><br><span class="line"><span class="meta">$</span>cp -a /etc/ssh/sshd_config /etc/ssh/sshd_config.default</span><br><span class="line">2.编辑配置文件</span><br><span class="line"><span class="meta">$</span>vi /etc/ssh/sshd_config</span><br><span class="line">将配置参数#PermitRootLogin yes改成PermitRootLogin no</span><br><span class="line">3.保存配置文件</span><br><span class="line">4.重启ssh服务</span><br><span class="line"><span class="meta">$</span> /etc/init.d/sshd restart</span><br></pre></td></tr></table></figure><p><strong>SSH 配置参数增强</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.备份配置文件</span><br><span class="line">2.编辑配置文件</span><br><span class="line"><span class="meta">$</span>vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">（1）禁止空密码登录</span><br><span class="line">将#PermitEmptyPasswords no参数的注释符号去掉，改成</span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"></span><br><span class="line">（2）关闭ssh的tcp转发</span><br><span class="line">将#AllowTcpForwarding yes参数改成</span><br><span class="line">AllowTcpForwarding no</span><br><span class="line"></span><br><span class="line">（3）关闭S/KEY（质疑-应答)认证方式</span><br><span class="line">将#ChallengeResponseAuthentication yes参数，改成</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（4）关闭基于GSSAPI 的用户认证</span><br><span class="line">将GSSAPIAuthentication yes参数，改成</span><br><span class="line">GSSAPIAuthentication no</span><br><span class="line"></span><br><span class="line">3.保存配置文件</span><br><span class="line">4.重启ssh服务</span><br></pre></td></tr></table></figure><p><strong>隐藏系统版本信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行以下命令：</span><br><span class="line"><span class="meta">$</span>mv /etc/issue /etc/issue.bak</span><br><span class="line"><span class="meta">$</span>mv /etc/issue.net /etc/issue.net.bak</span><br></pre></td></tr></table></figure><p>备注:登录界面显示系统版本信息</p><p><strong>系统参数调优</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1.备份配置文件</span><br><span class="line">cp -a /etc/sysctl.conf /etc/sysctl.conf.default</span><br><span class="line">2.添加以下调优参数到该文件中</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.route.gc_timeout = 20</span><br><span class="line">net.ipv4.tcp_retries2 = 5</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_wmem = 8192 131072 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 32768 131072 16777216</span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line">net.core.somaxconn = 262144</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.ipv4.route.gc_timeout = 20</span><br><span class="line">net.ipv4.ip_local_port_range = 10024  65535</span><br><span class="line">net.ipv4.tcp_retries2 = 5</span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 30</span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line">net.ipv4.tcp_wmem = 8192 131072 16777216</span><br><span class="line">net.ipv4.tcp_rmem = 32768 131072 16777216</span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line"></span><br><span class="line">fs.file-max = 65535</span><br><span class="line">kernel.pid_max = 65536</span><br><span class="line">net.ipv4.tcp_wmem = 4096 87380 8388608</span><br><span class="line">net.core.wmem_max = 8388608</span><br><span class="line">net.core.netdev_max_backlog = 5000</span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line"></span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line">net.core.somaxconn = 262144</span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = 120</span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 36000</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="centos" scheme="http://wysblogs.top/categories/centos/"/>
    
    
      <category term="centos" scheme="http://wysblogs.top/tags/centos/"/>
    
  </entry>
  
</feed>
