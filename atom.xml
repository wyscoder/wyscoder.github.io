<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wys&#39;blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wysblogs.top/"/>
  <updated>2020-07-26T01:51:15.220Z</updated>
  <id>http://wysblogs.top/</id>
  
  <author>
    <name>wys</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql锁详解</title>
    <link href="http://wysblogs.top/2020/07/25/mysql%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/25/mysql锁详解/</id>
    <published>2020-07-24T18:19:16.000Z</published>
    <updated>2020-07-26T01:51:15.220Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql锁详解"><a href="#mysql锁详解" class="headerlink" title="mysql锁详解"></a>mysql锁详解</h1><p>mysql的锁可以用两种情况区分</p><p>按粒度分为 行锁,页锁,表锁 </p><p>按用法有共享锁和排他锁</p><h2 id="按粒度来分"><a href="#按粒度来分" class="headerlink" title="按粒度来分"></a>按粒度来分</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>行锁是锁粒度最细的一个锁了,表示只对自己当前操作的行加锁.</p><p>行锁操作可以大大的减少数据库操作带来的冲突,但是加速开销太大</p><p>行锁分为共享锁和排他锁.</p><p>特点: 开销大,可能会出现死锁,并发程度高,锁冲突概率最低.</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁是mysql锁粒度最大的一个锁, 表示对当前操作的整张表都加锁, 资源消耗大, 被大部分引擎都支持.</p><p>表锁分为 共享锁 和 排他锁</p><p>特点: 开销小, 加锁快, 不会出现死锁, 锁粒度大, 发生冲突的概率最大, 并发性最低.</p><h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><p>页级锁是mysql中锁粒度一般的锁, 一般都是在行锁和表锁之间.</p><p>表锁速度快,但是冲突多, 行锁冲突少, 但是速度慢, 于是采用 页锁的比较多.</p><p>页锁是一次锁定相邻的一组记录开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁是一种悲观的并发控制线程访问的一个方法.</p><p>它可以阻止一个事务以影响其他用户的方式来修改数据.</p><p>如果一个事务的操作的某行数据加了锁, 那么只有当这个事务把锁释放了, 其他事物才能够执行和该锁冲突的操作.</p><p>悲观锁主要用于数据竞争比较激烈的环境 还有 并发冲突时维护锁的成本低于回滚成本的环境中.</p><p><strong>使用:</strong>如果要对数据修改,先给这个数据添加排他锁,如果添加失败,那么说明正在被使用, 因此要等待或者抛异常.</p><p>优点: 保证了数据的安全和完整性</p><p>缺点: 效率低,会让数据库产生额外开销,还有可能出现死锁, 在只读的事务中不会产生冲突, 这样做会增加系统开销, 降低了并行.</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁是一种乐观的并发控制线程访问的一个方法.</p><p>它假设在并发处理事务时,都不会相互影响, 各事务能够在不产生锁的情况下处理各自影响的那部分数据.</p><p>就是只在提交的时候进行判断是否冲突</p><p>提交数据时判断有没有其他事务修改数据, 如果数据被修改了,那么就回滚.</p><p>乐观锁不会使用数据库提供的锁机制, 一般的实现乐观锁的方式就是记录数据版本, 即添加一行字段 version , 如果提交时发现字段一致, 就更新数据 , 否则就回滚.</p><p>实现乐观锁两种方式: 版本号 和 时间戳</p><p>乐观锁原理就是 CAS 操作</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>innodb 支持行锁 和 表锁 默认是支持行锁</p><p>innodb行锁是个索引加锁实现的, 意思就是只有通过索引条件检索数据, InnoDB才使用行级锁, 否则 InnoDB使用表锁 , 实际中我们要注意这种情况, 不然会产生大量冲突.</p><p>当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。</p><p>即便 在 数据库设置了索引, 但是是否用索引 还是根据mysql 通过判断不同 执行计划代价来决定的, 如果 mysql 认为全表扫描效率高, 例如一些很小的表, 他就不会使用索引, 这种情况下 就会使用 表锁.</p><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>在mysql中, 行锁不是直接锁记录, 而是锁的时索引.</p><p>索引分为主键索引和非主键索引, 如果mysql操作了主键索引, 那么就锁主键索引, 如果走的索引是 非主键索引, 那么先锁非主键索引, 再锁相关的主键索引.</p><p><strong>死锁:</strong>一个事务锁了主键索引, 另一个事务锁了非主键索引, 在等主键索引, 就造成了死锁.</p><p>死锁后 InnoDB都可以检查到, 并使一个事务释放锁并回退, 另一个获取锁完成事务.</p><p>*<em>避免死锁: *</em></p><ul><li>尽量有序访问表</li><li>尽量一次锁定所需要的所有资源</li><li>也可以升级锁粒度</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>百度一面面经</title>
    <link href="http://wysblogs.top/2020/07/24/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>http://wysblogs.top/2020/07/24/百度一面面经/</id>
    <published>2020-07-24T07:26:05.000Z</published>
    <updated>2020-07-24T14:13:52.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="百度一面面经"><a href="#百度一面面经" class="headerlink" title="百度一面面经"></a>百度一面面经</h1><p><strong>1、介绍自己。</strong></p><p><strong>2、说说面向对象的几个特点</strong></p><p><strong>3、然后出了几个 <code>==</code>条件 让我进行判断（Integer缓冲池）</strong></p><p><strong>4、然后一个剑指Offer原题。</strong></p><p>一开始没有暴力，后来用hashmap进行优化时间</p><p><strong>5、int的最大值，为什么？</strong></p><p><strong>6、ArrayList和LinkedArrayList区别</strong></p><p><strong>6、mysql索引（B+树原理）</strong></p><p><strong>7、innodb的原理（回表操作）</strong></p><p><strong>8、给了几个索引查询语句，判断可以不可以走索引进行查询</strong></p><p><strong>9、最后让编写一个各科平均分数的sql语句（没写出来，太菜了）</strong></p><p><strong>10、需要问什么问题？</strong></p><p>我问的是，我有些地方答得不是很好，希望你能给我讲讲我现在需要提升的地方。</p><p><strong>基础知识都是靠记得，理解上面有些不好，sql语句也不是很好，需要多去理解理解，知识不能靠死记硬背，把sql语句也练一练</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="面经" scheme="http://wysblogs.top/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://wysblogs.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat原理</title>
    <link href="http://wysblogs.top/2020/07/24/Tomcat%E5%8E%9F%E7%90%86/"/>
    <id>http://wysblogs.top/2020/07/24/Tomcat原理/</id>
    <published>2020-07-24T00:51:33.000Z</published>
    <updated>2020-07-27T02:14:04.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Tomcat原理"><a href="#Tomcat原理" class="headerlink" title="Tomcat原理"></a>Tomcat原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Tomcat是一个JSP/Servlet容器，其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器、进程外的Servlet容器。</p><p>Tomcat也是一个中间件，运行在JVM上，是一个在JAVA项目和JVM之间的中间容器。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/upload/tomcat/20180518194004378.png" alt="img"></p><p>核心容器和<code>Connector</code>和<code>Container</code></p><ul><li>Connector：处理连接相关内容，并提供Socket的Request和Response相关的转换。</li><li>Container：核心容器，封装和管理Servlet，处理Request请求。</li></ul><h2 id="三种Connector运行模式"><a href="#三种Connector运行模式" class="headerlink" title="三种Connector运行模式"></a>三种Connector运行模式</h2><ul><li><strong>BIO</strong>：同步阻塞IO，一个线程处理一个请求，同时把其他线程阻塞，并发量高时，线程多，导致性能严重下降</li><li><strong>NIO</strong>：异步非阻塞IO，一个线程处理多个Connection，多路复用，使用较少的线程执行较多的请求。</li><li><strong>APR</strong>：异步非阻塞IO，和NIO在操作系统层面不同，不需要关注进度问题。</li></ul><h2 id="Tomcat工作模式"><a href="#Tomcat工作模式" class="headerlink" title="Tomcat工作模式"></a>Tomcat工作模式</h2><p>Tomcat作为servlet容器，有三种工作模式：</p><ul><li>1、<strong>独立的servlet容器</strong>，servlet容器是web服务器的一部分；</li><li>2、<strong>进程内的servlet容器</strong>，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足；</li><li>3、<strong>进程外的servlet容器</strong>，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优；</li></ul><p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p><ul><li>Tomcat作为<strong>应用程序服务器</strong>：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</li><li>Tomcat作为<strong>独立服务器</strong>：请求来自于web浏览器；</li></ul><h2 id="Tomcat违背双亲委派模型"><a href="#Tomcat违背双亲委派模型" class="headerlink" title="Tomcat违背双亲委派模型"></a>Tomcat违背双亲委派模型</h2><p>首先谈一下Tomcat要实现的目的：</p><ul><li>运行多个web程序，并且各个依赖的类库相互独立，相互隔离。</li><li>部署在同一个web容器下的相同类库可以共享。</li><li>web容器自己类库不能与程序冲突。</li><li>需要更改jsp后不用重启。</li></ul><p><strong>Tomcat类加载器</strong></p><p><img src="/upload/tomcat/4236553-89bacc3467d513f0.webp" alt="img"></p><p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。</p><p>tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器</p><p>、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="tomcat" scheme="http://wysblogs.top/categories/tomcat/"/>
    
    
      <category term="tomcat" scheme="http://wysblogs.top/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>UnSafe类详解</title>
    <link href="http://wysblogs.top/2020/07/23/UnSafe%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/23/UnSafe类详解/</id>
    <published>2020-07-23T06:55:17.000Z</published>
    <updated>2020-07-26T09:22:17.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UnSafe类详解"><a href="#UnSafe类详解" class="headerlink" title="UnSafe类详解"></a>UnSafe类详解</h1><p>Unsafe是位于sun.misc包下的一个类</p><p>主要是提供一些用于执行级别低，不安全操作的方法，如直接访问系统的一些资源，这些方法对提高java运行效率，增强java语言底层资源操作能力方面起到了很大的作用。</p><p>但是因为底层是直接操作内存来实现功能的，所以可能会发生内存上的一些问题，比如内存泄漏，如果不正当使用的话，可能使java变得不再那么安全。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://picb.zhimg.com/80/v2-f0570d67d15e6157e2723687b77aee15_720w.jpg" alt="img"></p><p>如上图可看出，Unsafe类在多个方面都有使用：</p><ul><li>内存操作<ul><li>主要是<strong>堆外内存</strong>的分配、拷贝、释放、给定地址值等操作。</li><li>因为是堆外内存，所以不归JVM管，得自己进行内存的管理</li><li>使用堆外内存的原因：对GC停顿进行改善，减少停顿带来的影响，提高IO操作性能，不需要再次进行拷贝。</li></ul></li><li>CAS操作<ul><li>比较并交换，轻量级无锁并发，执行CAS操作时，首先拿地址中的值和原值作比较，如果一样就把内存值更新为新值，否则就不做任何操作。</li><li>CAS在很多方面都有应用，比如Atomic原子类，还有AQS，ConcurrentHashMap等地方都有体现。</li></ul></li><li>Class相关的一些操作<ul><li>此部分主要提供<strong>Class</strong>和它的<strong>静态字段</strong>的操作相关方法，包含<strong>静态字段内存定位</strong>、<strong>定义类</strong>、<strong>定义匿名类</strong>、<strong>检验&amp;确保初始化</strong>等</li></ul></li><li>对象操作<ul><li>此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。</li><li>常规分配内存是使用<code>new</code>关键字，然后交给JVM来管理</li><li>但是Unsafe有分配内存的方法，不需要通过JVM进行操作，</li></ul></li><li>线程调度<ul><li>线程挂起，恢复，锁机制等操作。</li></ul></li><li>系统信息获取<ul><li>这部分包含两个获取系统相关信息的方法。</li></ul></li><li>内存屏障<ul><li>在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。</li></ul></li><li>数组操作<ul><li>这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://wysblogs.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://wysblogs.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>面对对象三大特点</title>
    <link href="http://wysblogs.top/2020/07/23/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9/"/>
    <id>http://wysblogs.top/2020/07/23/面对对象三大特点/</id>
    <published>2020-07-23T04:19:47.000Z</published>
    <updated>2020-07-25T13:07:55.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面向对象三大特点"><a href="#面向对象三大特点" class="headerlink" title="面向对象三大特点"></a>面向对象三大特点</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>就是把自己的类给封装起来，只暴露出想让外界访问的接口和数据，保证了类的安全性。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>OOP的一个主要功能，通过继承来实现代码的复用。                                                                                                                                                                                                                                                        </p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>同一个操作，作用于不同的对象，会产生不同的结果。</p><p>多态的好处是可以解耦合，灵活，面向接口编程，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引底层原理</title>
    <link href="http://wysblogs.top/2020/07/22/mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://wysblogs.top/2020/07/22/mysql索引底层原理/</id>
    <published>2020-07-22T11:12:51.000Z</published>
    <updated>2020-07-23T04:09:11.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql索引底层原理"><a href="#mysql索引底层原理" class="headerlink" title="mysql索引底层原理"></a>mysql索引底层原理</h1><p>我们都知道索引可以提高查询效率，那么为什么会提高查询效率呢？</p><p>我们可以从底层进行分析，因为mysql索引的底层是基于数据结构的。</p><p>假入我们没有索引，那么如果有5个数据，mysql在查询的时候就会比较5次，如果有1000w数据，那么就要比较100w次，很显然，这样的速度，我们肯定不能接受，所以就必须使用索引来进行优化查询速度。</p><p>mysql底层有以下几种数据结构：</p><ul><li><strong>Hash表</strong></li><li><strong>二叉搜索树</strong></li><li><strong>AVL和红黑树</strong></li><li><strong>B树</strong></li><li><strong>B+树</strong></li></ul><p>mysql引擎也有两种常用的：</p><ul><li><strong>InnoDB</strong></li><li><strong>MyiSam</strong></li></ul><h2 id="Mysql底层数据结构"><a href="#Mysql底层数据结构" class="headerlink" title="Mysql底层数据结构"></a>Mysql底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p><img src="https://pic1.zhimg.com/80/v2-7805f7b4bab4c98adc045e3667046398_1440w.jpg" alt="img"></p><p><strong>哈希表</strong>也叫散列表，是根据key和value直接进行访问的数据结构，是快速检索的好方法。</p><p><strong>哈希算法：</strong>也叫散列算法，就是把任意的key值通过哈希函数变换成固定长度的key地址，然后通过这个地址存放数据的算法。</p><p><strong>哈希碰撞：</strong>比如hash(7)和hash(199)值一样，如果只存放一个数据的话，会冲突，解决这种情况最常用的方法是<strong>链地址法</strong>，把碰撞的数据通过链表连接起来，但是计算完hash值之后还需要判断有没有产生hash碰撞，还得重新遍历一边链表，直到找到真正的key对应的数值。</p><p>hash算法的时间复杂度是O(1)，但是考虑到数据检索有一个范围性，hash算法对查询一个数据很高效，但是没办法做到高效查询范围，因此哈希索引不适合做Mysql底层索引。</p><p><img src="https://pic4.zhimg.com/80/v2-4deae667d7d5c9a1a166cb0e8bac9dd6_1440w.jpg" alt="img"></p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p><img src="https://pic2.zhimg.com/80/v2-032790aff0ddf52b676413573acce776_1440w.jpg" alt="img"></p><p>二叉搜索树也是一支持数据快速检索的数据结构。</p><p>二叉搜索树左子树所有值小于根节点的值，右节点所有值大于根节点的值。</p><p>二叉搜索树的时间复杂度是O(logn)，二叉搜索树还能解决高效范围性查找数据。</p><p>普通的二叉搜索树有个致命缺点，在极端情况下会退化成线性链表，二分查找会变成线性查找，性能严重下降。</p><p><img src="https://pic2.zhimg.com/80/v2-1cc416d59d4c44cf029e9e2103347bb8_1440w.jpg" alt="img"></p><p>例如主键索引，因为一般情况下主键索引都是自增的，采用二叉搜索树作为底层索引的话会导致查询性能严重下降。</p><h3 id="AVL树和红黑树"><a href="#AVL树和红黑树" class="headerlink" title="AVL树和红黑树"></a>AVL树和红黑树</h3><p>由于二叉搜索树极端不平衡的情况，就提出了让树节点自动旋转和调整，以便于随时处于平衡的状态，也就能保证二叉搜索树的查询性能。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>假入二叉搜索树处于一个严重不平衡的状态，那么红黑树就会自动调整节点，通过自动左旋右旋以及节点变色来调整树的形态，使其保持基本的平衡状态（时间复杂度O(logn)）。</p><p>红黑树保证了二叉搜索树不会处于一种极端情况（O(n)），但是又会引出一种新的问题，假入当我们顺序插入1~16个节点后，树形态会产生右倾，但是并没有像二叉搜索树那样的线性夸张，不过如果数据有几百万条的话，查询效率也会变得特别慢，对性能影响也是巨大的。</p><p><img src="https://pic3.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_1440w.jpg" alt="img"></p><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>由于红黑树会产生右倾趋势，所以又引出了一种更为严格的二叉平衡树（AVL树），这个树是一个绝对平衡的二叉树，因此在调整形态上会花费更多的性能。</p><p>比如我们插入1~16个节点，最后AVL树的结构会如下：</p><p><img src="https://pic3.zhimg.com/80/v2-0dad51645707e973b152e44e4b7479c5_1440w.jpg" alt="img"></p><p>从树的形态我们可以看出来，AVL树不会产生右倾的状态，我们查询16号节点，AVL树会比较四次，而红黑树会比较6次，这样就从根本上解决了红黑树的问题。</p><p>所以AVL树的优点有以下几点：</p><ul><li>查找性能好（O(logn)），不会产生极端情况，严重降低性能</li><li>可以实现范围查找和数据排序</li></ul><p>但是AVL树并不适合作为Mysql的底层索引的数据结构，主要是因为数据库查询的瓶颈在于磁盘IO，如果使用AVL树，每个节点只存放一个数据，我们一次磁盘IO只能把一个数据加载到内存中，比如查找节点7，就要进行三次IO，这样会特别耗时间，所以如果要设计数据库索引就要考虑很多情况，首先肯定是每个节点都存放多个数据，而且一次IO就可以加载多个数据到内存中，这就引出了B+树的设计原理。</p><p>磁盘IO有个特点，就是磁盘读取1K的数据和读取1B的数据所消耗的时间是一样的。</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>每个节点可以限制存放的key值数量，如果超过了这个约定的key值数量就自动分裂，比如我们继续插入1~16个节点，如果限制一个节点存放2个key的数量的话，结构如下</p><p><img src="https://pic3.zhimg.com/80/v2-f335bdb3e922a5f334416f557df20848_1440w.jpg" alt="img"></p><p>我们不难看出查询节点16的性能和AVL树一样了，也是经过四次磁盘IO，我们可以考虑每次IO可以读取更多的数据到内存中，可以增加限制的key的数量为6个</p><p><img src="https://pic3.zhimg.com/80/v2-7d5e34c698b1e4192ad0ff93c2c897d0_1440w.jpg" alt="img"></p><p>这样对于磁盘IO的次数就可以降低一半，只需要两次就可以读取到。</p><p><strong>B树的优点：</strong></p><ul><li>优秀的检索速度，差查找性能等于O(h*logn)，h是树高，n为每个节点关键词的个数。</li><li>尽可能地减少了磁盘IO的次数，提高了性能。</li><li>可以支持范围查找。</li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>首先看一下B树和B+树的区别：</p><ul><li><p>B树一个节点里存放的是数据，而B+树存放的是索引（地址），所以B树里一个节点    存不了很多数据，但是B+树可以存放很多数索引，B+树叶子节点存放所有数据。</p></li><li><p>B+树叶子节点使用链表串联了起来，便于范围查找。</p><p>对比可以看出，B+树存放的是索引，在单个节点容量有限的情况下，单节点也可以存放大量索引，使得整体树的高度降低，减少了磁盘IO，其次叶子节点是存放真正数据的地方，叶子节点用链表连起来，而且还是有序的，在范围查找中更占有优势。所以mysql索引用的就是B+树，在查找效率和范围查找都有不错的性能。</p></li></ul><p>例如插入1~16个节点：</p><p><img src="https://pic3.zhimg.com/80/v2-bda6661499c51dcff63eb12fd4b3795d_1440w.png" alt="img"></p><h2 id="Mysql引擎"><a href="#Mysql引擎" class="headerlink" title="Mysql引擎"></a>Mysql引擎</h2><p>mysql底层数据引擎以插件的形式设计，最常见的就是<strong>InnoDB</strong>和<strong>Myisam</strong>引擎，用户可以根据个人需求来选择不同的引擎作为mysql底层引擎。</p><p>首先来分析一下两者的区别：</p><ul><li>MyISAM查找性能好，但是不支持事务处理，InnoDB最大特色就是支持ACID兼容的事务功能，而且还支持行级锁</li><li>InnoDB创建表后生成的文件有：<ul><li>frm:创建表的语句</li><li>idb:表里面的数据+索引文件</li></ul></li><li>MyISAM创表后生成的文件有：<ul><li>frm:创建表的语句</li><li>MYD:表里面的数据文件（myisam data）</li><li>MYI:表里面的索引文件（myisam index）</li></ul></li></ul><p>InnoDB把数据和索引放在一起，称为聚集索引，而MyISAM把数据和索引分开，称为非聚集索引。</p><h3 id="MyISAM底层实现"><a href="#MyISAM底层实现" class="headerlink" title="MyISAM底层实现"></a>MyISAM底层实现</h3><p>MyISAM采用非聚集索引，建表时以主键作为key来建立B+树，树的叶子节点存放的是对应数据的物理地址，我们拿到这个物理地址后，就可以到MyISAM数据文件中直接定位到具体的数据记录。</p><p><img src="https://pic1.zhimg.com/80/v2-d9a03627e8e1319e46f42e6963c35e30_1440w.jpg" alt="img"></p><p>当我们为某个字段添加索引时，也会生出该字段的索引树，该字段的索引树的叶子节点同样记录了数据文件中的物理地址，根据这个地址同样可以定位到具体的数据记录。</p><h3 id="InnoDB底层实现"><a href="#InnoDB底层实现" class="headerlink" title="InnoDB底层实现"></a>InnoDB底层实现</h3><p>InnoDB是聚集索引，数据和索引都在一个文件中，建表时，InnoDB会根据主键ID作为key建立索引B+树，B+树叶子节点存放的是主键ID对应的数据。</p><p>我们为某个字段添加索引时，会根据这个字段去建立索引树，索引树节点中存放的是字段的值，根节点存放的是主键的值，拿到主键的key值之后会到主键索引创建的B+树查找对应的数据。</p><p><img src="https://pic2.zhimg.com/80/v2-6e16b355e3d0f05ed8bfb0f7c71de8f1_1440w.jpg" alt="img"></p><p>InnoDB只在主键索引的叶节点存放具体的数据原因是需要节省空间，一个表可能有多个索引，如果每个都创建一个索引树存放具体数据，就会导致数据文件变得十分巨大，数据冗杂，因此采用上面那种方式就可以牺牲较少的查询性能节省巨大的磁盘空间，还是蛮好的。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>由上面可以得知，MyISAM查询性能更好，因为MyISAM查询一次就能获取到数据，查询到物理地址就直接去数据文件中寻找。</p><p>而InnoDB两次才行，第一次查询到叶子节点的主键索引，第二次根据主键索引去主键索引创建的B+树中去寻找。</p><h2 id="什么时候需要创建索引呢？"><a href="#什么时候需要创建索引呢？" class="headerlink" title="什么时候需要创建索引呢？"></a>什么时候需要创建索引呢？</h2><ul><li>查询频繁的字段</li><li>唯一性太差的字段不适合创建索引，即使这个字段频繁作为查询条件。</li><li>更新频繁的字段不适合创建索引，因为每次都需要维护B+树，导致性能差。</li></ul><h2 id="最终选择B-树的原因？"><a href="#最终选择B-树的原因？" class="headerlink" title="最终选择B+树的原因？"></a>最终选择B+树的原因？</h2><ul><li>hash特别快，但是只能针对一个值</li><li>AVL和红黑树，在大数据的情况下，磁盘IO操作过多</li><li>B树每个节点存放的是数据，节点存放的分支太少了。</li><li>B+树节点存储的索引是索引和指针（引用指向下一个地址），可以存储大量索引，同时最终数据在叶子节点上，并且有引用横向链接，可以在2~3次的IO操作中完成千万级别表的操作。</li><li>建议索引为主键索引，有自增操作，适合范围查找。</li></ul><blockquote><p>文章参考自：<a href="https://zhuanlan.zhihu.com/p/113917726" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113917726</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>native关键字</title>
    <link href="http://wysblogs.top/2020/07/22/native%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://wysblogs.top/2020/07/22/native关键字/</id>
    <published>2020-07-22T08:49:56.000Z</published>
    <updated>2020-07-25T10:08:40.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Native关键字"><a href="#Native关键字" class="headerlink" title="Native关键字"></a>Native关键字</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>java调用本地API方法的关键字，不需要让java实现，让C++去实现。</p><p>JNI是Java Native Interface的 缩写，JNI允许java和其他语言进行交互，但是这样会丧失平台可移植性。</p><p>JNI标准至少保证本地代码能工作在任何java虚拟机下。</p><p><code>public static native void a(int a);</code></p><p>native关键字修饰的方法不需要实现，交给C或C++语言实现即可</p><p>如果想要调用native方法，自己可以实现一个，然后编译到动态库中，在java中加载动态库即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础知识" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java基础知识" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>final关键字详解</title>
    <link href="http://wysblogs.top/2020/07/22/final%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
    <id>http://wysblogs.top/2020/07/22/final关键字详解/</id>
    <published>2020-07-22T08:40:22.000Z</published>
    <updated>2020-07-25T14:16:45.677Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h1><p><strong>final关键字可以修饰的地方：</strong></p><ul><li><strong>类：</strong>类不能被继承</li><li><strong>方法：</strong>不能被重写</li><li><strong>变量：</strong>不能被改变</li><li><strong>修饰引用类型：</strong>引用类型的内存地址不可变，指向的值可以变。</li></ul><p>final 修饰的变量 会直接放在变量池中，如果一个类调用final修饰的变量是不会加载类的</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(demo.s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s = <span class="string">"1"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>直接输出1，不会加载静态代码块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Object类的方法</title>
    <link href="http://wysblogs.top/2020/07/22/Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://wysblogs.top/2020/07/22/Object类的方法/</id>
    <published>2020-07-22T08:37:05.000Z</published>
    <updated>2020-07-25T17:37:35.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h1><p>Object是所有类的父类，任何类都默认继承Object。Object类到底实现了哪些方法？</p><p>（1）clone方法</p><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p><p>（2）getClass方法</p><p>final方法，获得运行时类型。</p><p>（3）toString方法</p><p>该方法用得比较多，一般子类都有覆盖。</p><p>（4）finalize方法</p><p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p><p>（5）equals方法</p><p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p><p>（6）hashCode方法</p><p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p><p>一般必须满足obj1.equals(obj2)true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><p>（7）wait方法</p><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p><p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><p>（1）其他线程调用了该对象的notify方法。</p><p>（2）其他线程调用了该对象的notifyAll方法。</p><p>（3）其他线程调用了interrupt中断该线程。</p><p>（4）时间间隔到了。</p><p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p><p>（8）notify方法</p><p>该方法唤醒在该对象上等待的某个线程。</p><p>（9）notifyAll方法</p><p>该方法唤醒在该对象上等待的所有线程。</p><blockquote><p>引用来自：<a href="https://www.php.cn/faq/416709.html" target="_blank" rel="noopener">https://www.php.cn/faq/416709.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String和StringBuffer,StringBuilder区别</title>
    <link href="http://wysblogs.top/2020/07/22/String%E5%92%8CStringBuffer-StringBuilder%E5%8C%BA%E5%88%AB/"/>
    <id>http://wysblogs.top/2020/07/22/String和StringBuffer-StringBuilder区别/</id>
    <published>2020-07-22T08:36:22.000Z</published>
    <updated>2020-07-25T17:29:44.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="String和StringBuffer-StringBuilder区别"><a href="#String和StringBuffer-StringBuilder区别" class="headerlink" title="String和StringBuffer,StringBuilder区别"></a>String和StringBuffer,StringBuilder区别</h1><ul><li><p>String类是不可变的，而StringBuffer和StringBuilder是可变的</p></li><li><p>String一旦修改，就会重新开辟一块内存来存储修改的对象。</p></li><li><p>如果频繁修改字符串，肯定不能用String，会导致内存空间浪费。</p></li><li><p>频繁修改字符串就应该使用StringBuffer，底层也是和String一样都是数组，但是StringBuffer会建立一个缓冲区，所以速度会大于String</p></li><li><p>StringBuffer方法都加了锁，所以效率可能比StringBuilder更低，但是安全性来说，StringBuffer更好。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://wysblogs.top/2020/07/22/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://wysblogs.top/2020/07/22/Java反射机制/</id>
    <published>2020-07-22T08:33:46.000Z</published>
    <updated>2020-07-26T03:45:05.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>java反射机制是指在程序运行状态中，可以动态获取一个类的所有信息，这种功能被称为反射，反射是动态语言的关键。</p><p>java动态代理是基于反射实现的。</p><p>反射是面向抽象编程的一种实现方式，使代码更加灵活，极大提高了代码的运行时装配能力。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><ul><li>反射提高了程序灵活性和扩展性，降低了模块的耦合性，提高了自身适应能力。</li><li>反射可以在运行时构造一个类对象，动态的调用类中的方法。</li><li>反射是构建框架的基础，可以避免把代码写死在框架中。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>性能，因为JVM不能对反射代码进行优化，所以效率比较低，所以应该避免在性能要求搞得项目中去使用反射。</li><li>安全性，如果程序安全性要求较高，就不能使用反射，不然会破坏封装的特性，使得程序可能会被改动。</li><li>健壮性，反射允许代码进行一些不被允许的操作，所以反射可能导致破坏java程序的抽象性，导致平台变化抽象逻辑结构不能被识别，代码允许效果产生差异。</li></ul><h2 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h2><p>我们都知道一个final修饰的成员变量不能被修改，但是反射可以破坏这个规矩，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main t = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = t.getClass().getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Field modifiers = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line">            modifiers.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            modifiers.setInt(field,modifiers.getModifiers()&amp;~Modifier.FINAL);</span><br><span class="line">            field.set(t,<span class="number">5</span>);</span><br><span class="line">            System.out.println(field.get(t));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果final 修饰的是基本数据类型，那么在编译器就会被优化，导致修改之后输出的还是编译器优化好的常量值</p><p>所以如果换成引用数据类型，我们就可以看出来值已经被修改成了5，这个就是破坏了类的内部数据，所以如果<strong>安全性</strong>要求较高，就不建议使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="反射" scheme="http://wysblogs.top/categories/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="反射" scheme="http://wysblogs.top/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal原理</title>
    <link href="http://wysblogs.top/2020/07/22/ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>http://wysblogs.top/2020/07/22/ThreadLocal原理/</id>
    <published>2020-07-22T08:33:12.000Z</published>
    <updated>2020-07-27T00:10:58.349Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThreadLocal是一个本地线程副本变量工具类，各个线程都有自己的一份线程私有数据，线程之间的变量互不干扰，高并发情况下保证线程安全。</p><p>传统的线程安全是使用CAS或者synchronized锁实现的。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1595767761448&di=fd50c80e2b1e291a98279f9e4f16c3ed&imgtype=0&src=http%3A%2F%2Fwww.swifthumb.com%2Fdata%2Fattachment%2Fforum%2F202007%2F05%2F191742w8nz8odxxbkbxx09.jpg" alt="img"></p><ul><li>每个Thread里面都有一个Map对象</li><li>Map里面存放的是线程本地对象和线程的变量副本</li><li>ThreadMap内部的Map是由ThreadLocal维护的，由ThreadLocal获取和设置变量值。</li><li>各个线程之间是相互隔离的，一个线程不会获取到另一个线程的值</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>Session管理</li><li>数据库连接</li></ul><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>ThreadLocal的原理是内部的一个ThreadLocalMap类</p><p>Map的Entry继承了weakReference</p><p>java的弱引用在内存不足时会被回收，变成(null,value)形式，如果线程执行完的话，value也会被回收，如果是在线程池中，那么线程中有个强引用会指向ThreadLocalMap，导致value不会被回收，一直在内存中，如果线程数量太多的话，导致内存可能会发生泄漏</p><p><strong>避免方法：</strong>如果不用的话要使用remove()方法移除value值，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://wysblogs.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://wysblogs.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Rest和RPC</title>
    <link href="http://wysblogs.top/2020/07/22/Rest%E5%92%8CRPC/"/>
    <id>http://wysblogs.top/2020/07/22/Rest和RPC/</id>
    <published>2020-07-22T08:31:16.000Z</published>
    <updated>2020-07-27T01:27:14.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Rest和RPC"><a href="#Rest和RPC" class="headerlink" title="Rest和RPC"></a>Rest和RPC</h1><p><img src="https://pic4.zhimg.com/80/v2-94f2d3a1a96ce10d0b40fa7d17a78d00_720w.jpg" alt="img"></p><p>两种风格的API区别：</p><ul><li><strong>RPC面向过程：</strong>RPC只发送GET或者POST请求，RPC不单单指的是API的开发风格，RPC称为远程过程调用，发送一个RPC请求，实际上就是调用了服务端的一个方法。</li><li><strong>Restful面向资源：</strong>使用 POST、DELETE、PUT、GET 请求，分别对应增、删、改、查操作。请求参数是<strong>名词</strong>，这个名词就是“增删改查”想要操作的对象。</li></ul><h2 id="RPC和Dubbo"><a href="#RPC和Dubbo" class="headerlink" title="RPC和Dubbo"></a>RPC和Dubbo</h2><p>Dubbo是一个实现了RPC理念的框架，使得调用远程服务就跟调用本地方法一样，使得Dubbo更加的安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="分布式" scheme="http://wysblogs.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://wysblogs.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>重写equals为什么要重写hashcode</title>
    <link href="http://wysblogs.top/2020/07/22/%E9%87%8D%E5%86%99equals%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode/"/>
    <id>http://wysblogs.top/2020/07/22/重写equals为什么要重写hashcode/</id>
    <published>2020-07-22T08:29:11.000Z</published>
    <updated>2020-07-25T17:02:05.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重写equals为什么要重写hashcode"><a href="#重写equals为什么要重写hashcode" class="headerlink" title="重写equals为什么要重写hashcode"></a>重写equals为什么要重写hashcode</h1><h2 id="hashcode规范"><a href="#hashcode规范" class="headerlink" title="hashcode规范"></a>hashcode规范</h2><ol><li>当在一个应用程序执行过程中， 如果在 equals 方法比较中没有修改任何信息， 在一个对象上重复调用 hashCode 方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值 可以是不一致的。</li><li>如果两个对象根据 equals(Object) 方法比较是相等的，那么在两个对象上调用 hashCode 就必须产生的 结果是相同的整数。</li><li>如果两个对象根据 equals(Object) 方法比较并不相等，则不要求在每个对象上调用 hashCode 都必须产生不同的结果。但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables） 的性能。</li></ol><h2 id="为什么重写hashcode"><a href="#为什么重写hashcode" class="headerlink" title="为什么重写hashcode"></a>为什么重写hashcode</h2><p>因为要遵守equals的规范（第二条），如果重写了equals的话，如果equals比较相同，那么hashcode也要相同，</p><p>如果在hashmap中没有重写hashcode的话，会出现问题，因为在hashmap中，hashcode是用来作为对象访问定位的，如果重写了String的equals方法的话，put添加值的话，会将完全相同的两个key值存到不同位置。导致出现问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>接口和抽象类</title>
    <link href="http://wysblogs.top/2020/07/22/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://wysblogs.top/2020/07/22/接口和抽象类/</id>
    <published>2020-07-22T08:28:27.000Z</published>
    <updated>2020-07-25T12:00:53.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><ul><li>接口只能被实现，抽象类只能被继承</li><li>接口中的成员变量都是用<code>public static final</code>修饰的，默认都是可省略的</li><li>接口的方法都是<code>public abstract</code>修饰的，默认也都是可省略的</li><li>接口支持多实现，一个子类可以实现多个接口，但是抽象类只能被单继承，一个子类只能继承一个父类</li><li>在1.8之前，接口中不能有方法体，但是在1.8新添加了<code>default method</code>，可以实现方法体</li><li>在抽象类中，抽象方法不能有方法体，可以有普通方法，实现方法体</li><li>接口和抽象类都不能被实例化</li><li>final不能修饰接口和抽象类，因为不能被继承，所以就没有意义</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>重载和重写</title>
    <link href="http://wysblogs.top/2020/07/22/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99/"/>
    <id>http://wysblogs.top/2020/07/22/重载和重写/</id>
    <published>2020-07-22T08:28:14.000Z</published>
    <updated>2020-07-25T12:37:09.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ul><li>重载是在同一个类中或者子类中实现。</li><li>被重载的方法必须改变参数列表或者参数类型</li><li>被重载的方法可以改变返回类型</li><li>被重载的方法可以改变访问修饰符，但是修饰符权限只能比被重载的方法大</li><li>无法以返回值类型作为重载的依据</li></ul><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><ul><li>父类的方法只能被子类重写</li><li>参数列表和参数类型都必须和被重写的方法一样</li><li>访问权限不能比被重写的方法低</li><li>声明final的方法不能被重写</li><li>声明static的方法不能被重写，但能够被再次声明</li><li>构造方法不能被重写</li><li>如果没有继承这个方法也不能被重写</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>equals 和 ==</title>
    <link href="http://wysblogs.top/2020/07/22/equals-%E5%92%8C/"/>
    <id>http://wysblogs.top/2020/07/22/equals-和/</id>
    <published>2020-07-22T08:27:23.000Z</published>
    <updated>2020-07-25T17:35:25.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="equals-和"><a href="#equals-和" class="headerlink" title="equals 和 =="></a>equals 和 ==</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>这个是Object类中的方法，如果没有重写的话，默认就是比较的是内存地址是否相同</p><p><strong>String类</strong>重写了equals方法，比较的是两个字符串是否相同。</p><h2 id><a href="#" class="headerlink" title="=="></a>==</h2><p>这个一般比较的是基本数据类型，判断值是否相同。</p><p>但是在引用类型中，比较的是内存地址是否相同。</p><p><strong>具体可以通过敲代码来理解记忆。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java基础" scheme="http://wysblogs.top/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="http://wysblogs.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie区别</title>
    <link href="http://wysblogs.top/2020/07/22/Session%E5%92%8CCookie%E5%8C%BA%E5%88%AB/"/>
    <id>http://wysblogs.top/2020/07/22/Session和Cookie区别/</id>
    <published>2020-07-22T08:24:53.000Z</published>
    <updated>2020-07-24T01:38:18.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Session和Cookie区别"><a href="#Session和Cookie区别" class="headerlink" title="Session和Cookie区别"></a>Session和Cookie区别</h1><h2 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h2><p>Session代表服务器和客户端一次会话的过程。</p><p>Session对象存储特定用户会话所需的属性及配置信息。</p><p>用户在应用程序的WEB页跳转时，存储在Session对象的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。</p><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><p>cookie是服务器发送到用户浏览器并保存在本地的一小块数据，他会在浏览器下向同一服务器再发起请求时带上并再次发送到服务器。</p><p>它会告知服务端两个请求是否来自同一浏览器，如保持用户的登陆状态。</p><p>Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。</p><p><strong>Cookie主要用于以下三个方面</strong></p><ul><li>会话管理（如用户登陆状态，购物车等）</li><li>个性化设置（如用户自定义设置，主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><strong>作用范围不同：</strong>Cookie在客户端，Session在服务端。</li><li><strong>存取方式不同：</strong>Cookie只能保存ASCII，Session能保存各种类型，一般情况下我们可以保存一些变量信息。</li><li><strong>有效期不同：</strong>Cookie可设置为长时间保持，比如我们经常使用的登录功能，Session失效时间比较短，客户端关闭或者Session超时都会失效。</li><li><strong>隐私策略不同：</strong>Cookie在客户端，不安全，Session存储在服务端，安全性相对较高。</li><li><strong>存储大小不同：</strong>单个Cookie保存的数据不能超过4K，Session则远远高于Cookie。</li></ul><h2 id="为什么要用这些"><a href="#为什么要用这些" class="headerlink" title="为什么要用这些"></a>为什么要用这些</h2><p>因为HTTP请求是无协议，无状态的，当与服务端交互时，需要Cookie来告诉服务器谁在登录，还有Session配合执行操作。</p><p><img src="https://pic4.zhimg.com/80/v2-e651da81c8a95d8ddbdbc9e43cc8a082_1440w.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wysblogs.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://wysblogs.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令（持续更新）</title>
    <link href="http://wysblogs.top/2020/07/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://wysblogs.top/2020/07/22/linux常用命令（持续更新）/</id>
    <published>2020-07-22T08:23:06.000Z</published>
    <updated>2020-07-27T01:35:10.043Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="linux常用命令（持续更新）"><a href="#linux常用命令（持续更新）" class="headerlink" title="linux常用命令（持续更新）"></a>linux常用命令（持续更新）</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>查看系统资源占用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="linux" scheme="http://wysblogs.top/categories/linux/"/>
    
    
      <category term="linux" scheme="http://wysblogs.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务和隔离级别</title>
    <link href="http://wysblogs.top/2020/07/22/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://wysblogs.top/2020/07/22/mysql事务和隔离级别/</id>
    <published>2020-07-22T08:21:43.000Z</published>
    <updated>2020-07-25T01:48:47.350Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mysql事务和隔离级别"><a href="#mysql事务和隔离级别" class="headerlink" title="mysql事务和隔离级别"></a>mysql事务和隔离级别</h1><h2 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a>mysql事务</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>mysql的多条语句看成一个整体</p><p>事务就是保证这个整体能够同时成功，或者同时失败。</p><p>在mysql中不同的引擎对事务的支持也是不一样的</p><p>比如InnoDB支持事务， 而 MyISAM不支持事务。</p><p>所以以下说的都是mysql的事务都是以InnoDB作为引擎的</p><h3 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h3><ul><li><strong>原子性：</strong>要么全都成功，要么全都失败。不会在中间某一步停留，mysql执行事务时如果出错，那么就会回滚到没执行事务之前。</li><li><strong>一致性：</strong>事务完成前后，数据的完整性不能出错，比如转账，两个人钱的总和再转账前后不能改变，保证数据的一致性。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止并发交替导致数据的不一致。</li><li><strong>持久性：</strong>事务完成后，对数据的修改是永久的，即使系统故障也不会丢失。</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>事物的隔离级别是于事务的隔离性密不可分的，可以通过改变</p><p>事务的隔离级别认为以下几种：</p><ul><li><strong>读未提交</strong>： 任何事务修改数据之后都会暴露给其他事务</li><li><strong>读提交：</strong>只能读取其他事务已经提交过的数据</li><li><strong>可重复读：</strong>事务不会读到其他事务对已有数据的修改</li><li><strong>串行化：</strong>将事务的执行变成顺序型，相当于一个单线程，安全性最高，但是效率最低</li></ul><p>从上往下，隔离强度依次增加，性能逐渐变差，<strong>可重复读</strong>是mysql默认的隔离级别。</p><h3 id="事务隔离要解决的问题"><a href="#事务隔离要解决的问题" class="headerlink" title="事务隔离要解决的问题"></a>事务隔离要解决的问题</h3><ul><li><strong>脏读：</strong>读取到了其他事务未提交的数据，未提交意味着读到的是数据发生了回滚，也就是读到了不存在的数据，这就是脏读。</li><li><strong>幻读：</strong>这个是针对<strong>插入</strong>操作来说的，比如事务A更改记录时，事务B插入了一条新的记录与事务A要更改的记录一样，导致在事务A中查询发现更改的数据好像没有改变，这就是幻读。</li><li><strong>可重复读：</strong>在一个事务中，事务开始前后读取到的数据是一致的。</li><li><strong>不可重复读：</strong>不同时刻读取的数据是不一样的，比如其他事务提交并更改了数据。</li></ul><h3 id="事务隔离级别解决问题情况"><a href="#事务隔离级别解决问题情况" class="headerlink" title="事务隔离级别解决问题情况"></a>事务隔离级别解决问题情况</h3><p><img src="https://pic3.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_1440w.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p><p>读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://wysblogs.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wysblogs.top/tags/mysql/"/>
    
  </entry>
  
</feed>
