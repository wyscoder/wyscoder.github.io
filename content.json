{"meta":{"title":"wys'blogs","subtitle":null,"description":null,"author":"wys","url":"http://wysblogs.top","root":"/"},"pages":[{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2019-08-10T06:29:49.301Z","comments":true,"path":"categories/index.html","permalink":"http://wysblogs.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-10T06:27:48.000Z","updated":"2019-08-10T06:31:03.139Z","comments":true,"path":"about/index.html","permalink":"http://wysblogs.top/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-10T06:27:53.000Z","updated":"2019-08-10T06:31:51.533Z","comments":true,"path":"tags/index.html","permalink":"http://wysblogs.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面对对象三大特点","slug":"面对对象三大特点","date":"2020-07-23T04:19:47.000Z","updated":"2020-07-23T04:20:03.097Z","comments":true,"path":"2020/07/23/面对对象三大特点/","link":"","permalink":"http://wysblogs.top/2020/07/23/面对对象三大特点/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"mysql索引底层原理","slug":"mysql索引底层原理","date":"2020-07-22T11:12:51.000Z","updated":"2020-07-23T04:09:11.846Z","comments":true,"path":"2020/07/22/mysql索引底层原理/","link":"","permalink":"http://wysblogs.top/2020/07/22/mysql索引底层原理/","excerpt":"","text":"mysql索引底层原理我们都知道索引可以提高查询效率，那么为什么会提高查询效率呢？ 我们可以从底层进行分析，因为mysql索引的底层是基于数据结构的。 假入我们没有索引，那么如果有5个数据，mysql在查询的时候就会比较5次，如果有1000w数据，那么就要比较100w次，很显然，这样的速度，我们肯定不能接受，所以就必须使用索引来进行优化查询速度。 mysql底层有以下几种数据结构： Hash表 二叉搜索树 AVL和红黑树 B树 B+树 mysql引擎也有两种常用的： InnoDB MyiSam Mysql底层数据结构Hash表 哈希表也叫散列表，是根据key和value直接进行访问的数据结构，是快速检索的好方法。 哈希算法：也叫散列算法，就是把任意的key值通过哈希函数变换成固定长度的key地址，然后通过这个地址存放数据的算法。 哈希碰撞：比如hash(7)和hash(199)值一样，如果只存放一个数据的话，会冲突，解决这种情况最常用的方法是链地址法，把碰撞的数据通过链表连接起来，但是计算完hash值之后还需要判断有没有产生hash碰撞，还得重新遍历一边链表，直到找到真正的key对应的数值。 hash算法的时间复杂度是O(1)，但是考虑到数据检索有一个范围性，hash算法对查询一个数据很高效，但是没办法做到高效查询范围，因此哈希索引不适合做Mysql底层索引。 二叉搜索树 二叉搜索树也是一支持数据快速检索的数据结构。 二叉搜索树左子树所有值小于根节点的值，右节点所有值大于根节点的值。 二叉搜索树的时间复杂度是O(logn)，二叉搜索树还能解决高效范围性查找数据。 普通的二叉搜索树有个致命缺点，在极端情况下会退化成线性链表，二分查找会变成线性查找，性能严重下降。 例如主键索引，因为一般情况下主键索引都是自增的，采用二叉搜索树作为底层索引的话会导致查询性能严重下降。 AVL树和红黑树由于二叉搜索树极端不平衡的情况，就提出了让树节点自动旋转和调整，以便于随时处于平衡的状态，也就能保证二叉搜索树的查询性能。 红黑树假入二叉搜索树处于一个严重不平衡的状态，那么红黑树就会自动调整节点，通过自动左旋右旋以及节点变色来调整树的形态，使其保持基本的平衡状态（时间复杂度O(logn)）。 红黑树保证了二叉搜索树不会处于一种极端情况（O(n)），但是又会引出一种新的问题，假入当我们顺序插入1~16个节点后，树形态会产生右倾，但是并没有像二叉搜索树那样的线性夸张，不过如果数据有几百万条的话，查询效率也会变得特别慢，对性能影响也是巨大的。 AVL树由于红黑树会产生右倾趋势，所以又引出了一种更为严格的二叉平衡树（AVL树），这个树是一个绝对平衡的二叉树，因此在调整形态上会花费更多的性能。 比如我们插入1~16个节点，最后AVL树的结构会如下： 从树的形态我们可以看出来，AVL树不会产生右倾的状态，我们查询16号节点，AVL树会比较四次，而红黑树会比较6次，这样就从根本上解决了红黑树的问题。 所以AVL树的优点有以下几点： 查找性能好（O(logn)），不会产生极端情况，严重降低性能 可以实现范围查找和数据排序 但是AVL树并不适合作为Mysql的底层索引的数据结构，主要是因为数据库查询的瓶颈在于磁盘IO，如果使用AVL树，每个节点只存放一个数据，我们一次磁盘IO只能把一个数据加载到内存中，比如查找节点7，就要进行三次IO，这样会特别耗时间，所以如果要设计数据库索引就要考虑很多情况，首先肯定是每个节点都存放多个数据，而且一次IO就可以加载多个数据到内存中，这就引出了B+树的设计原理。 磁盘IO有个特点，就是磁盘读取1K的数据和读取1B的数据所消耗的时间是一样的。 B树每个节点可以限制存放的key值数量，如果超过了这个约定的key值数量就自动分裂，比如我们继续插入1~16个节点，如果限制一个节点存放2个key的数量的话，结构如下 我们不难看出查询节点16的性能和AVL树一样了，也是经过四次磁盘IO，我们可以考虑每次IO可以读取更多的数据到内存中，可以增加限制的key的数量为6个 这样对于磁盘IO的次数就可以降低一半，只需要两次就可以读取到。 B树的优点： 优秀的检索速度，差查找性能等于O(h*logn)，h是树高，n为每个节点关键词的个数。 尽可能地减少了磁盘IO的次数，提高了性能。 可以支持范围查找。 B+树首先看一下B树和B+树的区别： B树一个节点里存放的是数据，而B+树存放的是索引（地址），所以B树里一个节点 存不了很多数据，但是B+树可以存放很多数索引，B+树叶子节点存放所有数据。 B+树叶子节点使用链表串联了起来，便于范围查找。 对比可以看出，B+树存放的是索引，在单个节点容量有限的情况下，单节点也可以存放大量索引，使得整体树的高度降低，减少了磁盘IO，其次叶子节点是存放真正数据的地方，叶子节点用链表连起来，而且还是有序的，在范围查找中更占有优势。所以mysql索引用的就是B+树，在查找效率和范围查找都有不错的性能。 例如插入1~16个节点： Mysql引擎mysql底层数据引擎以插件的形式设计，最常见的就是InnoDB和Myisam引擎，用户可以根据个人需求来选择不同的引擎作为mysql底层引擎。 首先来分析一下两者的区别： MyISAM查找性能好，但是不支持事务处理，InnoDB最大特色就是支持ACID兼容的事务功能，而且还支持行级锁 InnoDB创建表后生成的文件有： frm:创建表的语句 idb:表里面的数据+索引文件 MyISAM创表后生成的文件有： frm:创建表的语句 MYD:表里面的数据文件（myisam data） MYI:表里面的索引文件（myisam index） InnoDB把数据和索引放在一起，称为聚集索引，而MyISAM把数据和索引分开，称为非聚集索引。 MyISAM底层实现MyISAM采用非聚集索引，建表时以主键作为key来建立B+树，树的叶子节点存放的是对应数据的物理地址，我们拿到这个物理地址后，就可以到MyISAM数据文件中直接定位到具体的数据记录。 当我们为某个字段添加索引时，也会生出该字段的索引树，该字段的索引树的叶子节点同样记录了数据文件中的物理地址，根据这个地址同样可以定位到具体的数据记录。 InnoDB底层实现InnoDB是聚集索引，数据和索引都在一个文件中，建表时，InnoDB会根据主键ID作为key建立索引B+树，B+树叶子节点存放的是主键ID对应的数据。 我们为某个字段添加索引时，会根据这个字段去建立索引树，索引树节点中存放的是字段的值，根节点存放的是主键的值，拿到主键的key值之后会到主键索引创建的B+树查找对应的数据。 InnoDB只在主键索引的叶节点存放具体的数据原因是需要节省空间，一个表可能有多个索引，如果每个都创建一个索引树存放具体数据，就会导致数据文件变得十分巨大，数据冗杂，因此采用上面那种方式就可以牺牲较少的查询性能节省巨大的磁盘空间，还是蛮好的。 对比由上面可以得知，MyISAM查询性能更好，因为MyISAM查询一次就能获取到数据，查询到物理地址就直接去数据文件中寻找。 而InnoDB两次才行，第一次查询到叶子节点的主键索引，第二次根据主键索引去主键索引创建的B+树中去寻找。 什么时候需要创建索引呢？ 查询频繁的字段 唯一性太差的字段不适合创建索引，即使这个字段频繁作为查询条件。 更新频繁的字段不适合创建索引，因为每次都需要维护B+树，导致性能差。 最终选择B+树的原因？ hash特别快，但是只能针对一个值 AVL和红黑树，在大数据的情况下，磁盘IO操作过多 B树每个节点存放的是数据，节点存放的分支太少了。 B+树节点存储的索引是索引和指针（引用指向下一个地址），可以存储大量索引，同时最终数据在叶子节点上，并且有引用横向链接，可以在2~3次的IO操作中完成千万级别表的操作。 建议索引为主键索引，有自增操作，适合范围查找。 文章参考自：https://zhuanlan.zhihu.com/p/113917726","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/tags/mysql/"}]},{"title":"native关键字","slug":"native关键字","date":"2020-07-22T08:49:56.000Z","updated":"2020-07-23T04:10:57.219Z","comments":true,"path":"2020/07/22/native关键字/","link":"","permalink":"http://wysblogs.top/2020/07/22/native关键字/","excerpt":"","text":"","categories":[{"name":"java基础知识","slug":"java基础知识","permalink":"http://wysblogs.top/categories/java基础知识/"}],"tags":[{"name":"java基础知识","slug":"java基础知识","permalink":"http://wysblogs.top/tags/java基础知识/"}]},{"title":"Hash原理探究","slug":"Hash原理探究","date":"2020-07-22T08:49:10.000Z","updated":"2020-07-23T04:12:11.361Z","comments":true,"path":"2020/07/22/Hash原理探究/","link":"","permalink":"http://wysblogs.top/2020/07/22/Hash原理探究/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/tags/数据结构/"}]},{"title":"final关键字详解","slug":"final关键字详解","date":"2020-07-22T08:40:22.000Z","updated":"2020-07-23T04:18:48.610Z","comments":true,"path":"2020/07/22/final关键字详解/","link":"","permalink":"http://wysblogs.top/2020/07/22/final关键字详解/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"Object类的方法","slug":"Object类的方法","date":"2020-07-22T08:37:05.000Z","updated":"2020-07-23T04:18:05.247Z","comments":true,"path":"2020/07/22/Object类的方法/","link":"","permalink":"http://wysblogs.top/2020/07/22/Object类的方法/","excerpt":"","text":"","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"String和StringBuffer,StringBuilder区别","slug":"String和StringBuffer-StringBuilder区别","date":"2020-07-22T08:36:22.000Z","updated":"2020-07-23T04:13:34.937Z","comments":true,"path":"2020/07/22/String和StringBuffer-StringBuilder区别/","link":"","permalink":"http://wysblogs.top/2020/07/22/String和StringBuffer-StringBuilder区别/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"Java反射机制","slug":"Java反射机制","date":"2020-07-22T08:33:46.000Z","updated":"2020-07-23T04:17:40.988Z","comments":true,"path":"2020/07/22/Java反射机制/","link":"","permalink":"http://wysblogs.top/2020/07/22/Java反射机制/","excerpt":"","text":"","categories":[{"name":"反射","slug":"反射","permalink":"http://wysblogs.top/categories/反射/"}],"tags":[{"name":"反射","slug":"反射","permalink":"http://wysblogs.top/tags/反射/"}]},{"title":"ThreadLocal原理","slug":"ThreadLocal原理","date":"2020-07-22T08:33:12.000Z","updated":"2020-07-23T04:17:54.182Z","comments":true,"path":"2020/07/22/ThreadLocal原理/","link":"","permalink":"http://wysblogs.top/2020/07/22/ThreadLocal原理/","excerpt":"","text":"","categories":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/tags/并发/"}]},{"title":"Rest和RPC","slug":"Rest和RPC","date":"2020-07-22T08:31:16.000Z","updated":"2020-07-22T08:31:16.500Z","comments":true,"path":"2020/07/22/Rest和RPC/","link":"","permalink":"http://wysblogs.top/2020/07/22/Rest和RPC/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TreeMap和TreeSet","slug":"TreeMap和TreeSet","date":"2020-07-22T08:29:58.000Z","updated":"2020-07-23T04:17:26.479Z","comments":true,"path":"2020/07/22/TreeMap和TreeSet/","link":"","permalink":"http://wysblogs.top/2020/07/22/TreeMap和TreeSet/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/tags/数据结构/"}]},{"title":"重写equals为什么要重写hashcode","slug":"重写equals为什么要重写hashcode","date":"2020-07-22T08:29:11.000Z","updated":"2020-07-23T04:15:43.601Z","comments":true,"path":"2020/07/22/重写equals为什么要重写hashcode/","link":"","permalink":"http://wysblogs.top/2020/07/22/重写equals为什么要重写hashcode/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"接口和抽象类","slug":"接口和抽象类","date":"2020-07-22T08:28:27.000Z","updated":"2020-07-23T04:11:32.653Z","comments":true,"path":"2020/07/22/接口和抽象类/","link":"","permalink":"http://wysblogs.top/2020/07/22/接口和抽象类/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"重载和重写","slug":"重载和重写","date":"2020-07-22T08:28:14.000Z","updated":"2020-07-23T04:18:34.092Z","comments":true,"path":"2020/07/22/重载和重写/","link":"","permalink":"http://wysblogs.top/2020/07/22/重载和重写/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"equals 和 ==","slug":"equals-和","date":"2020-07-22T08:27:23.000Z","updated":"2020-07-23T04:16:37.987Z","comments":true,"path":"2020/07/22/equals-和/","link":"","permalink":"http://wysblogs.top/2020/07/22/equals-和/","excerpt":"","text":"","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"}]},{"title":"Session和Cookie区别","slug":"Session和Cookie区别","date":"2020-07-22T08:24:53.000Z","updated":"2020-07-23T04:13:16.386Z","comments":true,"path":"2020/07/22/Session和Cookie区别/","link":"","permalink":"http://wysblogs.top/2020/07/22/Session和Cookie区别/","excerpt":"","text":"","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wysblogs.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wysblogs.top/tags/计算机网络/"}]},{"title":"linux常用命令（持续更新）","slug":"linux常用命令（持续更新）","date":"2020-07-22T08:23:06.000Z","updated":"2020-07-23T04:18:23.332Z","comments":true,"path":"2020/07/22/linux常用命令（持续更新）/","link":"","permalink":"http://wysblogs.top/2020/07/22/linux常用命令（持续更新）/","excerpt":"","text":"","categories":[{"name":"linux","slug":"linux","permalink":"http://wysblogs.top/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wysblogs.top/tags/linux/"}]},{"title":"mysql事务和隔离级别","slug":"mysql事务和隔离级别","date":"2020-07-22T08:21:43.000Z","updated":"2020-07-23T04:18:12.888Z","comments":true,"path":"2020/07/22/mysql事务和隔离级别/","link":"","permalink":"http://wysblogs.top/2020/07/22/mysql事务和隔离级别/","excerpt":"","text":"","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/tags/mysql/"}]},{"title":"红黑树和AVL树","slug":"红黑树和AVL树","date":"2020-07-22T08:17:44.000Z","updated":"2020-07-23T04:17:00.821Z","comments":true,"path":"2020/07/22/红黑树和AVL树/","link":"","permalink":"http://wysblogs.top/2020/07/22/红黑树和AVL树/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/tags/数据结构/"}]},{"title":"B树和B+树","slug":"B树和B-树","date":"2020-07-22T08:16:58.000Z","updated":"2020-07-23T04:15:25.558Z","comments":true,"path":"2020/07/22/B树和B-树/","link":"","permalink":"http://wysblogs.top/2020/07/22/B树和B-树/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/tags/数据结构/"}]},{"title":"TCP三次握手和四次挥手","slug":"TCP三次握手和四次挥手","date":"2020-07-22T08:15:28.000Z","updated":"2020-07-23T04:11:16.428Z","comments":true,"path":"2020/07/22/TCP三次握手和四次挥手/","link":"","permalink":"http://wysblogs.top/2020/07/22/TCP三次握手和四次挥手/","excerpt":"","text":"","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wysblogs.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://wysblogs.top/tags/计算机网络/"}]},{"title":"各类锁的介绍和原理","slug":"各类锁的介绍和原理","date":"2020-07-22T08:13:37.000Z","updated":"2020-07-23T04:16:18.770Z","comments":true,"path":"2020/07/22/各类锁的介绍和原理/","link":"","permalink":"http://wysblogs.top/2020/07/22/各类锁的介绍和原理/","excerpt":"","text":"","categories":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/tags/并发/"}]},{"title":"Innodb探究","slug":"Innodb探究","date":"2020-07-22T08:12:56.000Z","updated":"2020-07-23T04:15:57.622Z","comments":true,"path":"2020/07/22/Innodb探究/","link":"","permalink":"http://wysblogs.top/2020/07/22/Innodb探究/","excerpt":"","text":"","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/tags/mysql/"}]},{"title":"华宇金信面经","slug":"华宇金信面经","date":"2020-07-20T03:26:30.000Z","updated":"2020-07-20T05:24:48.359Z","comments":true,"path":"2020/07/20/华宇金信面经/","link":"","permalink":"http://wysblogs.top/2020/07/20/华宇金信面经/","excerpt":"","text":"华宇金信面经（第一次面试）毕竟是第一次面试，凉了也没关系，可以多学一些知识 重载和重写的区别 重载 被重载的方法必须改变参数列表 被重载的方法可以改变返回类型 被重载的方法可以改变访问修饰符 被重载的方法可以声明新的或更广的检查异常 方法能够在同一个类中或者在一个子类中被重载 无法以返回值类型作为重载函数的区分标准 重写 参数列表必须完全与重写方法的相同 返回值类型与重写的返回值类型可以不相同 访问权限不能比父类中被重写的方法访问权限更低 父类的成员方法只能被子类重写 声明final的方法不能被重写 声明static的方法不能被重写，但是能够被再次声明 子类和父类在同一个包中，可以重写除了声明private和final的方法 子类和父类不在同一个包中，只能够重写父类的声明public和protected的非final方法 重写的方法可以抛出非强制性异常，无论被重写的方法是否抛出异常，但是不能抛出新的强制性异常，或者比重写方法声明更广泛的强制性异常。 构造方法不能被重写 如果不能继承一个方法，就不能重写这个方法。 接口和抽象类的区别 抽象类和接口都不能直接被实例化 抽象类要被子类继承，接口要被子类实现 接口里面只能对方法进行声明，抽象类既可以声明也可以对方法进行实现 抽象类中的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类，接口里面的方法必须全部被子类实现，如果子类不能实现那么子类必须是抽象类 接口里面的方法只能声明，但是jdk1.8有了default method方式可以进行实现。 抽象类里面可以没有抽象方法 如果一个类里面有抽象方法，那么这个类一定是抽象类 抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。 接口可以继承接口，甚至可以继承多个接口，但是类只能继承一个类 抽象级别：接口 &gt; 抽象类 &gt; 实现类 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能，当你关注事物的本质的时候，请用抽象类，当你关注一种操作的时候，用接口。 接口的设计具有更大的可扩展性，而抽象类的设计必须十分谨慎（要考虑到子类所具有的共同属性和方法）。 类的访问修饰符12345//public 、 default 、 abstract 、 finalpublic class Test();class Test2();abstract class Test3();final class Test4(); public 表示任何位置都可以访问该类 defalut 默认是不写的，只能在同一个包下被访问 abstract表示是个抽象类，不能实例化该类，如果要使用，必须用子类继承 final修饰的类不能给子类继承，改类为最终类，不能在被继承。 为什么 private 和 protected 不能修饰外部类 1、private：表示不能被其它类访问，这个类就失去了意义，所以private只能修饰内部类，被private修饰的类只能被该类的外部类内部使用 2、protected：同理，外部类不能访问，所以这个也没有意义。 3、内部类四种修饰符都可以被使用。 equals 和 ==1、基本数据类型用 == 比较的是值 2、引用数据类型之间用 == 比较的内存引用地址 3、引用数据类型之间使用equals比较的是地址所映射的值 SpringBoot 启动原理123456//核心注解@SpringBootApplication //这个注解包含了一下几种注解@SpringBootConfiguration //主要配置信息@EnableAutoConfiguraiton //开启自动配置，会扫描符合的bean加载到ioc容器中@ComponentScan //扫描所有的包 启动流程 1、首先执行main入口方法运行SpringAppliction.run，后面new了一个SpringApplication对象，然后执行run方法。 2、初始化SpringApplication类，创建SpringApplication对象时，会自动调用初始化方法（initialize()方法） 3、之后执行核心run()方法，然后启动SpringBoot项目。 SpringBoot内置容器undertow tomcat 默认容器 jetty SpringBoot注解 RestController 和 Controller区别1、RestController 相当于 ResponseBody + Controller注解 2、Controller 返回的是视图 3、 RestController返回的是json或者xml格式的数据 MyBits相关的函数没理解这个到底是什么玩意儿。 可能是标签之类的 12345678910select ---查询update ---更新delete ---删除insert ---插入if test ---可以使用String 类的一些方法where ---条件判断choose ---选择 --- resultType ---返回值的类型collection ---集合标签association ---关联标签 Nginx负载均衡 轮询机制Nginx 是个反代服务器 负载均衡： 将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后汇总给用户。 将大量前端并发访问或数据流量分担到多个后端网络节点上分别处理（分流） 负载均衡策略： 内置策略 轮询 将每个前端按顺序逐一分配到后端节点上，出现问题的自动排除。 加权轮询 将每个前端按权值依次分配到后端节点上，根据权重的大小来判断每个节点被访问到的概率 IP hash 对访问ip进行hash操作，根据hash结果将请求分配到后端节点上。 扩展策略 将前端的请转发到最近负载最小的节点 算法名称排序 快速排序 堆排序 桶排序 冒泡排序 希尔排序 选择排序 插入排序 DP算法 KMP算法 快速幂 字典树 线段树 后缀数组 DFS和BFS 弗洛伊德算法，迪杰斯特拉算法 最大流，最小流 滑动窗口 数据结构 B树 和 B+树区别B树：这个是一个多路平衡查找树 特点： 每个节点最多有m-1个关键字 根节点最少可以只有1个关键字 非根节点至少有m/2个关键字 每个节点中的关键字都按照从小到大排序，每个左节点小于右节点 所有叶子节点都位于同一层，叶子节点到根节点距离都相同 每个节点都存有索引和数据，也就是对应的key和value值 根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。 B+树：和B树非常相似 与B树相同点： 根节点至少有一个元素 非根节点元素范围 m/2 &lt;= k &lt;= m-1 不同点： B+树有两种类型的节点：内部节点（也称索引节点）和叶子节点 每个叶子节点都存有相邻叶子节点的指针，叶子节点本身依关键字的大小自小而大顺序链接 父节点存有右孩子的第一个元素的索引 总结： 单一节点存储的元素更多，使得查询的IO次数更少，比B树更适合做mysq的底层 所有的查询都要查找到叶子节点，查询性能稳定，B树每个节点都可以查找到数据，不够稳定。 所有的叶子节点形成了有序链表，更加便于查找。 git命令行 总结基础知识差的太多了，一定要多看，多记，多理解。","categories":[{"name":"面经","slug":"面经","permalink":"http://wysblogs.top/categories/面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://wysblogs.top/tags/面经/"}]},{"title":"单例模式","slug":"单例模式","date":"2020-07-20T02:54:19.000Z","updated":"2020-07-20T03:25:08.812Z","comments":true,"path":"2020/07/20/单例模式/","link":"","permalink":"http://wysblogs.top/2020/07/20/单例模式/","excerpt":"","text":"单例模式简介单例模式","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wysblogs.top/tags/设计模式/"}]},{"title":"双亲委派模型","slug":"双亲委派模型","date":"2020-07-20T01:56:53.000Z","updated":"2020-07-20T02:23:18.548Z","comments":true,"path":"2020/07/20/双亲委派模型/","link":"","permalink":"http://wysblogs.top/2020/07/20/双亲委派模型/","excerpt":"","text":"双亲委派模型简介类加载阶段分为加载，连接，初始化，使用，卸载阶段。 由于在加载阶段需要使用全限定类名来获取此类的二进制字节流 Java把这一步抽出来用类加载器去实现，使得可以按自己的需要使用自定义的类加载器 在java中 任意一个类和其加载器来确定类在JVM中的唯一性 类加载器除了能加载类，还能用来作为类层次的划分 java中提供了三个类加载器： 启动类加载器（Bootstrap ClassLoader）：主要负责加载lib目录下的包，或者是被-Xbootclasspath指定路径中，并且文件名是被虚拟机识别的文件，它也是最顶层的加载器。 扩展类加载器（Extension ClassLoader）：主要负责加载lib目录下的ext目录下的包，或者被java.ext.dirs系统变量所指定的路径的类库。 应用程序类加载器（Application ClassLoader）：主要负责加载用户类路径（ClassPath）下的类库，如果没有实现自定义类加载器，那么这就是我们默认的加载器。 模型 解释如果一个类加载器需要加载类，会把这个类交给父类去加载，每一层类加载器都是如此，直到最顶层的父类加载器不能加载这个类，那么就会把这个类交给子类加载器来解决。 双亲委派模型不是一种强制性约束，就是如果你不这样去做也不会报错，他是java设计者推荐使用的类加载方式。 优点 避免java核心api被修改，保证了类加载的安全性 可以避免类的重复加载","categories":[{"name":"jvm","slug":"jvm","permalink":"http://wysblogs.top/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://wysblogs.top/tags/jvm/"}]},{"title":"Mysql索引基础","slug":"Mysql索引","date":"2020-07-19T12:00:34.000Z","updated":"2020-07-22T11:12:05.294Z","comments":true,"path":"2020/07/19/Mysql索引/","link":"","permalink":"http://wysblogs.top/2020/07/19/Mysql索引/","excerpt":"","text":"Mysql索引建立在一个或多个列上的辅助对象，可以加快查询的速度和效率。 索引的实质就是数据结构 优点 自带排序 快速查找 主键索引保证唯一性 表与表连接处添加索引，加速表与表的直接连接 分组和排序语句进行数据检索，减少查询时间中的分组和排序的时间 提高性能 缺点 占用空间 降低更新表的速度 需要动态维护，降低数据的维护速度 创建索引和维护索引会消耗时间，随着数据量的增加而增加 索引分类 普通索引 唯一索引 主键索引 组合索引 全文索引 单例索引一个索引只包含一个列，一个表可以有多个单例索引 1、普通索引最最最基本的索引，没有任何限制， sql格式： 123CREATE INDEX IndexName ON `table_name` (`字段名`(length))#或者ALTER TABLE table_name ADD INDEX IndexName(`字段名`(length)); 2、唯一索引与普通索引相似，只是唯一索引值是唯一的，和主键索引相似，但是唯一索引允许空值。 123CREATE UNIQUE INDEX IndexName ON `table_name`(`字段名`(lenght));#或者ALTER TABLE `table_name` ADD UNIQUE (`字段名`(length)); 3、主键索引不允许有空值，在B+树的InnoDB引擎中，主键索引起到了很重要的作用。 主键索引建表规则是int大于varchar，一般在建表的时候创建。 一般来说都会在首列，不会与其他列冲突，默认会设置成int类型，而且是AUTO_INCREMENT类型。 组合索引一个组合索引包含两个或者两个以上的列。 但是如果一个表中含有多个单例索引不代表是组合索引。 通缩来说：包含多个字段但是只有索引名称。 sql格式 1CREATE INDEX ·索引名称· ON `表名`(`字段1`, `字段2`, `字段3`); 如果创建组合索引，实际包含的是 123(`字段1`)(`字段1`，`字段2`)(`字段1`,`字段2`,`字段3`) 在查询的时候要遵循最左前缀原则，即索引where时，要对照创建时候的字段名顺序进行查询。 使用组合索引时，不能出现单例索引，否则可能会使用单例索引进行查询 全文索引如果文本字段建立的是普通索引，那么只会对字段前面的字符进行索引。 如果出现多个一样的字符，需要查找的话只能进行where column like %xxxx%，但是这样操作只会让索引失效。 所以全文索引就出来了。 1ALTER TABLE `table_name` ADD FULLTEXT(`column1`,`column2`); 有了全文索引，就能检索多个单词记录了。 1SELECT * FROM `table_name` WHERE MATCH(column1, column2) AGAINST(&apos;xxx&apos;, &apos;sss&apos;, &apos;ddd&apos;); 索引操作查询索引1SHOW INDEX FROM `table_name`; 删除索引1DROP INDEX IndexName ON `table_name`; 什么时候不需要创建索引 列很少使用，建立索引会影响整体的性能和增大空间需求。 数据很少的列也不需要创建，比如性别，只有男女。 定义位text和image和bit数据类型的列不应该增加索引。 当update，insert，delete操作远大于检索select操作时不需要，因为需要一直维护索引，会降低性能。 注意 负向条件不能使用索引 前导模糊查询不能用索引，非前导模糊查询可以 数据区分度不大不用使用索引 属性上计算不能命中索引 如果业务大部分是单条查询，使用Hash索引性能更好 单列索引不存null值，组合索引不应该全存null值，不然可能会得到不符合预期的结果集。 组合索引并不是需要一定要和字段顺序一样，mysql查询时会优化查询，比如 (a,b,c)，查询时使用(b,a)，也会优化成击中索引(a，b)。 如果明确知道会返回一条结果，那么使用 limit 1 能够提高效率，原因是告诉mysql不需要再往下查询了。 把计算放到业务层而不是数据库层，除了节省CPU，还会有查询缓存优化的作用。 强制类型转换会进行全表扫描。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/tags/mysql/"}]},{"title":"JUC知识总结","slug":"JUC知识总结","date":"2020-07-18T01:32:50.000Z","updated":"2020-07-22T11:16:41.631Z","comments":true,"path":"2020/07/18/JUC知识总结/","link":"","permalink":"http://wysblogs.top/2020/07/18/JUC知识总结/","excerpt":"","text":"JUC知识总结JUC是一个包，全称是java.uitls.current包","categories":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/tags/并发/"}]},{"title":"线程之间的通信","slug":"线程之间的通信","date":"2020-07-18T01:31:37.000Z","updated":"2020-07-21T03:18:26.815Z","comments":true,"path":"2020/07/18/线程之间的通信/","link":"","permalink":"http://wysblogs.top/2020/07/18/线程之间的通信/","excerpt":"","text":"线程之间的通信解决开发中遇到线程A执行完成后通知线程B的问题 有以下几种方法： 等待通知机制 join()方法 volatile共享内存 CountDownLatch 并发工具 CyclicBarrier 并发工具 线程响应中断 线程池 awaitTermination() 方法 管道通信 1、等待通知机制java中比较经典的线程通信方式 两个线程对同一对象调用wait()和notify()方法来进行通信 例如两个线程交替打印奇偶数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/18 10:02 * @FileName: ThreadCommunicationDemo */public class ThreadCommunicationDemo &#123; public static int i = 1; //是否时奇数 public static boolean flag = true; public static void main(String[] args) &#123; ThreadCommunicationDemo threadCommunicationDemo = new ThreadCommunicationDemo(); Thread t1 = new Thread(new OddNumber(),\"A\"); Thread t2 = new Thread(new EvenNumber(),\"B\"); t1.start(); t2.start(); &#125; /** * 奇数线程 */ public static class OddNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(flag)&#123; System.out.println(Thread.currentThread().getName()+\": \"+i); i++; flag = false; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //阻塞线程 释放锁 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; /** * 偶数线程 */ public static class EvenNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(!flag)&#123; System.out.println(Thread.currentThread().getName()+\": \"+i); i++; flag = true; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //释放锁同时进行阻塞 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/18 10:02 * @FileName: ThreadCommunicationDemo */public class ThreadCommunicationDemo &#123; public static int i = 1; //是否时奇数 public static boolean flag = true; public static void main(String[] args) &#123; ThreadCommunicationDemo threadCommunicationDemo = new ThreadCommunicationDemo(); Thread t1 = new Thread(new OddNumber(),\"A\"); Thread t2 = new Thread(new EvenNumber(),\"B\"); t1.start(); t2.start(); &#125; /** * 奇数线程 */ public static class OddNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(flag)&#123; System.out.println(Thread.currentThread().getName()+\": \"+i); i++; flag = false; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //阻塞线程 释放锁 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; /** * 偶数线程 */ public static class EvenNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(!flag)&#123; System.out.println(Thread.currentThread().getName()+\": \"+i); i++; flag = true; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //释放锁同时进行阻塞 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 解释： A，B线程都使用ThreadCommunicationDemo.class作为锁，A线程调用wait()方法释放锁，进入waiting状态，B线程调用notify()方法，A线程收到通知后就可以从wait()方法进行返回了。 注意： wait()、notify()、notifyAll()、调用的前提是获得对象的锁 调用wait()方法后线程会释放锁，进入waiting状态，线程也会被移入等待队列中。 调用notify()方法会将等待队列移动到同步队列，线程状态也会被更新成blocked状态 从wait()方法返回的前提是调用notify()方法的线程获得锁，wait()方法的线程释放锁。 经典范式 线程 A 作为消费者： 获取对象的锁。 进入 while(判断条件)，并调用 wait() 方法。 当条件满足跳出循环执行具体处理逻辑。 线程 B 作为生产者: 获取对象锁。 更改与线程 A 共用的判断条件。 调用 notify() 方法。 1234567891011121314151617/*** 伪代码*///Thread Asynchronized(Object)&#123; while(条件)&#123; Object.wait(); &#125; //do something&#125;//Thread Bsynchronized(Object)&#123; 条件=false;//改变条件 Object.notify();&#125; 2、join()方法123456789101112131415161718192021222324252627282930313233package org.example.thread;/** * @Author: wys * @Description: * @Date: 2020/7/18 16:19 * @FileName: JoinDemo */public class JoinDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"执行完毕\"); &#125; &#125;,\"A\"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"执行完毕\"); &#125; &#125;,\"B\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"线程完毕\"); &#125;&#125; 结果 123B执行完毕A执行完毕线程完毕 t1 会阻塞 至 t1 结束，最终主线程会等待 t1 和 t2 执行完毕。 join的核心逻辑 123while (isAlive()) &#123; wait(0);&#125; join线程完成后会调用 notifyAll方法，在JVM中实现 3、volatile共享内存1234567891011121314151617181920212223242526272829303132333435package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/18 17:25 * @FileName: VolatileDemo */public class VolatileDemo &#123; public static volatile boolean flag = true; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; while(flag)&#123; System.out.println(Thread.currentThread().getName()+\"执行ing\"); &#125; System.out.println(\"执行结束\"); &#125;,\"A\").start(); new Thread(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(1); stopThread(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,\"B\").start(); &#125; public static void stopThread()&#123; flag = false; &#125;&#125; 利用volatile的可见性对所有线程进行通知 3、CountDownLatch 并发工具​ Await()等待，countDown()计数，当count清零时，唤醒线程 123456789101112131415161718192021222324252627282930313233343536373839/** * @Author: wys * @Description: 5s后线程B通知结束线程A * @Date: 2020/7/18 17:50 * @FileName: CountDownLatch */public class CountDownLatchDemo &#123; private static int count = 0; private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) &#123; new Thread(()-&gt;&#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"开始执行\"); if(count!=5)&#123; try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+\"执行结束\"); &#125;,\"A\").start(); new Thread(()-&gt;&#123; for(int i=0;i&lt;5;i++)&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count++; &#125; if(count == 5)&#123; countDownLatch.countDown(); &#125; &#125;,\"B\").start(); &#125;&#125; 4、CyclicBarrier并发工具等待线程全部准备完毕，然后统一开始启动 12345678910111213141516171819202122232425262728293031323334353637383940package org.example.thread;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * @Author: wys * @Description: * @Date: 2020/7/21 9:42 * @FileName: CyclicBarrierDemo */public class CyclicBarrierDemo &#123; private CyclicBarrier cyclicBarrier = new CyclicBarrier(3); public static void main(String[] args) &#123; CyclicBarrierDemo demo = new CyclicBarrierDemo(); new Thread(()-&gt;&#123;demo.threadStarted();&#125;,\"A\").start(); new Thread(()-&gt;&#123;demo.threadStarted();&#125;,\"B\").start(); new Thread(()-&gt;&#123;demo.threadStarted();&#125;,\"C\").start(); &#125; public void threadStarted() &#123; System.out.println(Thread.currentThread().getName()+\"正在准备启动！\"); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"启动完毕\"); &#125;&#125; 5、线程中断响应12345678910111213141516171819202122232425262728293031package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/21 10:30 * @FileName: StopThreadDemo */public class StopThreadDemo &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println(Thread.currentThread().getName()+\"运行中\"); &#125; System.out.println(Thread.currentThread().getName()+\"已结束\"); &#125;,\"A\"); t1.start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t1.interrupt(); &#125;&#125; 使用isInterrupted()方法来判断线程有没有被中断 其他线程中使用interrupt()方法来通知其他线程进行中断响应 原理是interrupt()方法将线程中某个标志位改了，默认是true， 如果遇到但是如果抛出了InterruptedException 异常，该标志就会被 JVM 重置为 false。 6、线程池 awaitTermination() 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package org.example.thread;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/21 10:45 * @FileName: ThreadPoolExecutorDemo */public class ThreadPoolExecutorDemo &#123; public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(); ThreadPoolExecutor pool = new ThreadPoolExecutor(5,5,1, TimeUnit.MILLISECONDS,queue); pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"running\"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"running\"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); pool.shutdown(); while(!pool.awaitTermination(1,TimeUnit.SECONDS))&#123; System.out.println(\"线程在执行ing\"); &#125; System.out.println(\"主线程结束\"); &#125;&#125; 如果使用线程池，可以让主线程等待所有线程执行完毕。 使用awaitTermination()这个方法的前提是关闭线程池，如调用shutdown()方法等。 调用结束方法后，线程池不会接受新的任务，而是会平滑的关闭各个线程池中的已有的任务。 7、管道通信1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package org.example.thread;import java.io.IOException;import java.io.PipedReader;import java.io.PipedWriter;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/21 10:56 * @FileName: PipeDemo */public class PipeDemo &#123; public static void main(String[] args) throws IOException &#123; PipedWriter writer = new PipedWriter(); PipedReader reader = new PipedReader(); //建立连接 writer.connect(reader); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"running\"); try &#123; for(int i=0;i&lt;10;i++)&#123; writer.write(i+\"\"); TimeUnit.SECONDS.sleep(1); writer.flush(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"A\").start(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\"running\"); int msg = 0; try&#123; while((msg = reader.read())!=-1)&#123; System.out.println(\"msg = \"+(char)msg); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,\"B\").start(); &#125;&#125; 管道通信，首先先建立连接，然后在通信，相当于生产者和消费者。","categories":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/tags/并发/"}]},{"title":"JVM虚拟机知识点","slug":"JVM虚拟机知识点","date":"2020-07-11T00:50:51.000Z","updated":"2020-07-11T13:20:02.486Z","comments":true,"path":"2020/07/11/JVM虚拟机知识点/","link":"","permalink":"http://wysblogs.top/2020/07/11/JVM虚拟机知识点/","excerpt":"","text":"JVM虚拟机知识点运行时数据区运行时数据区就是jvm运行java文件时，会把管理的内存分为好几个部分，每一个部分就是一个运行时数据区。 结构图 线程共享的区域方法区：存放类信息，静态变量，常量，运行时常量池 的区域 堆：几乎所有的对象存放的地方，同时也是GC的主要区域 ​ 数组也存放在堆中 分代处理：目的是为了更好的回收内存和分配内存 新生代：Eden空间，From Survivor空间，To Survivor空间 老年代：存活周期特别长的对象 空间结构：逻辑连续，物理不连续 TLAB（线程本地分配缓存）：线程私有，空间小，避免同步带来的效率问题，从而提高分配效率 OOM：内存没有办法分配，堆也无法扩展，就会报出OOM异常 ​ 扩展：一般用逃逸分析法来判断对象是否分配在堆中或者是栈中，如果一个对象是随着方法的运行而出现，方法结束，对象也结束的话，就可以认为这个对象没有逃逸出方法，因此会分配在栈中 线程私有的区域栈： 生命周期与线程相同 描述的java方法执行的内存模型 栈帧：每执行一个方法就装入一个栈帧，每运行一个方法弹出 局部变量表：基本单位是变量槽，一个变量槽是四字节，如果遇到大于四字节的变量，就需要分成多部份来装。 基本数据类型 对象句柄 方法参数 方法的局部变量 操作数栈 动态链接 方法返回地址 …… 可能产生的异常：OutofMemoryError，StackOverflowError 本地方法栈：为navice方法服务 程序计数器：就是字节码执行的指令行号，如果是native方法就为空 对象创建从JVM角度来说： 检查类是否被加载 为对象分配内存空间 初始化对象字段 设置对象头 对象头 MarkWork：记录了对象和锁有关的信息 指向类的指针： 数组长度： 执行构造方法 对象访问定位句柄如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。 指针如果使用指针访问访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。 类加载机制类的生命周期 加载1、通过全限定类名获取此类的二进制字节流 2、将字节流所代表的静态存储结构转换为方法去的运行时数据结构 3、在内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口 加载阶段是可控性最强的，可以重写loadClass()方法，数组类型不通过类加载器加载，而是由虚拟机直接创建的。 加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就开始了 验证 准备这个阶段是为了给类变量分配内存并且设置初始值的阶段，内存都在 方法区中分配 1、这个阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化的时候跟着对象一起分配到java堆中。 2、初始值默认都是0或者是null，如果用final修饰的话，初始值可以指定成想要的样子。 解析这个阶段是把符号引用解析成直接引用的过程，解析动作主要针对 接口、字段、类方法】接口方法、方法类型、方法句柄、调用限定符等7类符号引用进行： 符号引用：就是用一组符号描述目标，可以是任意字面量。 直接引用：只有符号引用是不够的，还需要明确知道方法所在的位置，java虚拟机存在一个方法表，调用类方法是，只需要根据符号引用找到方法表中偏移量就能直接调用该方法。 总的来说，解析过程就是把符号引用替换成直接引用的过程，也就是获得方法、字段指针或者偏移量的过程。 初始化初始化是类加载的最后一步，也就是执行字节码，初始化过程是执行类构造器&lt;clinit&gt;() 方法的过程。 &lt;clinit&gt;()自带锁，线程安全，并且可能会造成死锁，而且这种死锁很难被发现 初始化阶段，有五种情况，必须对类进行初始化： 第一种情况： 当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。 当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。 当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。 当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。 使用java.lang.reflect包的方法对类进行反射调用，例如Class.forname()，newInstance()等等情况下，如果没有初始化，就会触发初始化。 初始化一个类的时候，父类没初始化，先初始化父类 虚拟机启动时，先初始化用户必须定义的主类 MethodHandle和VarHandle可以看作轻量级反射调用机制，而想要使用这两个调用就必须先使用findStaticVarHandle来初始化调用的类 JDK8新加入默认方法，被default关键字修饰接口方法时，如果这个实现类发生了初始化，接口要在其之前被初始化。 卸载卸载表示这个类的Class对象被GC 卸载类需要满足三个条件： 1、该类的所有实例对象都被GC。也就是堆里面没有这个对象， 2、该类没有在其他任何地方被引用 3、该类的类加载器的实例已被GC 自定义类的加载器可能被卸载，但是jdk自带的类加载器不会被卸载，比如 BootstrapClassLoader，PlatformClassstrapClassLoader，AppClassLoader，肯定不会被回收，因此使用我们自定义加载器加载的类是可以被卸载的。 垃圾回收JVM内存分配与回收java自动内存管理主要是针对对象内存的回收和对象内存的分配。 堆是垃圾收集器主要管理的地方。因此也被称为GC堆。 JAVA堆的结构 分为 新生代：Eden，From Survivor0，To Survivo1，老年代：Old Memeory 进一步划分的目的 是为了更好的回收和分配内存 常见的分配策略GC之后，Eden区和幸存区都被清空， from 和 to 交换角色，不管怎么样都要保证to的幸存区为空， to 被填满后，会将所有对象移动到老年代中。 分代回收算法新生代和老年代有着不同的回收算法，根据每个区域的特点不同选择合适的垃圾收集算法， 一般情况下，对象在eden区分配，当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 新生代GC（Minor GC）：指发生新生代的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快 老年代GC（Major GC/Full GC）：只发生在老年代GC，出现Major GC经常会伴随至少一次的 Minor GC（不一定），Major GC的速度一半回避Minor GC慢10倍以上。 12345678public class Test08 &#123; public static void main(String[] args) &#123; byte[] a,b; a = new byte[30900*1024]; b = new byte[30900*1024]; &#125; 老年代大对象是需要大量连续内存空间的对象（比如：字符串，数组等） 原因是为了避免分配内存时，分配担保机制带来的复制而降低效率。 长期存活的对象进入老年代，在eden出生并经过1次存活后，会进入到幸存区，在幸存区经过多次存活（默认是15次），就会进入老年代。 可以通过-XX:MaxTenuringThreshold进行设置 对象存活堆中几乎存放着所有的对象实例，对堆垃圾回收之前必须要先判断是否存活 引用计数法给每个对象实例添加一个引用计数器，引用时加1，引用失效时减一，当计数器为0时，就判断这个对象已经不再使用，就回收掉。 这种方法实现简单，效率高，但是目前主流的虚拟机并没有用这种方法，主要是没办法解决循环引用问题。 123456789101112public class Test09 &#123; Object instance = null; public static void main(String[] args) &#123; Test09 t1 = new Test09(); Test09 t2 = new Test09(); t1.instance = t2; t2.instance = t1; t1 = null; t2 = null; &#125;&#125; 可达性分析思想就是通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象不可用。 可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 本地方法栈（Native方法）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 四种引用类型 强引用 最普遍的引用，垃圾回收器绝不会回收它，当内存空间不足，jvm宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会考随意回收。 软引用 可有可无，内存足够就不回收，内存不够就会回收 弱引用 可有可无，这个生命周期特别短，如果垃圾回收器发现了它，不管内存够不够，都会回收。但是垃圾回收器优先级很低，不一定很快就发现。 虚引用 与其他几种不同，这个不会决定对象的生命周期，如果一个对象持有虚引用，那么在任何时候都有可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 与其他几种引用的区别：回收一个对象前，发现它还有虚引用，就会在回收对象内存之前，把它加入到引用队列，可以在内存回收之前来对这个对象进行操作 使用软引用情况多，软引用可以加速JVM对垃圾的回收速度，客户以维护系统的运行安全，防止内存溢出等问题的发生。 不可达对象不一定会被GC掉要宣告一个对象死亡必须经过两次标记，第一次标记的时候只是判断是否有必要执行finalize方法，当对象没有覆盖finalize方法，或者finalize方法已经被调用过时，就没必要GC掉，除非第二次GC时候还是没有和引用链有关联。 怎么判断一个常量是废弃常量当常量池中存在的字符串“abc”没有任何对象引用的时候，就说明它是废弃常量，下次GC，就会回收掉。 垃圾收集算法 标记-清除算法 复制算法 标记-整理算法 分代收集算法 标记-清除算法就是标记和清除阶段，首先比较出所有需要回收的对象，都打上标记，再进行清除 会造成两种问题： 效率问题 空间问题（标记清除后会产生大量不连续的碎片） 复制算法为了解决这个效率问题，就出现了复制算法，将内存分为大小相同的两部分，每次就只用一半，用完就清理掉，然后把剩下的放到另一块中。 空间问题（花销太大） 标记-整理算法过程和标记清除算法一样，后面会增加一个整理过程。 效率问题很大 分代收集算法就是把堆分为新生代和老年代，然后根据不同的特点进行不同的算法。 为什么要分为新生代和老年代？因为每个对象的存活时间不一样，有的特别长，有的特别短，因此需要用不同的分区来进行分别管理。 为什么要用两个Survivor？因为要管理内存碎片，而其中对象存活时间一般很短，用复制算法比较有效率 垃圾收集器 Serial收集器 ParNew收集器 Parallel Scavenge收集器 CMS收集器 G1收集器 如果说收集算法是理论，那么这个垃圾收集器就是内存回收的具体实现。 我们需要根据具体应用场景选择合适自己的垃圾收集器 Serial收集器很古老的收集齐了，历史悠久，他是个单线程垃圾收集器，收集垃圾的时候还必须暂停其他所有的工作进程，直到他收集完成。 新生代采用复制算法，老年代采用标记整理算法。 ParNew收集器就是Serial收集器的多线程版本，除了使用多线程收集垃圾外，其余行为和Serial收集器完全一样。 但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。 新生代采用复制算法，老年代采用标记-整理算法 只有这个收集器能与CMS收集器配合工作 Parallel Scavenge收集器Parallel Scavenge收集器也是使用复制算法的多线程收集器，他看上去几乎和ParNew一样。 123-XX:+UseParallelGC //使用Parallel 收集器 + 老年代串行-XX:+UseParallelOldGC //使用Parallel收集器 + 老年代并行 Parallel Scavenge收集器 关注点是吞吐量（高效率的利用CPU）。 CMS等垃圾收集器的关注点更多的是用户现成的停顿时间（提高用户体验）。 所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 新生代采用复制算法，老年代采用标记-整理算法 Serial Old收集器Serial收集器的老年代版本 jdk1.5版本之前和Parallel Old 搭配使用 作为CMS收集器的后备方案 Parallel Old收集Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”，注重吞吐量以及CPU资源，可以优先考虑。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对 CPU 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 G1收集器G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 空间整合：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。 G1 收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://wysblogs.top/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://wysblogs.top/tags/jvm/"}]},{"title":"redis缓存穿透，缓存击穿，缓存雪崩","slug":"redis缓存穿透，缓存击穿，缓存雪崩","date":"2020-07-10T07:11:43.000Z","updated":"2020-07-10T07:53:32.264Z","comments":true,"path":"2020/07/10/redis缓存穿透，缓存击穿，缓存雪崩/","link":"","permalink":"http://wysblogs.top/2020/07/10/redis缓存穿透，缓存击穿，缓存雪崩/","excerpt":"","text":"Redis缓存穿透，缓存击穿，缓存雪崩介绍 缓存穿透：key对应的数据源不存在，每次针对这个key的请求从缓存中获取不到，请求都会到数据源，从而可能压垮数据源。比如使用一个数据库和redis都不存在的用户id获取该用户信息，若有人利用此漏洞进行攻击，可能会压垮数据库。 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并缓存在redis中，这时候大并发请求可能瞬间会把后端DB压垮。 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，也会给后端DB带来很大压力。 解决方案缓存穿透解决方案最常用的就是布隆过滤器，将所有可能的数据hash到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免s对底层存储系统的查询压力。 其次，还有一个更简单的方法，如果一个查询返回的数据为空，仍然把这个空结果缓存下在，但是时间很短，最长不超过5分钟。 123456789101112131415161718192021222324//伪代码public object GetProductListNew() &#123; int cacheTime = 30; String cacheKey = \"product_list\"; String cacheValue = CacheHelper.Get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; cacheValue = CacheHelper.Get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; else &#123; //数据库查询不到，为空 cacheValue = GetProductListFromDB(); if (cacheValue == null) &#123; //如果发现为空，设置个默认值，也缓存起来 cacheValue = string.Empty; &#125; CacheHelper.Add(cacheKey, cacheValue, cacheTime); return cacheValue; &#125;&#125; 缓存击穿解决方案key可能会在某些时间段被超高并发的去访问，是一种非常“热点”的数据。这时候，需要考虑的到缓存击穿。 使用互斥锁(mutex key) 常用的做法，简单来说，就是在缓存时效的时候，不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，在进行load db的操作并回设缓存；否则就重试整个get缓存的方法。00 setnx当键key不存在的情况下，将键的key值设置为value，若已经存在就不做任何操作 12345678910111213141516public String get(key) &#123; String value = redis.get(key); if (value == null) &#123; //代表缓存值过期 //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db if (redis.setnx(key_mutex, 1, 3 * 60) == 1) &#123; //代表设置成功 value = db.get(key); redis.set(key, value, expire_secs); redis.del(key_mutex); &#125; else &#123; //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可 sleep(50); get(key); //重试 &#125; &#125; else &#123; return value; &#125; &#125; 缓存雪崩解决方案这个对底层系统的冲击特别可怕，大多数设计者都是通过加锁或者队列的方式来保证不会有大量线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开，在原有的失效时间上增加一个随机值。 1234567891011121314151617181920212223//伪代码public object GetProductListNew() &#123; int cacheTime = 30; String cacheKey = \"product_list\"; String lockKey = cacheKey; String cacheValue = CacheHelper.get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; else &#123; synchronized(lockKey) &#123; cacheValue = CacheHelper.get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; else &#123; //这里一般是sql查询数据 cacheValue = GetProductListFromDB(); CacheHelper.Add(cacheKey, cacheValue, cacheTime); &#125; &#125; return cacheValue; &#125;&#125; 加锁只是减轻数据库压力，并没有提高系统吞吐量，假设在高并发下，缓存重建期间key是锁着的，来10000个请求，9999个都在阻塞，会导致用户请求超时，治标不治本。 随机值代码： 1234567891011121314151617181920212223//伪代码public object GetProductListNew() &#123; int cacheTime = 30; String cacheKey = \"product_list\"; //缓存标记 String cacheSign = cacheKey + \"_sign\"; String sign = CacheHelper.Get(cacheSign); //获取缓存值 String cacheValue = CacheHelper.Get(cacheKey); if (sign != null) &#123; return cacheValue; //未过期，直接返回 &#125; else &#123; CacheHelper.Add(cacheSign, \"1\", cacheTime); ThreadPool.QueueUserWorkItem((arg) -&gt; &#123; //这里一般是 sql查询数据 cacheValue = GetProductListFromDB(); //日期设缓存时间的2倍，用于脏读 CacheHelper.Add(cacheKey, cacheValue, cacheTime * 2); &#125;); return cacheValue; &#125;&#125; 关于缓存雪崩的解决办法，有三种： 使用锁或队列，不过不建议，会降低用户体验 设置过期标志更新缓存 为key设置不同的缓存失效时间","categories":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/tags/redis/"}]},{"title":"生产者消费者模式","slug":"生产者消费者模式","date":"2020-07-10T04:52:39.000Z","updated":"2020-07-10T08:51:28.967Z","comments":true,"path":"2020/07/10/生产者消费者模式/","link":"","permalink":"http://wysblogs.top/2020/07/10/生产者消费者模式/","excerpt":"","text":"生产者消费者模式实现方式生产者消费者问题是线程模型中的经典问题；生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 保证同一时刻只有一个线程读或者写： 用synchronized对存储加锁，然后用object原生的wait()和notify()做同步 用concurrent.locks.Lock，然后用condition的await()和signal()做同步 使用信号量semaphore 保证存储内部的读写唯一 直接使用concurrent.BlockingQueue 使用PipedInputStream/PipedOutputStream synchronized、wait()、nofity() wait()：当缓冲区已满或者为空时，生产者/消费者线程停止自己的执行，放弃锁，让自己处于等待状态，让其他线程执行。 notify()：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 package org.example.test_wys;import java.util.LinkedList;import java.util.Queue;import java.util.Random;/** * @Author: wys * @Description: * @Date: 2020/7/10 16:03 * @FileName: Test_05 */public class Test_05 &#123; static int i = 0; static int size = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); public static void main(String[] args) &#123; Test_05 tt = new Test_05(); tt.new Producter(\"producter[1]\").start(); tt.new Producter(\"producter[2]\").start(); tt.new Consumer(\"consumer[1]\").start(); tt.new Consumer(\"consumer[2]\").start(); tt.new Consumer(\"consumer[3]\").start(); &#125; class Producter extends Thread &#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while (true) &#123; synchronized (queue)&#123; while(queue.size()==size)&#123; System.out.println(\"满了！\"+name+\"等待\"); try&#123; queue.wait(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(name+\" product===&gt;production_\"+i); queue.offer(\"production_\"+i); i++; queue.notifyAll(); &#125; try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; synchronized (queue)&#123; while(queue.isEmpty())&#123; System.out.println(\"空的！\"+name+\"等待\"); try&#123; queue.wait(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; String s = queue.poll(); System.out.println(name+\": consume=====&gt;\"+s); queue.notifyAll(); &#125; try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Lock、Condition、await()、signal()实现起来和上面一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package org.example.test_wys;import java.util.LinkedList;import java.util.Queue;import java.util.Random;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author: wys * @Description: * @Date: 2020/7/10 16:31 * @FileName: Test_06 */public class Test_06 &#123; static int i = 0; static int size = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); Lock lock = new ReentrantLock(); //可重入锁 Condition condition = lock.newCondition(); public static void main(String[] args) &#123; Test_06 tt = new Test_06(); tt.new Producter(\"producter[1]\").start(); tt.new Producter(\"producter[2]\").start(); tt.new Consumer(\"consumer[1]\").start(); tt.new Consumer(\"consumer[2]\").start(); tt.new Consumer(\"consumer[3]\").start(); &#125; class Producter extends Thread &#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while (true) &#123; lock.lock(); while(queue.size()==size )&#123; System.out.println(\"满了！\"+name+\"等待\"); try&#123; condition.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(name+\" product===&gt;production_\"+i); queue.offer(\"production_\"+i); i++; condition.signalAll();; lock.unlock(); try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; lock.lock(); while(queue.isEmpty())&#123; System.out.println(\"空的！\"+name+\"等待\"); try&#123; condition.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; String s = queue.poll(); System.out.println(name+\": consume=====&gt;\"+s); condition.signalAll(); lock.unlock(); try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; BlockingQueue在并发编程中，JUC中有一个接口BlockingQueue，有以下几个实现的阻塞队列： java.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue 我们可以使用FIFO队列，来实现生产消费者模型 在队列的基础上，使用Lock实现了同步队列，主要是两种方法， put()方法，容量达到最大时，自动阻塞。 take()方法，容量为0时，自动阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * @Author: wys * @Description: 生产者消费者模式 * @Date: 2020/7/10 12:51 * @FileName: Test_04 */public class Test_04 &#123; static int i = 0; static int size = 10; BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;String&gt;(10); public static void main(String[] args) &#123; Test_04 m = new Test_04(); m.new Producter(\"producter[1]\").start(); m.new Producter(\"producter[2]\").start(); m.new Consumer(\"consumer[1]\").start(); m.new Consumer(\"consumer[2]\").start(); m.new Consumer(\"consumer[3]\").start(); &#125; /** * 生产者 */ class Producter extends Thread&#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; try&#123; synchronized(blockingQueue) &#123; blockingQueue.put(\"producter_\"+i); System.out.println(name+\" product =====&gt; production_\"+i); i++; &#125; sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者 */ class Consumer extends Thread&#123; private String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; try&#123; System.out.println(name+\" consumer ====&gt;\"+blockingQueue.take()); sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; SemaphoreSemaphore信号量，可以控制对互斥资源的访问的线程数。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Main &#123; int i = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); Semaphore notFull = new Semaphore(10);//可以生产的数量，生产一个少一个 permit Semaphore notEmpty = new Semaphore(0);//可以消费的数量，消费一个多一个 permit Semaphore mutex = new Semaphore(1);//控制 queue 的互斥访问 //生产者 class Producter extends Thread&#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; notFull.acquire(); mutex.acquire(); queue.offer(\"production_\"+i); System.out.println(name+\"：product====&gt;production_\"+i); i++; mutex.release(); notEmpty.release(); sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; notEmpty.acquire(); mutex.acquire(); String s = queue.poll(); System.out.println(name+\"：consume====&gt;\"+s); mutex.release(); notFull.release(); sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Main main = new Main(); main.new Producter(\"producter[1]\").start(); main.new Producter(\"producter[2]\").start(); main.new Consumer(\"consumer[1]\").start(); main.new Consumer(\"consumer[2]\").start(); main.new Consumer(\"consumer[3]\").start(); &#125; &#125; PipedInputStream、PipedOutputStream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Main &#123; static int i = 0; static int size = 10; PipedInputStream pis = new PipedInputStream(size); PipedOutputStream pos = new PipedOutputStream(); &#123; try &#123; pis.connect(pos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Main main = new Main(); main.new Producter(\"producter[1]\").start(); main.new Producter(\"producter[2]\").start(); main.new Consumer(\"consumer[1]\").start(); main.new Consumer(\"consumer[2]\").start(); main.new Consumer(\"consumer[3]\").start(); &#125; //生产者 class Producter extends Thread&#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; synchronized (pos) &#123;//避免产生相同名称的产品，如果不在意可以去掉 pos.write(i); pos.flush(); System.out.println(name+\"：product====&gt;production_\"+i); i++; &#125; sleep(new Random().nextInt(1000)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; System.out.println(name+\"：consume====&gt;production_\"+pis.read()); sleep(new Random().nextInt(3500)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://wysblogs.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://wysblogs.top/tags/设计模式/"}]},{"title":"dubbo基础","slug":"dubbo基础","date":"2020-07-08T23:21:36.000Z","updated":"2020-07-20T02:59:22.935Z","comments":true,"path":"2020/07/09/dubbo基础/","link":"","permalink":"http://wysblogs.top/2020/07/09/dubbo基础/","excerpt":"","text":"Dubbo基础介绍Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。 dubbo是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。 使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。 Dubbo通信协议Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低 与spring cloud区别 协议支持类型 dubbo://（推荐） rmi:// hessian:// http:// webservice:// thrift:// memcached:// redis:// rest:// 需要web容器吗不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。 内置了几种服务容器 Spring Container Jetty Container Log4j Container Dubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。 节点角色 流程图 注册中心推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。 配置方式1）Spring 配置方式2）Java API 配置方式 Dubbo启动时如果依赖的服务不可用会怎样？Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=”true”，可以通过 check=”false” 关闭检查。 Dubbo支持服务多协议吗？Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。 当一个服务接口有多种实现时怎么做？当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。 Dubbo优点 透明的远程化调用，就像调用本地方法一样调用远程方法，只需要简单的配置，没有任何api侵入 软负载均衡及容错机制 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。","categories":[{"name":"dubbo","slug":"dubbo","permalink":"http://wysblogs.top/categories/dubbo/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://wysblogs.top/tags/dubbo/"}]},{"title":"如何开始阅读框架源码？","slug":"如何开始阅读框架源码？","date":"2020-07-01T16:31:47.000Z","updated":"2020-07-04T03:27:28.469Z","comments":true,"path":"2020/07/02/如何开始阅读框架源码？/","link":"","permalink":"http://wysblogs.top/2020/07/02/如何开始阅读框架源码？/","excerpt":"","text":"如何开始阅读框架源码？ 1、首先学习阅读中所需要的基础的知识 2、要带着目的去阅读 3、看一看官方文档 4、要学会使用这个框架 5、了解整体模块架构设计 6、从高到底梳理每一个模块 7、一直到可以运行起来 1、基础知识在学习某种框架之前，一定要确保自己掌握了部分基础知识，例如这个java基础，设计模式等等，确保自己能够理解这个框架最深层所隐藏的知识或者技术。 2、确定目的一定要清楚自己阅读源码是为了干什么，是为了解决工作中出现的问题，还是为了学习框架的中所蕴含的知识，亦或是想了解这个框架所需要应用的业务场景。 3、官方文档官方文档很重要，它能让你对这个框架有个大概的了解，以及每个模块的各个作用与联系，之后再把整体框架架构。 4、学会使用了解一下这个框架的基本用法，官网都应该有 Quick Start，先运行运行demo，再测试一些其他高级功能，知道这个框架究竟是怎么使用的。 5、框架架构了解框架的设计模式，和设计思路，然后思考思考去猜一猜这样写有什么用，之后顺着思路往下走。 6、从顶至下学框架一定要从上往下分析各个模块的作用和功能，分清各个主次关系，理清逻辑。 7、运行起来最后一点一点的运行出来，至此，大概就可以很大程度上的去理解这个框架的思想。 8、不懂就问如果遇到不明白的地方，可以去各个论坛，各个帖子去百度，去询问，也可以去查看官方文档，把搞懂，才能受益匪浅。","categories":[{"name":"经验","slug":"经验","permalink":"http://wysblogs.top/categories/经验/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://wysblogs.top/tags/经验/"}]},{"title":"并发基础知识点","slug":"并发基础知识点","date":"2020-07-01T13:44:31.000Z","updated":"2020-07-18T01:43:48.562Z","comments":true,"path":"2020/07/01/并发基础知识点/","link":"","permalink":"http://wysblogs.top/2020/07/01/并发基础知识点/","excerpt":"","text":"并发基础知识点并发和并行 并发是多个事件在同一时刻，并行是多个事件在同一时间段 并行是多个实体的多个事件，并发是一个实体的多个事件 并行不会抢占资源，并发会抢占资源 线程和进程进程进程就是程序的一次执行过程，是系统运行的基本单位。 比如运行一次java程序，实际上就是启动了一次jvm进程 而main函数其实就是这个进程中的一个线程，也成为主线程。 进程进程和线程相似，但是线程是比进程更小的执行单位。 一个进程可以产生多个线程。 同类的多个线程共享进程的堆和方法区资源。 每个线程有自己的程序计数器、虚拟机栈、本地方法栈。 各个线程之间切换工作时负担比进程小，因此线程也被称为轻量级进程。 查看线程信息： 123456789101112131415161718192021package org.example.thread;import java.lang.management.ManagementFactory;import java.lang.management.ThreadInfo;import java.lang.management.ThreadMXBean;/** * @Author: wys * @Description: * @Date: 2020/7/17 10:26 * @FileName: ThreadInfoDemo */public class ThreadInfoDemo &#123; public static void main(String[] args) &#123; ThreadMXBean thread = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = thread.dumpAllThreads(false,false); for(ThreadInfo i : threadInfos)&#123; System.out.println(\"ID:\"+i.getThreadId()+\",Name:\"+i.getThreadName()); &#125; &#125;&#125; 123456ID:6,Name:Monitor Ctrl-BreakID:5,Name:Attach ListenerID:4,Name:Signal DispatcherID:3,Name:FinalizerID:2,Name:Reference HandlerID:1,Name:main 线程与进程的关系线程在JVM中的模型 线程的分类用户线程：程序中创建的线程 守护线程：为用户线程提供服务的线程，一般用户线程结束时才被终止，如JVM的垃圾回收 通过Thread.setDaemon(true)方法将用户进程变成守护进程。 线程周期和状态线程的生命周期 线程的状态 图中 wait到 runnable状态的转换中，join实际上是Thread类的方法，但这里写成了Object 线程常用的方法12345678//线程休眠：让当前线程暂时停止运行，一段时间后继续执行，保证线程安全Thread.sleep();//线程让步：主动放弃占用的cpu资源，转变为就绪状态，让其他线程先执行Thread.yield();//线程阻塞：让指定线程先执行，执行完之后才能执行，可以实现多个线程的顺序执行join();//获取当前线程状态Thread.currentThread(); 什么是上下文切换通俗来说，因为CPU在任意时刻只能被一个线程使用，为了保证每个线程都能充分的得到利用，因此采用分配时间片并轮转的方式来保证线程执行。 切换时间片时会保存当前执行状态，下次获取时间片的时候继续执行，这个过程称为上下文切换，就是任务保存并重新加载的过程就是一次上下文切换。 这个也是操作系统中最消耗时间的操作了。","categories":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/categories/并发/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/tags/并发/"}]},{"title":"Serializable知识点","slug":"Serializable知识点","date":"2020-07-01T00:26:24.000Z","updated":"2020-07-01T06:49:37.363Z","comments":true,"path":"2020/07/01/Serializable知识点/","link":"","permalink":"http://wysblogs.top/2020/07/01/Serializable知识点/","excerpt":"","text":"Serializable知识点Serializable接口简介一个对象序列化接口，一个类只有实现了Serializable接口，它的对象才能被序列化。 什么是序列化序列化是对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以很容易的去存储和传输数据。 序列化：把对象转换为字节序列的过程称为对象的序列化 反序列化：把字节序列恢复为对象的过程称为对象的返序列化 什么情况下需要序列化1、网络进行传输 2、需要对象的状态信息持久化 为什么要定义serialversionUID变量1、如果我们没有自己声明一个serialVersionUID变量,接口会默认生成一个serialVersionUID 2、建议用户自定义一个UID，默认的UID对class细节很敏感，反序列化时可能会导致InvalidClassException 3、序列化后的数据中UID与当前类中的UID一直才能被反序列化成功，否则可能是成员变量的数量或者类型发生了变化，反序列化时就会发生crash，可能就会发生异常","categories":[{"name":"Serializable","slug":"Serializable","permalink":"http://wysblogs.top/categories/Serializable/"}],"tags":[{"name":"Serializable","slug":"Serializable","permalink":"http://wysblogs.top/tags/Serializable/"}]},{"title":"java基础面试知识","slug":"java基础面试知识","date":"2020-05-11T02:36:58.000Z","updated":"2020-07-09T14:01:10.304Z","comments":true,"path":"2020/05/11/java基础面试知识/","link":"","permalink":"http://wysblogs.top/2020/05/11/java基础面试知识/","excerpt":"","text":"Java基础面试知识（持续更新）HashMap，ConcurrentHashMap，Hashtable的数据结构HashMap介绍 HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null 值， 因为key不允许重复，因此只能有一个键为null,另外HashMap不能保证放入元素的顺序，它是无序的，和放入的顺序并不能相同。HashMap是线程不安全的。 HashMap扩容特别耗时，如果能估算大小，最好给它一个默认的初始值，避免进行多次扩容，HashMap线程不安全，多线程状态下应使用ConcurrentHashMap。 如果在多线程状态下想要使用HashMap需要使用Conllections.synchronizedMap()方法获取一个线程安全的Map集合，就是在操作HashMap的时候会自动给方法添加synchronized 关键字来保证线程安全性。 数据结构 HashMap在1.8之前使用的是 数组+链表，1.8之后使用的是 数组+链表+红黑树，当链表长度超过阈值8的时候，将链表转换为红黑树，性能得到提升。 Hashtable介绍 和HashMap基本一样。 对比HashMap Hashtable线程安全，HashMap线程不安全 Hashtable不能使用null作为key，HashMap可以用null作为key HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。 HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。 HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1。 Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模 HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸。 ConcurrentHashMap介绍 在1.8之前采用锁分段技术来保证性能，锁分段技术就是把存储空间分为许多段，然后给每个段都上锁，这样确保在访问某一段的代码时，不会阻塞其他段的访问，提高了性能。 1.8之后，抛弃了锁分段技术，采用了CAS + synchronized 来保证并发更新的安全性。 CAS：Compare and Swap，即比较再交换。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。 CAS的缺点：CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。 循环时间长开销很大。只能保证一个变量的原子操作。ABA问题。 循环时间长开销很大：CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。 只能保证一个变量的原子操作：当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。 什么是ABA问题？ABA问题怎么解决？如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？ 如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。 总结 Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。 ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。 应该根据具体的应用场景选择合适的HashMap。 Hash函数 加法Hash 位运算Hash 乘法Hash 除法Hash 查表Hash 混合Hash 数组Hash equals和hashcode1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 equals 它的性质有： 自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。 对于Object类来说，equals()方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非null的引用值x和y，当且仅当x和y引用的是同一个对象，该方法才会返回true。 需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。 hashcode 1.如果两个对象相同，那么它们的hashCode值一定要相同；2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。 如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。 反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 String为什么是final修饰","categories":[{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/tags/面试/"}]},{"title":"redis面试知识","slug":"redis面试知识","date":"2020-05-11T02:36:49.000Z","updated":"2020-07-11T13:18:07.442Z","comments":true,"path":"2020/05/11/redis面试知识/","link":"","permalink":"http://wysblogs.top/2020/05/11/redis面试知识/","excerpt":"","text":"Redis面试知识（持续更新） 参考如下： https://blog.csdn.net/chenyao1994/article/details/79491337 https://blog.csdn.net/u012240455/article/details/81843714 https://www.jianshu.com/p/3677afe376ee redis是什么Redis 是一个c语言编写，开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 redis为什么那么快 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速，数据存在内存中，类似于HashMap，查找和操作时间复杂度都是O(1) 数据结构简单，对数据操作也比较简单 采用单线程，避免了上下文切换和竞争条件，不存在多线程切换导致消耗cpu，不用去考虑各种锁的问题，避免了因锁产生的性能消耗 使用多路I/O复用模型，非阻塞IO 使用底层模型不同，它们之间底层实现方式以及客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用函数的话，会浪费一定的时间去移动和请求 多路I/O复用模型 多路I/O复用模型是利用select，poll，epoll可以同时监察多个流的I/O事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。 redis为什么是单线程因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了 redis哨兵机制什么是哨兵机制redis哨兵机制(sentinel)系统用于管理多个redis服务器，主要执行三个任务： 监控(Monitoring)：哨兵会不断的检查你的Master和Slave是否运作正常 提醒(Notification)：当被监控的某个redis出现问题，哨兵可以通过api向管理员或者其他应用程序发送通知 自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵会开始一次自动故障迁移操作，他会将失效Master的其中一个Slave升级成为新的Master，并让失效的Master的其他Slave改为复制新的Master，当客户端试图连接失效的Master时，集群也会向客户端返回新的Master的地址，使得集群可以使用Master代替失效的Master。 哨兵是一个分布式系统，你可以在一个架构中运行多个哨兵进程，这些进程使用流言协议(gossipprotocols)来接收关于Master是否下线的信息,并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。 每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave定时发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master”彻底死亡”(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。 虽然哨兵(sentinel) 释出为一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动哨兵(sentinel)。 哨兵(sentinel) 的一些设计思路和zookeeper非常类似 总结哨兵是redis集群架构中非常重要的一个组件，作用如下： 集群监控：负责监控redis master和slave进程是否正常工作 消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员 故障转移：如果master node，会自动转移到slave node上 配置中心：如果故障转移发生了，通知client客户端新的master地址 哨兵本身也是分布式的，作为一个哨兵集群去运行的，相互协同工作 (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。(2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。 redis内存淘汰机制volatile-lru从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。redis并不是保证取得所有数据集中最近最少使用的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。 volatile-ttl从已设置过期时间的数据集中挑选将要过期的数据淘汰。redis 并不是保证取得所有数据集中最近将要过期的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。 volatile-random从已设置过期时间的数据集中任意选择数据淘汰。当内存达到限制的时候无法写入非过期时间的数据集。 allkeys-lru从数据集中挑选最近最少使用的数据淘汰。当内存达到限制的时候，对所有数据集挑选最近最少使用的数据淘汰，可写入新的数据集。 allkeys-random从数据集中任意选择数据淘汰，当内存达到限制的时候，对所有数据集挑选随机淘汰，可写入新的数据集。 no-enviction当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错。 redis集群的CAPCAP理论 C:consistency(一致性) A:avalibility(可用性) P:Partition(分区)-tolerence to partition(分区容忍度) CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 redis发布订阅 命令 描述 PUBLISH channel message 将信息发送到指定的频道。 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息 PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 应用场景1、构建实时消息系统，比如普通的即时聊天，群聊等功能。 2、微信的公共号订阅消息推送等 redis和Mysql同步一、对强一致要求比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存的设置过期(建议不要去更新缓存内容，直接设置缓存过期)。 二、对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。 三、使用阿里的同步工具canal，canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。 四、采用UDF自定义函数的方式，面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++语言实现，学习成本高。 redis分布式session结构 原理由于Http连接是无状态的，所以使用Tomcat做服务器的时候Tomcat内部会维护一个Session用来保存客户端的状态，一般情况下每个客户端都有一个cookie里面保存着叫jsessionid的cookie，每次访问tomcat的时候都会携带上，Tomcat可以根据这个jsessionid找到对应的session。 使用Redis作为session存储容器，登录时将session信息存储至cookie客户端，同时服务端将session信息存至redis缓存，双重保障，接下来的接口调用直接可以获取到cookie中的token信息作为参数传递进来即可，如果发现token为空，则再从redis中获取，如果两者都为空，则说明session已过期。 redis集群如何部署 gossip协议Gossip是一种去中心化、容错并保证最终一致性的协议。 redis集群使用的服务 Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播 引用 https://blog.csdn.net/renooon/article/details/73834598 redis和memcache的区别1、数据操作不同 与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能。Redis支持服务器端的数据操作相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，支持list、set、sorted set、hash等众多数据结构，还同时提供了持久化和复制等功能。 而通常在Memcached里，使用者需要将数据拿到客户端来进行类似的修改再set回去，这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作， Redis会是更好的选择。 2、内存管理机制不同 在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。 而Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。 从内存利用率来讲，使用简单的key-value存储的话，Memcached的内存利用率更高。而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 3、性能不同 由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。 4、集群管理不同 Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。 Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。 https://www.php.cn/redis/423024.html Redis持久化操作redis是基于内存的数据库，提供了两种形式进行持久化 RDBRDB是redis默认的持久化形式，本质就是把redis的数据以快照的形式保存到磁盘中。 RDB持久化是指在指定的时间间隔内，将内存中的数据快照写入磁盘，本质是将内存中的数据写入到二进制文件中，默认的文件名是dump.rdb RDB机制的三种触发方式1、save触发方式该命令会阻塞当前的redis服务器，执行save命令期间，redis不能处理其他命令，知道rdb过程完成之后，执行过程中，如果遇到老的rdb文件，就用新的替代掉旧的，但是这种方法一般不可取。 2、bgsave触发方式执行该命令后，redis会在后台异步进行快照操作，进行快照操作的同时还能响应客户端请求 具体操作就是redis进行fork时候创建一个子进程，rdb持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一半时间很短，redis大多数采用的都是这样的触发方式。 3、自动触发一般在配置文件中配置，主要还是使用上面两种触发方式 AOF1、持久化原理由于全量备份总是特别耗时，这时候就需要用到AOF了，AOF工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中，通俗来说就是日志记录。 2、文件重写原理redis提供了bgrewriteof命令，将内存中的数据以命令的形式保存到临时文件中，同时fork出一条新的子线程来将文件重写。 而且，重写操作没有读取旧的aof文件，而是重写了一个新的aof文件 3、三种触发方式 每次修改都同步写入(always)，同步持久化，性能差，数据完整性好。 每秒同步(everysec)，异步操作，每秒记录，如果发生宕机，会丢失数据。 不同步(no)，从不同步。 两者对比 一般来说，通常都是两者一起使用会比较好 根据需求来判断是最合适的。","categories":[{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/tags/面试/"}]},{"title":"Spring面试知识","slug":"Spring面试知识","date":"2020-05-08T00:57:50.000Z","updated":"2020-05-17T12:20:46.615Z","comments":true,"path":"2020/05/08/Spring面试知识/","link":"","permalink":"http://wysblogs.top/2020/05/08/Spring面试知识/","excerpt":"","text":"Spring面试知识（持续更新）1、Spring是什么","categories":[{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/tags/面试/"}]},{"title":"Netty面试知识","slug":"Netty面试知识","date":"2020-05-05T05:03:30.000Z","updated":"2020-05-05T15:24:00.033Z","comments":true,"path":"2020/05/05/Netty面试知识/","link":"","permalink":"http://wysblogs.top/2020/05/05/Netty面试知识/","excerpt":"","text":"Netty面试知识Netty是什么Netty是一个基于NIO的网络通信框架 NIO是从java1.4版本开始引入的一个新的IO API SelectableChannelSelectableChannel 是 jdk1.4引入的nio包中一个有用的抽象类，SelectableChannel可以让程序员避免编写大量阻塞式的代码，特别是在高并发的交互式网络编程中，作用尤其明显。 BIO、NIO、AIO的区别？ BIO：一个连接一个线程，客户端有连接请求时服务器就需要启动一个线程，线程开销大。 NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 通道（Channel）：负责传输Buffer 缓冲区（Buffer）：负责数据的存取 多路复用器（selector）： 多路复用器，用于监控SelectableChannel的IO状况 与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel类和ServerSocketChannel两种不同的套接字实现，都支持阻塞和非阻塞模式，阻塞模式简单，但是性能和可靠性不行，非阻塞模式与此相反，一般低负载，低并发使用同步阻塞IO降低复杂度，对于高负载，高并发还是要用NIO的非阻塞模式。 简单来说，Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生了读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取到就绪Channel的集合，进行后续操作； SocketChannel是一个连接到TCP网络套接字的通道 ServerSocketChannel是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。 DatagramChannel主要针对UDP 管道（Pipe）： JAVA NIO 管道是两个线程之间的单向数据连接 Pipe有一个source通道和一个sink通道，数据会被写到sink通道，从source通道读取。 NIO编程的优点: 1、客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECTION等待后续结果，不需要像之前的客户端那样被同步阻塞。 2、SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样IO通信线程就可以处理其他的链路，不需要同步等待这个链路可用了。 3、线程模型的优化，由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者对单个进程的句柄限制），意味着Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降，因此，它非常适合做高性能，高负载的网络服务器。 epoll： epoll是为处理大批量句柄而作了改进的poll，是性能最好的多路I/O就绪通知方法 只有三个系统调用： 1、epoll_create：创建一个poll实例，文件描述符 2、epoll_ctl：将监听的文件描述符添加到epoll实例中，实例代码为将标准输入文件描述符添加到epoll中 3、epoll_wait：等待epoll事件从epoll实例中发生，并返回事件以及对应文件描述符 两种事件模型： 1、水平触发： socket接受缓冲区不为空，有数据可读，读事件一直触发 socket发送缓冲区不满，可以继续写入数据，写事件一直触发 2、边沿触发 socket的接受缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发事件 socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出时间时触发读事件 边沿触发仅触发一次，水平触发会一直触发 高效原理： 当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以epoll_wait非常高效 高效本质： 减少了用户态和内核态的文件句柄拷贝 减少了可读可写文件句柄的遍历 mmap加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝 I/O性能不会随着监听的文件描述的数量增长而下降 使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多空间。 AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。 JDK1.7升级了NIO类库，升级后的NIO类库被称为NIO2.0，这个版本中Java正式提供了异步文件IO操作，同时提供了与UNIX网络编程事件驱动IO对应的AIO； BIO和NIO区别 1、BIO是面向流的，NIO是面向缓冲区的 2、BIO的各种流是阻塞的，而NIO是非阻塞的； 3、BIO的Stream是单向的，而NIO的Channel是双向的 NIO的特点： 1、事件驱动模型 2、单线程处理多任务 3、非阻塞I/O，I/O读写不在阻塞，而是返回0 4、基于block的传输比基于流的传输更高效 5、更高级的IO函数zero_copy 6、IO多路复用大大提高了java网络应用的可伸缩性和实用性 7、基于Reactor线程模型 Reactor模式 1、Reactor模式是什么？ Reactor模式也叫反应器模式，是一种典型的事件驱动的编程模型 Reactor模式逆置了程序处理流程 Reactor组件： 负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包括连接建立就绪，都就绪，写就绪 Handler组件 将自身与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel 2、Reactor事件处理机制： 1、主程序将事件以及对应事件处理的方法在Reactor上进行注册，如果相应的事件发生，Reactor将会主动调用事件注册的接口，即回调函数 2、Redis中基于I/O多路复用开发Reactor事件处理机制，读事件绑定读操作和具体执行命令的操作函数，写事件绑定命令自动回复的操作函数 3、Reactor编程优点 1、响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的 2、编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销 3、可扩展性，可以方便的通过增加Reactor实例个数来充分利用cpu资源 4、可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性 4、Reactor编程缺点 1、相比传统的简单模型，Reactor增加了一定的复杂性，因而具有一定门槛，并且不易于调试 2、Reactor模式需要底层的多路复用支持，比如java中的selector，操作系统的select系统调用支持 3、Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，共享Reactor的Channel如果有一个出现长时间的数据读写，还会影响其这个Reactor中其他的Channel，这时候就需要使用改进版的Reactor模式，Proactor模式。 5、Reactor三种角色 Reactor，将I/O事件分派给对应的Handler Acceptor，处理客户端新连接，并分派请求到处理链中 Handlers，执行非阻塞 读/写 任务 阻塞和非阻塞 传统IO流都是阻塞的 当一个线程调用read()或者write()时，该线程被阻塞，直到一些数据被读取，或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO操作时，由于线程会被阻塞，所以服务器端必须为每个客户端提供一个独立的线程进行处理，当服务端要处理大量客户端时，性能就会下降的严重。 NIO 是非阻塞模式的 当线程从某通道进行读写数据时，若没有数据可用时，该线程可以处理其他事，线程通常将非阻塞IO的空闲时间用于其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道，因此NIO可以使用一个或几个线程来同时处理连接到服务器端的所有客户端 NIO的组成 Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的 flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式 clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。 rewind方法 ： 重绕此缓冲区，将position置为0 DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。 Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！ Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。 Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。 fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。 Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取 NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件 Netty的特点 一个高性能，异步事件驱动的NIO框架，它提供了对TCP，UDP和文件传输的支持 使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式 采用多种decoder/encoder支持，对TCP粘包/分包进行了自动化处理 可使用接受/处理线程池，提高连接效率，对重连，心跳检测的简单支持 可配置IO线程数，TCP参数，TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuff 通过引用计数器及时申请释放不在引用的对象，降低了GC频率 使用单线程串行化的方式，搞笑的Reactor线程模型 大量使用了volitale、使用了CAS和源自类、线程安全类的使用、读写锁的使用","categories":[{"name":"Netty","slug":"Netty","permalink":"http://wysblogs.top/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://wysblogs.top/tags/Netty/"}]},{"title":"常用算法模板","slug":"常用算法模板","date":"2020-05-02T08:02:12.000Z","updated":"2020-05-02T08:03:50.647Z","comments":true,"path":"2020/05/02/常用算法模板/","link":"","permalink":"http://wysblogs.top/2020/05/02/常用算法模板/","excerpt":"","text":"常用算法模板整理八大排序算法 冒泡排序12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/* 思路： 将大数交换到右边 */void bubble_sort(int arr[], int len) &#123; for(int i=0;i&lt;len-1;i++) &#123; for(int j=0;j&lt;len-1-i;j++) &#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr[j],arr[j+1]); &#125; &#125; &#125; &#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; bubble_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; printf(\"%d \",arr[i]); &#125; return 0;&#125; 快排1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;void quick_sort(int arr[], int left, int right) &#123; //如果左边大于右边说明已经找不到可以互换的了，排序结束 if(left&gt;right)&#123; return; &#125; //基准 int temp = arr[left]; //i,j分别等于边界值，t用来交换值 int i=left,j=right,t; while(i!=j)&#123; //判断左右是否大于或者小于基准 while(arr[j]&gt;=temp&amp;&amp;i&lt;j)&#123; j--; &#125; while(arr[i]&lt;=temp&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; //排序结束进行基准归位 //基准和最左边的数交换位置 arr[left] = arr[i]; arr[i] = temp; //归位后进行排除头和尾进行下次交换 quick_sort(arr,left,j-1); quick_sort(arr,i+1,right); &#125;int main()&#123; int arr[5] = &#123;5,7,3,1,4&#125;; quick_sort(arr,0,4); for(int i=0;i&lt;5;i++)&#123; printf(\"%d \",arr[i]); &#125; return 0; &#125; 插入排序12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void insert_sort(int arr[],int length)&#123; /* 思路：在第i个元素开始向右查找，遇到左边大于右边的就交换位置 每次循环都需要把一个最小元素移动到数组左边 */ for(int i=0;i&lt;length;i++)&#123; for(int j=i;j&gt;0&amp;&amp;arr[j-1]&gt;arr[j];j--)&#123; swap(arr[j-1],arr[j]); &#125; &#125; &#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; insert_sort(arr,5); for(int i=0;i&lt;5;i++)&#123; printf(\"%d \",arr[i]); &#125;&#125; 希尔排序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/* 希尔排序思路： 根据增量把数组分成几个小数组 插入排序完成后慢慢减小增量 使得数组在有一定顺序的基础上继续排序 提高排序效率 */void shell_sort(int arr[], int length)&#123; int N = length; //最外层的控制增量 for(int gap=N/2;gap&gt;0;gap/=2)&#123; //对每个组进行插入排序 for(int i=gap;i&lt;N;i++)&#123; //将arr[i]插入到正确的位置 int v = arr[i]; int j; //插入的时候按组进行插入（组内元素两两相隔gap） for(j=i-gap;j&gt;=0&amp;&amp;v&lt;arr[j];j-=gap)&#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = v; &#125; &#125;&#125;int main()&#123; int arr[8] = &#123;5,7,1,4,3,9,6,2&#125;; int len = 8; shell_sort(arr,len); for(int i=0;i&lt;len;i++)&#123; printf(\"%d \",arr[i]); &#125; return 0;&#125; 插入排序1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/* 选择排序思路： 每次把最小的选出来放到前边 */void select_sort(int arr[],int len)&#123; for(int i=0;i&lt;len;i++)&#123; int minn = i; for(int j=i+1;j&lt;len;j++)&#123; if(arr[j]&lt;arr[minn])&#123; minn = j; &#125; &#125; swap(arr[minn],arr[i]); &#125;&#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; select_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; printf(\"%d \",arr[i]); &#125; return 0;&#125; 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//建立父节点和子节点 void max_heapify(int arr[], int start, int end) &#123; //建立父节点指标和子节点指标 int f = start; int s = f*2+1; //若子节点指标在范围内才做比较 while(s&lt;=end)&#123; //先比较两个子节点大小，选择最大的 if(s+1&lt;=end&amp;&amp;arr[s]&lt;arr[s+1])&#123; s++; &#125; //如果父节点大于子节点则表示调整完毕，直接跳出循环 if(arr[f]&gt;arr[s])&#123; return; //佛瑞泽交换父子内容再继续子节点和孙节点比较 &#125;else&#123; swap(arr[f],arr[s]); f = s; s = f*2+1; &#125; &#125; &#125; //堆排序 void heap_sort(int arr[],int len) &#123; //初始化，i从最后一个父节点开始调整 for(int i=len/2-1;i&gt;=0;i--)&#123; max_heapify(arr,i,len-1); &#125; //先将第一个元素和已经排好的元素前一位做交换，再重新调整，直到排序完成 for(int i=len-1;i&gt;0;i--)&#123; swap(arr[0],arr[i]); max_heapify(arr,0,i-1); &#125;&#125;int main()&#123; int arr[10] = &#123;3,5,3,0,8,6,1,5,4,9&#125;; heap_sort(arr,10); for(int i=0;i&lt;10;i++)&#123; printf(\"%d \",arr[i]); &#125; return 0;&#125; 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; /* 归并排序思路： 一直分隔，直到剩最后一个然后归并进行排序 */void merge(int arr[], int l, int r, int mid)&#123; int aux[r-l+1],i,j,k; for(k=l;k&lt;=r;k++) &#123; aux[k-l] = arr[k]; &#125; i = l; j = mid + 1; for(k=l;k&lt;=r;k++) &#123; if(i&gt;mid)&#123; arr[k] = aux[j-l]; j++; &#125;else if(j&gt;r) &#123; arr[k] = aux[i-l]; i++; &#125;else if(aux[i-l]&gt;aux[j-l])&#123; arr[k] = aux[j-l]; j++; &#125;else&#123; arr[k] = aux[i-l]; i++; &#125; &#125;&#125;void merge_sort(int arr[], int l, int r)&#123; if(l&gt;=r) &#123; return; &#125; int mid = (l+r)/2; merge_sort(arr,l,mid); merge_sort(arr,mid+1,r); merge(arr,l,r,mid); &#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; merge_sort(arr,0,4); for(int i=0;i&lt;5;i++) &#123; printf(\"%d \",arr[i]); &#125; return 0;&#125; 快速幂1234567891011121314151617181920212223242526#include&lt;iostream&gt;#define ll long longusing namespace std;//迭代运算，把值转化成二进制进行迭代 ll pow_mod(ll a, ll b, ll mod) &#123; //求(a^b)%mod次方 ll ans = 1; while(b&gt;0)&#123; //如果b为奇数 //类似于 b % 2 == 1 if(b&amp;1)&#123; ans = ans * a % mod; &#125; //a的平方 a = a * a % mod; //b右移相当于b/2 b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; printf(\"%d\",pow_mod(2,3,1000)); return 0;&#125; 最长递增子序列和123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int main()&#123; int n; int ans = 0; int dp[1005]; int num[1005]; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;num[i]); &#125; dp[0] = 1; int x = 0; for(int i=0;i&lt;n;i++) &#123; ans = 0; for(int j=0;j&lt;i;j++) &#123; ans = 0; for(int j=0;j&lt;i;j++) &#123; if(num[i]&gt;num[j]) &#123; ans = max(dp[j],ans); &#125; &#125; dp[i] = ans + 1; if(dp[i]&gt;x) x = dp[i]; &#125; &#125; printf(\"%d\",x); return 0;&#125; 最长公共子序列123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;char x[1005],y[1005];int dp[1005][1005];int main()&#123; scanf(\"%s %s\",x+1,y+1); x[0] = y[0] = '.'; int len = strlen(x)&gt;strlen(y)?strlen(x):strlen(y); for(int i=0;i&lt;=len;i++) &#123; dp[i][0] = dp[0][i] = 0; &#125; for(int j,i=1;i&lt;strlen(x);i++) &#123; for(int j=1;j&lt;strlen(y);j++) &#123; if(x[i] == y[j]) &#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = dp[i-1][j]&gt;dp[i][j-1]?dp[i-1][j]:dp[i][j-1]; &#125; &#125; &#125; printf(\"%d\",dp[strlen(x)-1][strlen(y)-1]); return 0;&#125; 最长公共上升子序列1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,m;ll p[1005],q[1005],ans,dp[1005][1005];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;p[i]); cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)scanf(\"%lld\",&amp;q[i]); for(int i=1;i&lt;=n;i++) &#123; ll cur = 0; for(int j=1;j&lt;=m;j++) &#123; dp[i][j] = dp[i-1][j]; if(p[i]&gt;q[j]&amp;&amp;dp[i-1][j]&gt;cur) cur = dp[i-1][j]; if(p[i]==q[j]) dp[i][j] = cur+1; &#125; &#125; for(int i=1;i&lt;=m;i++)ans=max(ans,dp[n][i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 并查集1234567891011121314int pre[maxn];int find(int x) &#123; if(pre[x]!=x)&#123; pre[x] = find(pre[x]); &#125; return pre[x];&#125;void join(int x, int y) &#123; int fx = find(x); int fy = find(y); if(fx!=fy)&#123; pre[fx] = fy; &#125;&#125; DFS遍历图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;const int INF = 65535;int map[1005][1005];int Ne,Nv;int visited[1005];void DFS(int n)&#123; visited[n] = 1; printf(\"%d \",n); for(int i=0;i&lt;Nv;i++) &#123; if((visited[i]!=1&amp;&amp;map[n][i]!=INF))&#123; DFS(i); &#125; &#125;&#125;int main()&#123; int a,b; //先输入点，在输入边 scanf(\"%d %d\",&amp;Nv,&amp;Ne); for(int i=0;i&lt;Nv;i++) &#123; for(int j=0;j&lt;Nv;j++) &#123; map[i][j] = INF; &#125; visited[i] = 0; &#125; for(int i=0;i&lt;Ne;i++) &#123; scanf(\"%d %d\",&amp;a,&amp;b); map[a][b] = map[b][a] = 1; &#125; for(int i=0;i&lt;Nv;i++) &#123; if(!visited[i]) DFS(i); &#125; return 0;&#125;/* 测试数据8 60 70 12 04 12 43 5 结果0 1 4 2 7 3 5 6 */ DFS全排列123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int visit[11],num[11];int n;void dfs(int depth) &#123; if(depth&gt;n)&#123; for(int j=1;j&lt;=n;j++) &#123; cout&lt;&lt;num[j]&lt;&lt;\"\"; &#125; cout&lt;&lt;endl; &#125;else&#123; for(int i=1;i&lt;=n;i++) &#123; if(!visit[i])&#123; visit[i] = 1; num[depth] = i; dfs(depth+1); visit[i] = 0; &#125; &#125; &#125;&#125; int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; visit[i] = 0; &#125; dfs(1); return 0;&#125; BFS遍历图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#define INF 65535using namespace std;int map[1005][1005];int Nv,Ne;int visited[1005];void BFS(int n)&#123; int que[Nv]; int head = 0; int tail = 0; que[tail++] = n; visited[n] = 1; while(head!=tail) &#123; int m = que[head++]; printf(\"%d \",m); for(int i=0;i&lt;Nv;i++)&#123; if(visited[i]!=1&amp;&amp;map[m][i]!=INF)&#123; que[tail++] = i; visited[i] = 1; &#125; &#125; &#125;&#125;int main()&#123; int a,b; cin&gt;&gt;Nv&gt;&gt;Ne; for(int i=0;i&lt;Nv;i++)&#123; for(int j=0;j&lt;Nv;j++)&#123; map[i][j] = INF; &#125; visited[i] = 0; &#125; for(int i=0;i&lt;Ne;i++)&#123; cin&gt;&gt;a&gt;&gt;b; map[a][b] = map[b][a] = 1; &#125; for(int i=0;i&lt;Nv;i++)&#123; if(!visited[i])&#123; BFS(i); &#125; &#125; return 0;&#125;/* 测试用例8 60 70 12 04 12 43 5结果0 1 2 7 4 3 5 6 */ BFS最短迷宫路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;queue&gt;#define INF 65535using namespace std;int vis[100][100];//路径长度 int map[100][100];//迷宫地图 typedef pair&lt;int,int&gt; P; //节点坐标 P p; int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,1,0,-1&#125;;int sx = 0,sy = 0; //起始坐标 int ex = 4,ey = 4; //出口坐标int N,M; //迷宫大小queue&lt;P&gt; que;void BFS()&#123; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) &#123; vis[i][j] = INF; &#125; &#125; vis[sx][sy] = 1;//表示起始路径长度 que.push(P(sx,sy)); while(que.size())&#123; p = que.front(); que.pop(); for(int i=0;i&lt;4;i++)&#123; int x = p.first + dx[i]; int y = p.second + dy[i]; //在范围内，并且没有被访问过，而且是通路 if(x&gt;=0&amp;&amp;x&lt;N&amp;&amp;y&gt;=0&amp;&amp;y&lt;M&amp;&amp;map[x][y]!=1&amp;&amp;vis[x][y]==INF)&#123; que.push(P(x,y)); vis[x][y] = vis[p.first][p.second] + 1; if(p.first==ex&amp;&amp;p.second==ey)&#123; break; &#125; &#125; &#125; &#125; &#125; int main()&#123; N = 5; M = 5;//初始化迷宫大小 for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) &#123; scanf(\"%d\",&amp;map[i][j]); &#125; &#125; BFS(); printf(\"%d\",vis[N-1][M-1]); /*printf(\"%d\",vis[N-1][M-1]); for(int i=0;i&lt;5;i++) &#123; for(int j=0;j&lt;5;j++)&#123; printf(\"%d \",vis[i][j]); &#125; printf(\"\\n\"); &#125;*/ return 0;&#125; /*测试用例 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出9*/ 最小生成树（克鲁斯卡尔算法）1234567891011121314151617181920/* |Kruskal算法| |适用于 稀疏图 求最小生成树| |16/11/05ztx thanks to wangqiqi|*//* 第一步：点、边、加入vector，把所有边按从小到大排序 第二步：并查集部分 + 下面的code*/void Kruskal() &#123; ans = 0; for (int i = 0; i&lt;len; i++) &#123; if (Find(edge[i].a) != Find(edge[i].b)) &#123; Union(edge[i].a, edge[i].b); ans += edge[i].len; &#125; &#125; &#125; 迪杰斯特拉算法（单源最短路径）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstring&gt;#define INF 65535using namespace std;int map[1005][1005];int dist[1005];int vis[1005];void Dijkstra(int n) &#123; int i,j,k,min; for(int i=1;i&lt;=n;i++) &#123; dist[i] = map[1][i]; &#125; for(i=1;i&lt;=n;i++)&#123; k = 0; min = INF; //先找最短的路，要求该点没有被访问过，而且是距离的最小值 for(j=1;j&lt;=n;j++) &#123; if(vis[j]==0&amp;&amp;dist[j]&lt;min)&#123; min = dist[j]; k = j; &#125; &#125; vis[k] = 1; for(j=1;j&lt;=n;j++) &#123; if(vis[j] == 0&amp;&amp;dist[j]&gt;dist[k]+map[k][j])&#123; dist[j] = dist[k] + map[k][j]; &#125; &#125; &#125; &#125;int main()&#123; int i,j,a,b,c; int t,n; while(cin&gt;&gt;t&gt;&gt;n) &#123; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(i==j)map[i][j] = 0; else map[i][j] = INF; &#125; &#125; memset(dist,0,sizeof(dist)); memset(vis,0,sizeof(vis)); for(i=1;i&lt;=t;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(c&lt;map[a][b])&#123; map[b][a] = map[a][b] = c; &#125; &#125; Dijkstra(n); printf(\"%d\\n\",dist[n]); &#125; return 0;&#125; /*poj 2387样例： 5 51 2 202 3 303 4 204 5 201 5 100结果 90*/ 弗洛伊德算法12345678910111213141516171819void Floyd()&#123; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j] = min(dis[i][j],dis[i][k)+dis[k][j]) &#125; &#125; &#125;&#125;//传递闭包 判断两点是否联通 void Floyd() &#123; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j] |= dis[i][k] &amp; dis[k][j]; &#125; &#125; &#125;&#125; 01背包123456789101112131415161718192021222324252627282930//求解将哪些物品装入背包可使价值总和最大 #include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int nmax=1000; int v[nmax];//v[i]表示第i个物品的价值value int w[nmax];//w[i]表示第i个物品的重量weight int dp[nmax];//总价值 int n,m;//n表示物品数量，m表示背包容量 int main() &#123;//一维数组实现的01背包模板 while(cin&gt;&gt;n&gt;&gt;m)&#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;n;i++)&#123;//遍历n个物品 for(int j=m;j&gt;=0;j--)&#123;//01背包容量 逆序遍历 if(j&gt;=w[i])&#123; dp[j]=max(dp[j],(dp[j-w[i]]+v[i])); &#125;//第i个物体不选，dp[j]=dp[j]; //第i个物体若选 dp[j]=dp[j-w[i]]+v[i] &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;endl; &#125; return 0;&#125; 完全背包1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int nmax=1000; int v[nmax];//v[i]表示第i个物品的价值value int w[nmax];//w[i]表示第i个物品的重量weight int dp[nmax];//总价值 int n,m;//n表示物品数量，m表示背包容量 int main() &#123;//一维数组实现的完全背包模板 while(cin&gt;&gt;n&gt;&gt;m)&#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;n;i++)&#123;//遍历n个物品 for(int j=0;j&lt;=m;j++)&#123;//完全背包容量 顺序遍历 if(j&gt;=w[i])&#123; dp[j]=max(dp[j],(dp[j-w[i]]+v[i])); &#125;//第i个物体不选，dp[j]=dp[j]; //第i个物体若选 dp[j]=dp[j-w[i]]+v[i] &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://wysblogs.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wysblogs.top/tags/算法/"}]},{"title":"阿里Redis规范","slug":"阿里Redis规范","date":"2020-04-22T02:47:35.000Z","updated":"2020-04-24T10:49:49.731Z","comments":true,"path":"2020/04/22/阿里Redis规范/","link":"","permalink":"http://wysblogs.top/2020/04/22/阿里Redis规范/","excerpt":"","text":"阿里云Redis规范一、键值设计1、key名设计(1)【建议】: 可读性和可管理性 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id ugc:video:1 (2)【建议】：简洁性 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如： user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。 (3)【强制】：不要包含特殊字符 反例：包含空格、换行、单双引号以及其他转义字符 2、value设计 (1)【强制】：拒绝bigkey(防止网卡流量、慢查询) string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。 反例：一个包含200万个元素的list。 非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法 (2)【推荐】：选择适合的数据类型。 例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡) 反例： setuser:1:nametom setuser:1:age19 setuser:1:favor football 正例: hmsetuser:1nametomage19favorfootball 3、【推荐】：控制key的生命周期，redis不是垃圾桶。 建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。 二、命令使用1.【推荐】 O(N)命令关注N的数量 例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。 2.【推荐】：禁用命令 禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。 3.【推荐】合理使用select redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。 4.【推荐】使用批量操作提高效率 原生命令：例如mget、mset。 非原生命令：可以使用pipeline提高效率。 但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。 注意两者不同： 1、原生是原子操作，pipeline是非原子操作。 2、pipeline可以打包不同的命令，原生做不到 3、pipeline需要客户端和服务端同时支持。 5.【建议】Redis事务功能较弱，不建议过多使用 Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决) 6.【建议】Redis集群版本在使用Lua上有特殊要求： 1.所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn” 2.所有key，必须在1个slot上，否则直接返回error, “-ERR eval/evalsha command keys must in same slotrn” 7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。 三、客户端使用1.【推荐】 避免多个应用使用一个Redis实例 正例：不相干的业务拆分，公共数据做服务化。 2.【推荐】 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式： 3.【建议】 高并发下建议客户端添加熔断功能(例如netflix hystrix) 4.【推荐】 设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持） 5.【建议】 根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。 默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。 其他策略如下： allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。 allkeys-random：随机删除所有键，直到腾出足够空间为止。 volatile-random:随机删除过期键，直到腾出足够空间为止。 volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。 noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。 四、相关工具1.【推荐】：数据同步 redis间数据同步可以使用：redis-port 2.【推荐】：big key搜索 redis大key搜索工具 3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用) facebook的redis-faina 阿里云Redis已经在内核层面解决热点key问题，欢迎使用。","categories":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/tags/redis/"}]},{"title":"Redis初探","slug":"Redis初探","date":"2020-04-21T02:49:52.000Z","updated":"2020-04-21T02:50:32.745Z","comments":true,"path":"2020/04/21/Redis初探/","link":"","permalink":"http://wysblogs.top/2020/04/21/Redis初探/","excerpt":"","text":"Redis初探简介REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 安装下载压缩包 1wget http://download.redis.io/releases/redis-5.0.9.tar.gz 解压压缩包 123tar -zxvf redis-5.0.9.tar.gz#解压好感觉最好改个名字mv redis-5.0.9 redis 进入文件夹进行安装 12cd redismake MALLOC=libc 完成后进入src目录进行安装 12cd srcmake install 启动服务 刚开始运行是不支持后台的，得在配置文件中进行修改，然后读取配置文件运行 12345vim /usr/local/bin/redis/redis.conf#修改下面这个配置为yesdaemonize no#然后指定配置文件运行./redis-server /usr/local/bin/redis/redis.conf 关闭进程 如果想关闭的话得先找到pid 12#找PID有很多方法，我是习惯了这种从端口寻找的方法lsof -i:6379 整合整合是整合到springboot中 首先导入依赖 12345&lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 然后在application.yml中进行配置 123456789101112spring: redis: host: 127.0.0.1 #主机地址 port: 6379 #端口号 password: 123456 #自己设置的密码 timeout: 1000 #连接超时时间 jedis: pool: max-active: 10 #最大连接数 max-wait: -1 #最大阻塞等待时间 max-idle: 500 #最大空闲数量 min-idle: 0 #最小空闲数量 之后就可以写配置类进行测试了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Componentpublic class RedisUtils &#123; @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; /** * 读取缓存 * @param key 缓存key值 * @return 返回查找到的值 */ public String get(final String key) &#123; return redisTemplate.opsForValue().get(key); &#125; /** * 写入缓存 * @param key key值 * @param value value值 * @return 返回布尔类型表示是否写入成功 */ public boolean set(final String key, final String value) &#123; boolean result = false; try&#123; redisTemplate.opsForValue().set(key,value); result = true; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 更新缓存 * @param key 更新的key值 * @param value 更新的value值 * @return 返回是否更新成功的布尔类型 */ public boolean getAndSet(final String key, final String value) &#123; boolean result = false; try&#123; redisTemplate.opsForValue().getAndSet(key,value); result = true; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 删除缓存 * @param key 要删除的缓存的key值 * @return 返回是否删除成功的布尔类型 */ public boolean delete(final String key)&#123; boolean result = false; try&#123; redisTemplate.delete(key); result = true; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; 可以在测试类中进行测试，我是测试之后没问题的。","categories":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/tags/redis/"}]},{"title":"Redis基础","slug":"Redis基础","date":"2020-03-26T00:15:44.000Z","updated":"2020-03-26T00:19:55.343Z","comments":true,"path":"2020/03/26/Redis基础/","link":"","permalink":"http://wysblogs.top/2020/03/26/Redis基础/","excerpt":"","text":"Redis简介Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 安装在官网下载，然后用ftp工具把下载的压缩包放到服务器上，解压缩 配置文件redis.conf 配置项说明如下： 序号 配置项 说明 1 daemonize no Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ） 2 pidfile /var/run/redis.pid 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定 3 port 6379 指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字 4 bind 127.0.0.1 绑定的主机地址 5 timeout 300 当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能 6 loglevel notice 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice 7 logfile stdout 日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null 8 databases 16 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id 9 save &lt;seconds&gt; &lt;changes&gt;Redis 默认配置文件中提供了三个条件：save 900 1 save 300 10 save 60 10000分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 10 rdbcompression yes 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 11 dbfilename dump.rdb 指定本地数据库文件名，默认值为 dump.rdb 12 dir ./ 指定本地数据库存放目录 13 slaveof &lt;masterip&gt; &lt;masterport&gt; 设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 14 masterauth &lt;master-password&gt; 当 master 服务设置了密码保护时，slav 服务连接 master 的密码 15 requirepass foobared 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH 命令提供密码，默认关闭 16 maxclients 128 设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息 17 maxmemory &lt;bytes&gt; 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区 18 appendonly no 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no 19 appendfilename appendonly.aof 指定更新日志文件名，默认为 appendonly.aof 20 appendfsync everysec 指定更新日志条件，共有 3 个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折中，默认值） 21 vm-enabled no 指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制） 22 vm-swap-file /tmp/redis.swap 虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享 23 vm-max-memory 0 将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0 24 vm-page-size 32 Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值 25 vm-pages 134217728 设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。 26 vm-max-threads 4 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 27 glueoutputbuf yes 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 28 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 29 activerehashing yes 指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍） 30 include /path/to/local.conf 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 常用的数据类型及应用场景 类型 简介 特性 场景 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set(集合) 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 待更新。。。","categories":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/tags/redis/"}]},{"title":"多模块开发踩坑","slug":"多模块开发踩坑","date":"2020-03-17T08:57:32.000Z","updated":"2020-03-18T07:32:07.156Z","comments":true,"path":"2020/03/17/多模块开发踩坑/","link":"","permalink":"http://wysblogs.top/2020/03/17/多模块开发踩坑/","excerpt":"","text":"多模块开发踩坑项目结构介绍 我遇到的问题1、 父pom文件内容，该写什么，什么部分不需要 2、 子pom文件内容，怎么去继承父模块 3、 怎么规范版本号，以及怎么统一包的版本 4、 怎么启动项目，怎么打包，怎么发布 5、 每个模块之前的packaging怎么填，谁需要打包，谁需要war，谁需要jar 6、 模块的子模块中还有子模块，这样的情况怎么调用和使用。 7、 application的配置到底属于哪一个模块 8、 relativePath到底需不需要（大坑） 9、 如果出现模块不一致怎么办 10、dependencyManagement和dependencies区别 11、多模块中怎么给需要的bean注入值 问题解决1、 写自己的版本号，把需要用的包使用 &lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; 导入，如果子类继承父类后，如果需要包的话就直接导入不用指明版本号 2、 如果直接在父pom中使用 &lt;dependencies&gt;&lt;/dependencies&gt; 的话那么子类不管用不用都需要导入 3、 子pom文件直接导入父pom文件的版本号就行 4、 版本号写在父pom文件中，以及包的版本号统一在父pom文件中使用，而且不需要指定jar的version了 5、 启动项目，我感觉应该是web层进行启动项目 6、 打包问题，如果项目没有问题直接对父项目 clean + package 即可，最后生成的包在web模块中 7、 一般来说父模块一般都是用pom聚合，子模块都要打成jar包，war包则一般都是web模块 8、 父模块需要指定所有子模块，子模块相互调用是通过相互依赖来实现的 9、 application的配置一般在web模块中 10、relativePath看情况来判断，首先relativePath默认值为../pom.xml ，查找顺序：relativePath元素中的地址–本地仓库–远程仓库，设定一个空值将始终从仓库中获取，不从本地路径获取，如&lt;relativePath /&gt; 11、如果模块不一致，那么就需要打开project Structure，在模块中把右边不一致的模块删除 12、如果用dependencyManagement来指定依赖，那么子模块中默认不会有，需要使用的时候只需要导入坐标就行，不需要指定版本号，默认使用的是父模块中的版本号，如果使用dependencies的话，不管子模块中用不用得到，都会在子模块中显示依赖。 13、如果想要注入值，那么需要在springbootApplication的注解中进行添加扫包，把其他模块中的类扫描进来 例如这种格式 @SpringBootApplication(scanBasePackages = {&quot;com.guidinglight&quot;}) POM文件parent模块packaging 需要改成 pom，因为默认为jar类型，改成pom表示夫类型都是pom类型 modules 把子模块全部添加进去 dependencyManagement 把需要用到的依赖都给添加进去，如果需要使用直接导入依赖就行了 child模块就是正常使用即可，需要什么依赖直接添加 待更新。。。引用https://blog.csdn.net/gdsgdh308227363/article/details/79722491 https://blog.csdn.net/zwt0909/article/details/52218222","categories":[{"name":"开发经验","slug":"开发经验","permalink":"http://wysblogs.top/categories/开发经验/"}],"tags":[{"name":"开发经验","slug":"开发经验","permalink":"http://wysblogs.top/tags/开发经验/"}]},{"title":"多模块项目理解","slug":"多模块项目理解","date":"2020-03-17T01:44:13.000Z","updated":"2020-03-17T03:07:35.058Z","comments":true,"path":"2020/03/17/多模块项目理解/","link":"","permalink":"http://wysblogs.top/2020/03/17/多模块项目理解/","excerpt":"","text":"多模块项目理解介绍为什么要用多模块？ 1、 做项目首先讲究 “高内聚，低耦合”，因此传统的项目是将一个项目分为多个包，随着项目复杂，如果想复用一个模块的话，因为是包的形式，复用起来会很麻烦，耦合性很强，常用的方法就是复制代码修改，但是这样会做出很多无用功和增加出错几率。 2、 springboot多模块简单说，就是把包按分模块的模式，借助maven升级到jar方式，抽象性就更强了，假如jar再升级到war或者多个集合的jar，就成微服务了，在多模块jar模式下，可以将某个jar拿出来对外共用，能大大提高代码复用率和开发效率。 3、 开发者对自己或者别人负责的代码边界很模糊，这是复杂项目中最容易遇到的，导致结果就是开发者很容易修改别人代码，而且代码负责人还不知道，责任追踪很麻烦。 4、简单来说就是 高内聚，低耦合，容易维护，便于开发者确定自己负责的内容。 5、以上都是百度的。 开发思路1、首先确定项目开发结构 2、创建最基本的项目模块 3、理清楚各模块之间的依赖关系 4、修改pom文件，统一版本号和使用的jar包版本，如果在此期间觉得哪几个模块能够合并，就优化一下 可能会存在的问题（1） 划分模块的方式 划分模块主要根据是职责单一性和耦合性，如果是项目创建初期就使用多模块来规划项目，那么职责单一性就应该是首先考虑的，也就是通常意义上的按照层次划分，如果是从一个十分复杂的项目开始拆分，那么在划分模块的石航就不仅仅是考虑职责单一性了，职责单一会造成大量的子模块产生导致pom文件臃肿且不容易识别，如果将耦合性考虑进去就应该将关系较为紧密的模块合并降低模块的数量提高实用性。 （2） 公有依赖的抽象 parent中的以来配置主要是有一些公有的依赖，例如log，apache，commons，spring等，怎么界定一个依赖是否属于公有呢？一般情况下如果这个依赖被超过2/3的子模块所依赖就可以将其认定为公有依赖，另外也可以将依赖的某些配置（例如版本号）以parent中pom的属性的形式加以声明，这样在升级某些依赖的时候只要改动一处就行了（很类似C语言中的#define） （3） 模块的存在与消亡 模块的划分并不是一成不变的，模块的存在就是为了方便维护和提高生产效率，如果某些模块不合理并且影响了开发效率，那么这些模块就需要再好好斟酌一下，一般情况下这种情况出现不是为了模块过于庞大就是因为模块的碎片化，对于前者需要拆分更多模块以提高复用和去除冗余，后者则需要酌情合并一些耦合性较高的模块。 （4） 子模块的子模块 这种情况的出现往往就意味着这个项目本身就应该被分成多个项目，多个项目之间也可以继承同一个parent的pom.xml这主要是为了方便统一构建多个项目。所以子模块的子模块应该避免出现。 待更新。。。引用如下: https://blog.csdn.net/wuzhenwei0419/article/details/84029454 https://www.cnblogs.com/ruanjianlaowang/p/11214271.html","categories":[{"name":"开发经验","slug":"开发经验","permalink":"http://wysblogs.top/categories/开发经验/"}],"tags":[{"name":"开发经验","slug":"开发经验","permalink":"http://wysblogs.top/tags/开发经验/"}]},{"title":"Centos基本信息和ssh","slug":"Centos基本信息和ssh","date":"2019-12-12T13:26:22.000Z","updated":"2019-12-12T17:02:07.937Z","comments":true,"path":"2019/12/12/Centos基本信息和ssh/","link":"","permalink":"http://wysblogs.top/2019/12/12/Centos基本信息和ssh/","excerpt":"","text":"Centos 基本信息和SSHCentos介绍CentOS Linux是一个社区支持的发行版，该发行版来自在Red Hat或CentOS git上免费提供给公众的资源适用于Red Hat Enterprise Linux（RHEL）。因此，CentOS Linux旨在与RHEL在功能上兼容。CentOS专案主要更改软件包以删除上游供应商的品牌和艺术品。CentOS Linux是免费的，可以免费重新分发。每个CentOS版本都会得到维护，直到等效的RHEL版本不再受到一般支持为止。一旦重建了新的RHEL版本，便会提供一个新的CentOS版本-大约每6-12个月发行一次次要点发布，几年则更新一次主要版本。重建所需的时间从点发布的几周到主要版本变更的几个月不等。这样就形成了一个安全，低维护，可靠，可预测和可再现的Linux环境。 下载下载地址 常用命令文件与目录操作 命令 解析 cd /home 进入 ‘/home’ 目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd - 返回上次所在目录 cp file1 file2 将file1复制为file2 cp -a dir1 dir2 复制一个目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录（.代表当前目录） ls 查看目录中的文件 ls -a 显示隐藏文件 ls -l 显示详细信息 ls -lrt 按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序） pwd 显示工作路径 mkdir dir1 创建 ‘dir1’ 目录 mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 mv dir1 dir2 移动/重命名一个目录 rm -f file1 删除 ‘file1’ rm -rf dir1 删除 ‘dir1’ 目录及其子目录内容 查看文件内容 命令 解析 cat file1 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 more file1 查看一个长文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 tail -3 file1 查看一个文件的最后三行 vi file 打开并浏览文件 文本内容处理 命令 解析 grep str /tmp/test 在文件 ‘/tmp/test’ 中查找 “str” grep ^str /tmp/test 在文件 ‘/tmp/test’ 中查找以 “str” 开始的行 grep [0-9] /tmp/test 查找 ‘/tmp/test’ 文件中所有包含数字的行 grep str -r /tmp/* 在目录 ‘/tmp’ 及其子目录中查找 “str” diff file1 file2 找出两个文件的不同处 sdiff file1 file2 以对比的方式显示两个文件的不同 vi file 操作解析i进入编辑文本模式Esc退出编辑文本模式:w保存当前修改:q不保存退出vi:wq保存当前修改并退出vi 查询操作 命令 解析 find / -name file1 从 ‘/’ 开始进入根文件系统查找文件和目录 find / -user user1 查找属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件 find /usr/bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 find -name ‘*.[ch]’ | xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ find -type f -print0 | xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ find -maxdepth 1 -type f | xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 压缩、解压 命令 解析 bzip2 file1 压缩 file1 bunzip2 file1.bz2 解压 file1.bz2 gzip file1 压缩 file1 gzip -9 file1 最大程度压缩 file1 gunzip file1.gz 解压 file1.gz tar -cvf archive.tar file1 把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数） tar -cvf archive.tar file1 dir1 把 file1，dir1 打包成 archive.tar tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 把压缩包释放到 /tmp目录下 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 dir1 把文件和目录压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式的压缩包到当前目录 unzip test.zip -d /tmp/ 解压一个zip格式的压缩包到 /tmp 目录 yum安装器 命令 解析 yum -y install [package] 下载并安装一个rpm包 yum localinstall [package.rpm] 安装一个rpm包，使用你自己的软件仓库解决所有依赖关系 yum -y update 更新当前系统中安装的所有rpm包 yum update [package] 更新一个rpm包 yum remove [package] 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search [package] 在rpm仓库中搜寻软件包 yum clean [package] 清除缓存目录（/var/cache/yum）下的软件包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 网络相关 命令 解析 ifconfig eth0 显示一个以太网卡的配置 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置网卡的IP地址 ifdown eth0 禁用 ‘eth0’ 网络设备 ifup eth0 启用 ‘eth0’ 网络设备 iwconfig eth1 显示一个无线网卡的配置 iwlist scan 显示无线网络 ip addr show 显示网卡的IP地址 系统相关 命令 解析 su - 切换到root权限（与su有区别） shutdown -h now 关机 shutdown -r now 重启 top 罗列使用CPU资源最多的linux任务 （输入q退出） pstree 以树状图显示程序 man ping 查看参考手册（例如ping 命令） passwd 修改密码 df -h 显示磁盘的使用情况 cal -3 显示前一个月，当前月以及下一个月的月历 cal 10 1988 显示指定月，年的月历 date –date ‘1970-01-01 UTC 1427888888 seconds’ 把一相对于1970-01-01 00:00的秒数转换成时间 XSheel 5相关操作窗体快捷键 命令 解析 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + a 光标移动到行首（ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（end of line） Ctrl + f 光标向前（forward）移动一个字符位置 Ctrl + b 光标往回（backward）移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + r 显示:号提示，根据用户输入查找相关历史命令（reverse-i-search） Ctrl + w 删除从光标位置前到当前所处单词（word）的开头 Ctrl + t 交换光标位置前的两个字符 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + Alt + d 显示桌面 Alt + b 光标往回（backward）移动到前一个单词 Alt + d 删除从光标位置到当前所处单词的末尾 Alt + F2 运行 Alt + F4 关闭当前窗口 Alt + F9 最小化当前窗口 Alt + F10 最大化当前窗口 Alt + Tab 切换窗口 Alt + 左键 移动窗口（或在最下面的任务栏滚动鼠标滑轮） SSH介绍SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 SSH用法检查是否开启ssh1$rpm -qa | grep ssh 安装ssh1$yum install openssh-server 开启ssh1$ /bin/systemctl start sshd.service 继续检查是否开启1$ps -e | grep sshd 将ssh添加自启动1$systemctl enable sshd.service","categories":[{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/categories/centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/tags/centos/"}]},{"title":"centos mysql配置","slug":"Centos7-mysql配置","date":"2019-12-11T01:16:07.000Z","updated":"2019-12-12T17:27:28.956Z","comments":true,"path":"2019/12/11/Centos7-mysql配置/","link":"","permalink":"http://wysblogs.top/2019/12/11/Centos7-mysql配置/","excerpt":"","text":"Centos 7 Mysql配置Yum安装123456#安装$yum install mysql-server#启动$systemctl start mysqld #登录$mysql -u root -p 配置修改root密码 1234567891011121314进入mysql系统表use mysql;对用户进行排序desc user;修改root密码update user set password = password(“root”) where user = ‘root’;刷新权限flush privileges;赋予其他机器可以访问的权限grant all privileges on . to root@’%’ identified by ‘root’ with grant option; 修改字符集 1$vim /etc/my.cnf 修改成这个样子 1234567891011121314151617181920[client]port=3306socket=/var/lib/mysql/mysql.sockdefault-character-set=utf8[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0character-set-server=utf8[mysql]no-auto-rehashdefault-character-set=utf8[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 重启mysql服务 1234$service mysqld restart#在mysql中查看字符编码show variables like 'character_set%';","categories":[{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/categories/centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/tags/centos/"}]},{"title":"centos7 防火墙优化","slug":"Centos7-防火墙","date":"2019-12-11T01:14:40.000Z","updated":"2019-12-12T17:20:49.776Z","comments":true,"path":"2019/12/11/Centos7-防火墙/","link":"","permalink":"http://wysblogs.top/2019/12/11/Centos7-防火墙/","excerpt":"","text":"Centos 7 防火墙优化简介Centos 7 使用的防火墙是 firewall，可以允许哪些服务可用，哪些端口可用 开关123456789$systemctl enable firewalld.service #启用 \"开机启动\"$systemctl disable firewalld.service #关闭 \"开机启动\"$systemctl start firewalld.service #启用防火墙$systemctl stop firewalld.service #关闭防火墙$systemctl status firewalld.service #查看防火墙状态【开机自启】$chkconfig firewalld on #\"开机自启\" 开启$chkconfig firewalld off #\"开机自启\" 关闭 端口端口其实就是 类似于门的东西，你只能通过这扇门来访问我的服务器， 因此对于服务器安全来说，这扇门还是很重要的。 开放端口 12345678910$firewall-cmd --zone=public --add-port=&#123;端口&#125;/tcp --permanent #开放端口#开放端口之后必须重新启动防火墙才可以生效$systemctl restart firewalld.service #重启防火墙# --zone 作用域# --add-port=&#123;端口&#125;/tcp 添加端口# --permanent 永久生效，没有这个重启之后就会失效#查看开启端口$firewall-cmd --list-ports 关闭端口 1$firewall-cmd --zone=public --remove-port=80/tcp --permanent 优化修改22端口 1、打开 /etc/ssh/sshd_config文件 1$vim /etc/ssh/sshd_config 2、将#Port 22 注释去掉，22改为你想设置的端口，如33881，保存 3、重启ssh 1systemctl restart sshd.service 4)将该端口加入防火墙例外并重启防火墙 123$firewall-cmd --permanent --zone=public --add-port=33881/tcp$sudo systemctl restart firewalld.service 密码长度与有效期 默认配置： 123456$cat /etc/login.defs |grep PASS_ |grep -v '#'PASS_MAX_DAYS 99999PASS_MIN_DAYS 0PASS_MIN_LEN 5PASS_WARN_AGE 7 加固方案: 1.备份配置文件： 1$ cp -a /etc/login.defs /etc/login.defs.default 2.编辑配置文件并将相关参数改成如下 12345$vi /etc/login.defsPASS_MAX_DAYS 90PASS_MIN_DAYS 6PASS_MIN_LEN 8PASS_WARN_AGE 30 备注: /etc/login.defs文件的pass_min_len 参数并不具备强制性，测试仍然可以设置7位密码。最终需要cracklib来实现。 参数说明： PASS_MAX_DAYS 密码有效期 PASS_MIN_DAYS 修改密码的最短期限 PASS_MIN_LEN 密码最短长度 PASS_WARN_AGE 密码过期提醒 禁止root通过ssh远程登录 默认配置: 12$cat /etc/ssh/sshd_config |grep PermitRootLogin#PermitRootLogin yes 加固方案: 123456781.备份配置文件$cp -a /etc/ssh/sshd_config /etc/ssh/sshd_config.default2.编辑配置文件$vi /etc/ssh/sshd_config将配置参数#PermitRootLogin yes改成PermitRootLogin no3.保存配置文件4.重启ssh服务$ /etc/init.d/sshd restart SSH 配置参数增强 12345678910111213141516171819202122231.备份配置文件2.编辑配置文件$vi /etc/ssh/sshd_config（1）禁止空密码登录将#PermitEmptyPasswords no参数的注释符号去掉，改成PermitEmptyPasswords no（2）关闭ssh的tcp转发将#AllowTcpForwarding yes参数改成AllowTcpForwarding no（3）关闭S/KEY（质疑-应答)认证方式将#ChallengeResponseAuthentication yes参数，改成ChallengeResponseAuthentication no（4）关闭基于GSSAPI 的用户认证将GSSAPIAuthentication yes参数，改成GSSAPIAuthentication no3.保存配置文件4.重启ssh服务 隐藏系统版本信息 123执行以下命令：$mv /etc/issue /etc/issue.bak$mv /etc/issue.net /etc/issue.net.bak 备注:登录界面显示系统版本信息 系统参数调优 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869701.备份配置文件cp -a /etc/sysctl.conf /etc/sysctl.conf.default2.添加以下调优参数到该文件中net.ipv4.ip_forward = 1net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.route.gc_timeout = 20net.ipv4.tcp_retries2 = 5net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000net.core.somaxconn = 262144net.core.netdev_max_backlog = 262144net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.route.gc_timeout = 20net.ipv4.ip_local_port_range = 10024 65535net.ipv4.tcp_retries2 = 5net.ipv4.tcp_syn_retries = 2net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_keepalive_time = 1800net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000fs.file-max = 65535kernel.pid_max = 65536net.ipv4.tcp_wmem = 4096 87380 8388608net.core.wmem_max = 8388608net.core.netdev_max_backlog = 5000net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_max_syn_backlog = 10240net.core.netdev_max_backlog = 262144net.core.somaxconn = 262144net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 120net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_max_tw_buckets = 36000","categories":[{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/categories/centos/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/tags/centos/"}]},{"title":"Mybatis逆向工程","slug":"Mybatis逆向工程","date":"2019-11-21T13:32:57.000Z","updated":"2019-11-21T13:36:02.227Z","comments":true,"path":"2019/11/21/Mybatis逆向工程/","link":"","permalink":"http://wysblogs.top/2019/11/21/Mybatis逆向工程/","excerpt":"","text":"Mybatis逆向工程pom.xml插件123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"Mybatis3\"&gt; &lt;!-- 避免生成重复代码的插件 --&gt; &lt;!-- &lt;plugin type=\"com.vi.tmall.util.OverlsMergeablePlugin\"/&gt;--&gt; &lt;!-- 是否不生成注释 --&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressDate\" value=\"true\" /&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/tmall_ssm\" userId=\"root\" password=\"root\"/&gt; &lt;!-- 这个元素的配置用来指定JDBC类型和Java类型如何转换。 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否强制将DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal --&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetPackage:生成实体类存放的包名, targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject=\"src/main/java\"）--&gt; &lt;javaModelGenerator targetPackage=\"com.vi.tmall.pojo\" targetProject=\"src/main/java\"&gt; &lt;!--enableSubPackages 如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false--&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;!-- trimStrings:是否对数据库查询结果进行trim操作，如果设置为true就会生成类似这样public void setUsername(String username)--&gt; &lt;property name=\"trimString\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!--生成xml映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成mapper类存放位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.vi.tmall.mapper\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\"/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名,enableXXX:XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句--&gt; &lt;table tableName=\"category\" domainObjectName=\"Category\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"true\" selectByExampleQueryId=\"false\"&gt; &lt;property name=\"my.isgen.usekeys\" value=\"true\"/&gt; &lt;!--useActualColumnNames:如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式--&gt; &lt;property name=\"useActualColumnNames\" value=\"true\"/&gt; &lt;generatedKey column=\"id\" sqlStatement=\"JDBC\"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行在Maven中运行generator插件就行","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://wysblogs.top/categories/Mybatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://wysblogs.top/tags/MyBatis/"}]},{"title":"JAVA设计模式之面向对象设计模式","slug":"JAVA设计模式之面向对象设计模式","date":"2019-11-18T13:20:33.000Z","updated":"2019-11-18T15:06:56.287Z","comments":true,"path":"2019/11/18/JAVA设计模式之面向对象设计模式/","link":"","permalink":"http://wysblogs.top/2019/11/18/JAVA设计模式之面向对象设计模式/","excerpt":"","text":"java设计模式之面向对象设计模式概述软件的可维护性和可复用性是两个非常重要的用于衡量软件质量的属性 面向对象设计，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。 单一职责原则定义一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 另一种定义方式就一个类而言，应该仅有一个引起它变化的原因。 解释在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被服用的可能性就越小，而且一个类承担的职责过多，相当于将这些指责耦合在一起，当一个职责变化的时候就可能引起其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一个类中。 单一职责原则是实现高内聚、低耦合的指导方针 开闭原则开闭原则是面向对象的可复用设计的第一块基石，他是最重要的面向对象设计原则。 定义软件实体应当对扩展开放，对修改关闭。 解释在开闭原则的定义中，软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。 如果一个软件设计符合开闭原则，那么可以非常方便的对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 实现为了满足开闭原则。，需要对系统进行抽象化设计，抽象化是开闭原则的关键。编程时，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。 在后面的24种设计模式中很多设计模式都符合开闭原则，在对每一个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可拓展性。 里氏代换原则定义所有引用基类的地方必须能透明地使用其子类的对象。 解释在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此判断我喜欢所有的动物。 里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在运用里氏代换原则时应该将父类设计为抽象类或者接口，让子类继承父类或者实现父接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 依赖倒转原则定义高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 解释依赖倒转原则要求针对接口编程，不需要针对实现编程。 依赖倒转原则要求在程序代码中传递参数时或者在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式注入所依赖的对象。 常用的三种注入方式： 构造注入，设值注入和接口注入。 后话开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，他们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。 接口隔离原则定义客户端不应该依赖那些它不需要的接口。 解释当一个接口太大时，需要把这个接口分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。 这里的“接口“往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的”接口“，有严格的定义和结构，例如 interface。 在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 合成复用原则定义优先使用对象组合，而不是通过继承来达到复用的目的。 解释合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。 在复用的时候，尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或者通过继承，但是首先应该考虑使用组合/聚合,组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对于其他类造成的影响相对较少；其次才考虑继承，在使用继承时需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，而且灵活性不够强，只能在有限的环境中使用。 组合/聚合可以将已有的对象纳入新对象中，使之成为新对象的一部分，相对继承关系而言，耦合性相对较低； 合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 扩展关联 关联指的是两个分开的类通过对象或者实例建立地关系。关联可以是一对一，一对多，多对一，多对多等关系。 关联比较宽泛，组合是聚合地一个子集。组合-》聚合-》关联； 聚合 聚合是关联的一种特殊形式：主要体现在三个方面 聚合代表了has-a的关系 并且是一种单向关系。单向的，比如说公寓里有学生，但是学生里面不能有公寓，这是一种天生的单向关系。 在聚合的关系中，两种实例是可以单独存在的，不会相互影响，一个实例的存在与否不会影响与之聚合的实例的存在与否。 组合 组合是一种聚合的限制形式，其中两个实体高度相互依赖，也就是说，两个类高度耦合。有以下特征： 代表着一种part-of关系，就是一个类是另一个类的一部分 在组合的关系中，实例是彼此依赖的 当两个实例是组合关系，他们就是高度耦合的，一个对象必须依赖另一个对象的存在而存在 比如图书馆中会有很多相同或者不同主题的图书，但是如果图书馆被销毁后，对应的图书也就没了，图书不能独立与图书馆而存在，这就是组合关系。 聚合和组合相比较 依赖：聚合代表被关联的一方可以独立于关联一方而存在的关系，比如说，银行和雇员，将银行删除后，雇员仍然存在；然后，组合代表着被关联的一方不能独立与另一方而存在的关系，比如，人没有心脏就不能生存，心脏没有人也就没有了心脏。 关系类型：聚合是has-a关系，组合是part-of关系。 关联类型：组合是一种强关联关系，聚合是一种弱关联关系 迪米特原则定义每一个软件单位对其他单位都只有最少的只是，而且局限于那些与本单位密切相关的软件单位。 解释迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则则要求限制软件实体之间通信的宽度和深度。 应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。 定义形式： 不要和 “陌生人” 说话 只与你的朋友直接通信 朋友的类别： 当前对象本身（this） 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 任意一个对象如果满足上面的条件之一，就是当前对象的 ”朋友“ ，否则就是 “陌生人” 。 在应用迪米特法则的时候，一个对象只能与直接朋友发生交互，不要与 “陌生人” 直接交互，这样可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。如果一个对象需要调用另一个对象的方法，可以通过 “第三者” 转发这个调用。简单说就是引用一个 “第三者” 来降低现有对象之间的耦合度。 注意： 类的划分上尽量创建松耦合类，类之间的耦合度越低，就越有利于复用，如果修改了一个类，不会对关联的类造成太大的影响。 类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 类的设计上，只要有可能，一个类型应该设计成不变类，在对其它类的引用上，一个对象对其他对象的引用应当降到最低。 小结低耦合，高内聚，可维护，可复用，可扩展","categories":[{"name":"java设计模式","slug":"java设计模式","permalink":"http://wysblogs.top/categories/java设计模式/"}],"tags":[{"name":"java设计模式","slug":"java设计模式","permalink":"http://wysblogs.top/tags/java设计模式/"}]},{"title":"Maven课上学习（三）","slug":"Maven课上学习（三）","date":"2019-11-13T07:35:09.000Z","updated":"2019-11-13T07:45:32.086Z","comments":true,"path":"2019/11/13/Maven课上学习（三）/","link":"","permalink":"http://wysblogs.top/2019/11/13/Maven课上学习（三）/","excerpt":"","text":"Maven课上学习（三）依赖如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。 依赖传递范围设定score：作用域，控制依赖传递 test 仅适用于第一类jar包，其不会向下传递 provided 仅适用于第二类jar包，其不会向下传递 runtime 仅适用于第三类jar包，会向下传递 compile 默认值。适用于第四类jar包，会向下传递 system &lt;systemPath&gt;${basedir}/lib/xxx.jar&lt;/systemPath&gt; import 下节课会说 jar包分类： 编译、运行、打包时都不需要 测试用jar包属于该类型，例如junit、spring-test 编译、运行时需要的jar，打包时不需要 servlet-api，jsp-api属于该类型 编译时不需要，但运行、打包时需要的jar包 mysql驱动属于该类型 Class.forName(“com.mysql.jdbc.Driver”); 编译、运行、打包时均需要的jar包 可选传递optional（可选的） true，表示当前依赖是可选的，即可要可不要 false，默认值，表示默认是传递的 exclusions： exclusion：排除依赖，将所选的依赖排除 依赖冲突直接依赖冲突在同一个工程中出现了同一个依赖的不同版本，系统会自动选择最后导入的那个版本 间接依赖冲突间接依赖冲突在工程中会出问题，所以需要手工删除发生冲突的依赖 上级的包传递到下级，下级版本与上级不一致 版本号的统一与管理 依赖的继承直接继承 可选继承 聚合 课外开源中国—-&gt;国产开源 开源项目管理软件—-&gt;易软天创（禅道） 无反射无框架，无代理无框架","categories":[{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/categories/Maven学习/"}],"tags":[{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/tags/Maven学习/"}]},{"title":"学习中遇到的问题（一）","slug":"学习中遇到的问题（一）","date":"2019-11-13T06:46:57.000Z","updated":"2019-11-13T07:23:48.224Z","comments":true,"path":"2019/11/13/学习中遇到的问题（一）/","link":"","permalink":"http://wysblogs.top/2019/11/13/学习中遇到的问题（一）/","excerpt":"","text":"学习中遇到的问题（一）1、集合类型只能通过XML来实现 2、setting注入复杂类型数据 list: array value list value set value map: properties prop map entry key value 3、为什么IOC容器中获得bean的时候要把bean转化为接口类型？ 因为new对象的时候也是用接口实例化子类，而在spring-config.xml中已经实例化子类，所以把子类转化为接口类型，实现了多态。 4、javaBean使用包装类 Integer，String，Float等，因为如果值为空 不会显示0 可以显示null 5、线程绑定事务方法 TheadLocal ThreadLocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据 数据库事务控制 6、分页 可以使用分页框架实现 pagehelper 7、引入css样式后面一定要写上 rel=”stylesheet” 8、ResponseBody @ResponseBody是作用在方法上的，表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用（也就是ajax），在使用@RequestMapping后，返回值通常解析为跳转路径，但是加上@ReponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body 中，比如异步获取json数据，加上@ResponseBody后，会直接返回json数据。@RequestBody将HTTP请求正文插入方法中，使用适合的HttpMessageConverter将请求体写入某个对象。 9、 Mapper作用 为了把mapper这个DAO交給Spring管理 为了不再写mapper映射文件 为了给mapper接口 自动根据一个添加@Mapper注解的接口生成一个实现类 10、三层架构 三层架构：表现层，业务层，持久层 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是为了完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。 M称为模型，也就是实体类，用于数据的封装和数据的传输。 V称为视图，也就是GUI组件，用于数据的展示。 C称为控制，也就是事件，用于流程的控制。 设计原则 业务层接口的设计原则：一个实体类一个接口，一次提交一个事务方法。业务方法的参数来自表现层。 持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。 11、favicon报错 在head标签中最下面写上 1&lt;link rel=\"shortcut icon\" href=\"#\" /&gt; 12、centos防火墙端口 123456789101112131415161718#查看防火墙所有开放端口firewall-cmd --zone=public --list-ports#开启端口firewall-cmd --zone=public --add-port=80/tcp --permanent#命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效#关闭端口firewall-cmd --zone=public --remove-port=80/tcp --permanent#查看防火墙状态firewall-cmd --state #重启防火墙firewall-cmd --reload","categories":[{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/categories/学习/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/tags/学习/"}]},{"title":"thymeleaf","slug":"thymeleaf","date":"2019-10-31T10:51:38.000Z","updated":"2019-10-31T10:53:20.548Z","comments":true,"path":"2019/10/31/thymeleaf/","link":"","permalink":"http://wysblogs.top/2019/10/31/thymeleaf/","excerpt":"","text":"thymeleaf简介Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。 Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。 Thymeleaf的主要目标是提供一个优雅和高度可维护的创建模板的方式。 为了实现这一点，它建立在自然模板的概念之上，以不影响模板作为设计原型的方式将其逻辑注入到模板文件中。 这改善了设计沟通，弥合了前端设计和开发人员之间的理解偏差。 Thymeleaf也是从一开始就设计(特别是HTML5)允许创建完全验证的模板。 引入在头部引入xmls的参数 1234&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;/html&gt; 使用主要的使用标签 语法 说明 {home.welcome} 使用国际化文本,国际化传参直接追加(value…) ${user.name} 使用会话属性 @{} &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; – – ${} 中预存对象（表达式中基本对象） param 获取请求参数，比如${param.name},http://localhost:8080?name=jeff session 获取 session 的属性 application 获取 application 的属性 execInfo 有两个属性 templateName和 now(是 java 的 Calendar 对象) ctx vars locale httpServletRequest httpSession – – th扩展标签 th:text 普通字符串 th:utext 转义文本 th:href th:attr &lt;img src=&quot;../../images/gtvglogo.png&quot; th:attr=&quot;src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}&quot; /&gt; th:with 定义常量 th:attrappend th:classappend th:styleappend 其他th标签 * * * th:abbr th:accept th:accept-charset th:abbr th:accept th:accept-charset th:accesskey th:action th:align th:alt th:archive th:audio th:autocomplete th:axis th:background th:bgcolor th:border th:cellpadding th:cellspacing th:challenge th:charset th:cite th:class th:classid th:codebase th:codetype th:cols th:colspan th:compact th:content th:contenteditable th:contextmenu th:data th:datetime th:dir th:draggable th:dropzone th:enctype th:for th:form th:formaction th:formenctype th:formmethod th:formtarget th:frame th:frameborder th:headers th:height th:high th:href th:hreflang th:hspace th:http-equiv th:icon th:id th:keytype th:kind th:label th:lang th:list th:longdesc th:low th:manifest th:marginheight th:marginwidth th:max th:maxlength th:media th:method th:min th:name th:optimum th:pattern th:placeholder th:poster th:preload th:radiogroup th:rel th:rev th:rows th:rowspan th:rules th:sandbox th:scheme th:scope th:scrolling th:size th:sizes th:span th:spellcheck th:src th:srclang th:standby th:start th:step th:style th:summary th:tabindex th:target th:title th:type th:usemap th:value th:valuetype th:vspace th:width th:wrap th:xmlbase th:xmllang th:xmlspace th:alt-title 或th:lang-xmllang（如果其中两个属性值相同） 表达式语法简单的语法 #{...} ：Message 表达式 ${}：变量表达式 *{} ：选择变量表达式 @{}：链接 URL 表达式 变量 分类 示例 文本 ‘one text’ , ‘Another one!’ ,… 数字 0 , 34 , 3.0 , 12.3 ,… 真假 true , false 文字符号 one , sometext , main ,… 字符连接 分类 示例 + ‘The name is ‘+${name} … The name is ${name} 算数运算 语法 示例 +, -, *, /, % 二元运算符 - 减号（一元运算符） 真假运算 分类 示例 and , or 二元运算符 ! , not 否定（一元运算符） 比较运算 分类 示例 &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 比较 == , != ( eq , ne ) 平等 条件运算 分类 示例 if-then (if) ? (then) if-then-else (if) ? (then) : (else) Default (value) ?: (defaultvalue) 表达式中使用内置对象 123456789101112131415161718192021222324252627282930#dates :utility methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects.#numbers :utility methods for formatting numeric objects.#strings : utility methods for String objects: contains, startsWith, prepending/appending, etc. #objects : utility methods for objects in general.#bools : utility methods for boolean evaluation. #arrays : utility methods for arrays.#lists :utility methods for lists.#sets : utility methods for sets.#maps : utility methods for maps.#aggregates : utility methods for creating aggregates on arrays or collections.#messages : utility methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;...&#125; syntax.#ids : utility methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). 预处理 1__$&#123;expression&#125;__ 循环 1234567891011121314151617181920212223242526&lt;tr th:each=\"prod : $&#123;prods&#125;\"&gt; &lt;td th:text=\"$&#123;prod.name&#125;\"&gt;Onions&lt;/td&gt; &lt;td th:text=\"$&#123;prod.price&#125;\"&gt;2.41&lt;/td&gt; &lt;td th:text=\"$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;\"&gt;yes&lt;/td&gt;&lt;/tr&gt;迭代器的状态index: 当前的索引，从0开始count: 当前的索引，从1开始size：总数current:even/odd:firstlast&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"prod,iterStat : $&#123;prods&#125;\" th:class=\"$&#123;iterStat.odd&#125;? 'odd'\"&gt; &lt;td th:text=\"$&#123;prod.name&#125;\"&gt;Onions&lt;/td&gt; &lt;td th:text=\"$&#123;prod.price&#125;\"&gt;2.41&lt;/td&gt; &lt;td th:text=\"$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;\"&gt;yes&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 判断 1234567891011121314151617if&lt;a href=\"comments.html\" th:href=\"@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;\" th:if=\"$&#123;not #lists.isEmpty(prod.comments)&#125;\"&gt;view&lt;/a&gt;unless&lt;a href=\"comments.html\" th:href=\"@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;\" th:unless=\"$&#123;#lists.isEmpty(prod.comments)&#125;\"&gt;view&lt;/a&gt;switch&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"'admin'\"&gt;User is an administrator&lt;/p&gt; &lt;p th:case=\"#&#123;roles.manager&#125;\"&gt;User is a manager&lt;/p&gt;&lt;/div&gt;&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"'admin'\"&gt;User is an administrator&lt;/p&gt; &lt;p th:case=\"#&#123;roles.manager&#125;\"&gt;User is a manager&lt;/p&gt; &lt;p th:case=\"*\"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 模板布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354th:fragment示例templates/footer.html&lt;!DOCTYPE html SYSTEM \"http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd\"&gt; &lt;html xmlns=\"http://www.w3.org/1999/xhtml\" &lt;body&gt; &lt;div th:fragment=\"copy\"&gt; © 2011 The Good Thymes Virtual Grocery &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;templates/index.html中使用 &lt;body&gt; ... &lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt; &lt;/body&gt;或者 ... &lt;div id=\"copy-section\"&gt; © 2011 The Good Thymes Virtual Grocery &lt;/div&gt; ...使用 &lt;body&gt; ... &lt;div th:include=\"footer :: #copy-section\"&gt;&lt;/div&gt; &lt;/body&gt;th:include 和 th:replace 区别th:include 加入代码th:replace 替换代码模板传参：参数传递顺序不强制 定义&lt;div th:fragment=\"frag (onevar,twovar)\"&gt; &lt;p th:text=\"$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;\"&gt;...&lt;/p&gt;&lt;/div&gt; 使用&lt;div th:include=\"::frag ($&#123;value1&#125;,$&#123;value2&#125;)\"&gt;...&lt;/div&gt;&lt;div th:include=\"::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)\"&gt;...&lt;/div&gt; 等价于 &lt;div th:include=\"::frag\" th:with=\"onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;\"&gt;） 移除标签 th:remove 取值范围 all：移除所有 body：不移除自己，但移除他的子标签 tag: 只移除自己，不移除他的子标签 all-but-first：移除所有内容除第一个外 none：啥都不做 执行顺序 thymeleaf注释语法 html 看不到，并且 thymeleaf 不会执行 1&lt;!--/* This code will be removed at thymeleaf parsing time! */--&gt; and 未运行可以在 html 中看到，运行后就消失 123&lt;!--/*--&gt; &lt;div&gt;you can see me only before thymeleaf processes me! &lt;/div&gt;&lt;!--*/--&gt; 运行后才会看到 12345678910&lt;table&gt; &lt;th:block th:each=\"user : $&#123;users&#125;\"&gt; &lt;tr&gt; &lt;td th:text=\"$&#123;user.login&#125;\"&gt;...&lt;/td&gt; &lt;td th:text=\"$&#123;user.name&#125;\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" th:text=\"$&#123;user.address&#125;\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt;&lt;/table&gt; 推荐下面写法（编译前看不见） 123456789&lt;table&gt; &lt;tr&gt; &lt;td th:text=\"$&#123;user.login&#125;\"&gt;...&lt;/td&gt; &lt;td th:text=\"$&#123;user.name&#125;\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\" th:text=\"$&#123;user.address&#125;\"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt; &lt;/table&gt; 文本内联th:inline 略 验证模板的正确性 略 特殊用法展示 1&lt;td th:text=\"$&#123;#aggregates.sum(o.orderLines.&#123;purchasePrice * amount&#125;)&#125;\"&gt;23.32&lt;/td&gt;","categories":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://wysblogs.top/categories/thymeleaf/"}],"tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://wysblogs.top/tags/thymeleaf/"}]},{"title":"Docker","slug":"Docker","date":"2019-10-30T13:09:21.000Z","updated":"2019-10-30T13:10:31.222Z","comments":true,"path":"2019/10/30/Docker/","link":"","permalink":"http://wysblogs.top/2019/10/30/Docker/","excerpt":"","text":"Docker简介Docker是一个开源的应用容器引擎； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。 核心概念 docker主机（Host）：安装了Docker程序的机器 docker客户端（Client）：连接docker主机进行操作 docker仓库（Registry）：用来保存各种打包好的软件镜像 docker镜像（images）：软件打包好的镜像，放在docker仓库中 docker容器（Container）：镜像启动后的一个实例称为一个容器 步骤： 1、安装Docker 2、去Docker仓库找到这个软件对应的镜像 3、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器 4、对容器的启动停止就是对软件的启动停止 安装环境12345678910111213141516171、检查内核版本必须是3.10及以上uname -r2、安装dockeryum install docker3、按y确认4、启动docker# systemctl start docker# docker -v5、开机启动docker# systemctl enable docker6、停止docker# sytemctl stop docker7、进入docker镜像# docker exec -it 容器id 这种方式进入容器，退回到前台时，容器还在运行# docker attach 容器id 这种方式进入容器，退出时，容器也跟着退出8、退出docker镜像# exit 容器操作软件镜像（类似于安装程序）—-运行镜像—-产生一个容器（正在运行的软件） 步骤： 123456789101112131415161718192021222324252627281、搜索镜像# docker search tomcat2、拉取镜像# docker pull tomcat3、根据镜像启动容器# docker run --name mytomcat -d tomcat:latest4、查看运行中的容器# docker ps5、停止运行中的容器# docker stop 容器id6、查看所有容器# docker ps -a7、启动容器# docker start 容器id8、删除一个容器# docker rm 容器id9、启动一个做了端口映射的tomcat-d：后台运行-p：将主机的端口映射到容器的一个端口 主机端口：容器内部的端口10、防火墙# service firewalld status 查看防火墙状态# service firewalld stop 关闭防火墙11、查看容器的日志# docker logs container -name/container -id更多命令可以上官网https://docs.docker.com/engine/reference/commandline/docker/可以参考文档 环境搭建docker官方镜像网站 https://hub.docker.com/ 安装mysql 1docker pull mysql 使用mysql 必选按照人家给的文档来指定参数 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 做了端口映射 1docker run -p 3306:3306 --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 几个其他的高级操作 12345678docker run --name some-mysql -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/my/custom文件夹挂载到 mysqldocker容器的/ect/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在/conf/mysql文件夹下docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些参数","categories":[{"name":"Docker","slug":"Docker","permalink":"http://wysblogs.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://wysblogs.top/tags/Docker/"}]},{"title":"SpringBoot（三）日志","slug":"SpringBoot（三）日志","date":"2019-10-23T14:12:46.000Z","updated":"2019-10-23T14:15:13.343Z","comments":true,"path":"2019/10/23/SpringBoot（三）日志/","link":"","permalink":"http://wysblogs.top/2019/10/23/SpringBoot（三）日志/","excerpt":"","text":"Spring Boot（三）日志SpringBoot文档日志框架小张：开发一个大型系统： 1、 System.out.println(“”);将关键数据打印在控制台；老板要去掉？ 2、框架来记录系统的一些信息；日志框架；zhanglogging.jar； 3、高大上的几个功能？异步模式？自动归档？xxxx？zhanglogging-good.jar？ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglooging-perfect.jar； 5、JDBC—数据库驱动； 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； 给项目中导入具体的日志实现就行了； 我们之前的日至框架都是实现的抽象层； 市面上的日志框架： JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j。。。。 日志门面 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for java） jboss-logging LOg4j JUL(java.util.logging) Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面：SLF4j； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认使用的是JCL； SpringBoot选用SLF4j和logback； SLF4j的使用如何在系统中使用SLF4j以后开发的时候，日志记录的方法调用，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法； 应该给系统里面导入slf4j的jar包和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件，使用slf4j以后，配置文件还是做成日志实现框架的配置文件； 遗留问题a（slf4j+logback）；Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出； 如何让系统中所有日志都统一到slf4j1、 将系统中其他日志框架先排除出去 2、用中间包来替换原有的日志框架 3、我们导入slf4j其他的实现 SpringBoot日志关系123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; SpringBoot使用它来做日志功能： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 总结： 1、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 2、SpringBoot也把其他的日志都替换成了slf4j 3、中间替换包？ 4、如果我们要引入其他框架？一定要把这个框架的默认日子和依赖移除掉？ SpringBoot能自动适配所有日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架以来的日志框架排除掉； 日志使用默认配置SpringBoot帮我们配置好了日志； 12345678910111213141516171819202122232425/** * 记录器 */Logger logger = LoggerFactory.getLogger(getClass());@Testvoid contextLoads() &#123; /** * 日志的级别 * 由低到高 * trace&lt;debug&lt;warn&lt;error * 可以调整需要输出的日志级别； * 日志就只会在这个级别以后的高级别生效 */ logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); /** * SpringBoot默认给我们使用的是info级别的 * 没有指定级别的就用SpringBoot默认规定级别，root级别 */ logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 12345678日志和输出格式： %d表示日期时间， %thread表示线程名称， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分隔 %msg : 日志消息， %n 是换行符 %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.wys=trace#当前项目下生成springboot.log日志#支持绝对路径#可以指定完整的路径；#logging.file.name=springboot.log#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；#使用spring.log作为默认文件logging.file.path=/spring/log#在控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger - %msg%n#指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n 指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用它默认的配置了； Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml ：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项， 由SpringBoot来解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;!--可以指定某段配置只在某个环境中生效--&gt;&lt;/springProfile&gt; 否则 1no applicable action for [springProfile] 切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j + log4j的方式：排除不相关的依赖，导入自己需要的依赖就行； 可以在官方文档中进行资料查找； 切换为log4j2：导入log4j2的启动器依赖即可；","categories":[{"name":"Spring Boot学习笔记","slug":"Spring-Boot学习笔记","permalink":"http://wysblogs.top/categories/Spring-Boot学习笔记/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wysblogs.top/tags/Spring-Boot/"}]},{"title":"IDEA快捷键大全","slug":"IDEA快捷键大全","date":"2019-10-23T14:09:49.000Z","updated":"2019-10-23T14:11:37.477Z","comments":true,"path":"2019/10/23/IDEA快捷键大全/","link":"","permalink":"http://wysblogs.top/2019/10/23/IDEA快捷键大全/","excerpt":"","text":"IDEA快捷键大全Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件（查找文件） Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处（查找接口实现类） Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法","categories":[{"name":"IDEA","slug":"IDEA","permalink":"http://wysblogs.top/categories/IDEA/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://wysblogs.top/tags/IDEA/"}]},{"title":"Spring MVC常用注解","slug":"Spring-MVC常用注解","date":"2019-10-20T13:10:48.000Z","updated":"2019-10-20T13:11:31.113Z","comments":true,"path":"2019/10/20/Spring-MVC常用注解/","link":"","permalink":"http://wysblogs.top/2019/10/20/Spring-MVC常用注解/","excerpt":"","text":"Spring MVC 常用注解@Controller这个注解表示当前类是一个控制器组件，并且把这个类装进Spring容器中； 在Spring MVC中，控制器Controller负责处理DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层之后封装成一个Model，然后把该Model返回给对应的View进行展示； 123@Controllerpublic class HelloWorldController &#123;&#125; @RequestMapping作用 用于请求地址映射，可以作用于类和方法上； 参数 value：定义request请求的映射地址； method：定义request请求的方式；包括（GET，POST，OPTIONS，PUT，PATCH，DELETE，TRACE）默认接受的是GET请求，如果请求方式和定义方式不一致，那么就会请求不到指定映射地址。 params：定义request请求中必须包含的参数； headers：定义request请求中必须包含某些指定的请求头；如：@RequestMapping(value=”/test”,headers=”content-type=text/*”)说明请求中必须包含“text/html”等类型的Content-type头，才是一个匹配的请求； consumes：定义请求提交内容的类型； produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型从才返回； 1234@RequestMapping(\"/hello\")public String hello() &#123; return \"hello world quick!\";&#125; @RequestParam作用 用于获取传入参数的值 参数 value：参数的名称 required：定义该传入参数是否必须，默认为true，（和RequestMapping的params属性有点类似） 1234@RequestMapping(\"/hello\")public String hello(@RequestParam(name = \"myname\") String name) &#123; return name;&#125; @PathViriable作用 用于定义路径参数值 参数 value：参数的名称 required：定义传入参数是否为必须值 1234@RequestMapping(\"/hello/&#123;myname&#125;\")public String hello(@PathVariable(name=\"myname\") String name) &#123; return name;&#125; @ResponseBody作用 作用于方法上，可以将整个返回结果以某种格式返回，如json或者xml等 @CookieValue作用 用于获取请求的Cookie值 1234@RequestMapping(\"/hello\")public String hello(@CookieValue(value = \"JSESSIONID\",defaultValue = \"\") String cookie) &#123; return \"hello world\";&#125; @ModelAttribute作用 用于把参数保存到model中，可以注解方法或者参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在session中， 这个注解在使用的时候，如果没有指定名称，就默认按照返回类型的类名称（首字母小写）作为属性名称； @SessionAttributes作用 默认情况下，Spring MVC将模型中的数据存储在request域中。当一个请求结束的时候，数据就失效了，如果想要跨页面使用，就需要用的session。而SessionAttributes注解就可以使模型中数据存储一份到session中。","categories":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://wysblogs.top/categories/Spring-MVC/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://wysblogs.top/tags/Spring-MVC/"}]},{"title":"SpringBoot（二）配置","slug":"SpringBoot（二）配置","date":"2019-10-20T13:09:28.000Z","updated":"2019-10-20T13:10:29.191Z","comments":true,"path":"2019/10/20/SpringBoot（二）配置/","link":"","permalink":"http://wysblogs.top/2019/10/20/SpringBoot（二）配置/","excerpt":"","text":"SpringBoot（二）配置配置文件SpringBoot使用一个全局的配置文件，配置文件名称是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好了； YAML （YAML Ain’t Markup Language） YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言 标记语言： 以前的配置文件：大多数都使用的是XXXX.xml文件； YAML：以数据为中心，比json，xml更适合做配置文件； YAML：语法配置例子 12server: port: 8081 XML：配置 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YAML语法基本语法 key:(空格)value ： 表示一对键值对； 以空格的缩进来控制层级关系； 只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感的； 值的写法字面量：普通的值（数字，字符串，布尔）： key: Value ：字面直接来写； 字符串默认不用加上单引号或者双引号； “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: “zhangsan\\n lisi”：输出：zhangsan 换行 lisi ‘’: 单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: “zhangsan\\n lisi”：输出：zhangsan\\n lisi 对象、Map（属性和值）（键值对）： key: value : 在下一行来写对象的属性和值的关系；注意缩进 对象还是 key: value的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: &#123;cat,dog,pig&#125; 配置文件值注入：配置文件123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2019/10/10 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 JavaBean 12345678910111213141516171819202122232425262728293031package com.wys.springboot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * ConfigurationProperties：告诉SpringBoot将本类中所有属性和配置文件中相关的配置进行绑定 * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 我们可以导入配置文件处理器，以后编写配置就有提示了； 123456789&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 中文乱码idea中默认使用的是utf-8编码，所以需要去设置中，将 File Encodings 中的编码类型全都改成utf-8，并且将最下面的把utf-8编码转换成ascill码给勾上去。 @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value; 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 松散绑定属性松散绑定表示驼峰式、下划线(_)、短横线(-) 标准方式person.firstName 方式一大写用-person.first-name 方式二大写用_person.first_name 三种方式，都可以使用推荐，属性书写方式PERSON_FIRST_NAME @PropertySource&amp;@ImportResource@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")//@Validated@PropertySource(value=&#123;\"classpath:person.properties\"&#125;)public class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"张三/$&#123;key&#125; 从环境变量、配置文件获取值/#&#123;spEL&#125;\"&gt;&lt;/property&gt; * &lt;/bean&gt; */ //@Value(\"$&#123;person.last-name&#125;\") //lastName必须是邮箱类型 //@Email private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"false\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring配置文件生效，加载进来；@ImportResource标注在配置类上； 1@ImportResource(value = &#123;\"classpath:beans.xml\"&#125;) 不来编写Spring的配置文件 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.wys.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring Boot 推荐给容器中添加组件的方式：推荐使用全注解的方式； 配置类 ==== Spring配置文件 使用@Bean给容器中添加组件 12345678910111213@Configurationpublic class MyAppConfig &#123; /** * 将方法的返回值添加到容器中，容器中这个组件默认id就是方法名 * @return */ @Bean public HelloService helloService() &#123; System.out.println(\"给容器中添加组件了\"); return new HelloService(); &#125;&#125; 配置文件占位符随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int&#123;1024,65536&#125;&#125; 占位符获取之前配置的，如果没有可以使用:指定默认值 123456789person.last-name=李四$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2019/10/10person.boss=falseperson.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 Profile概念 Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境 多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-(profile).properties/yml 默认使用application.properties配置； yml支持多文档块模式 12345678910111213141516server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定profile 在配置文件中指定 spring.profiles.active=dev 命令行： –spring.profiles.active=dev 可以直接在测试的时候，配置传入命令行参数 虚拟机参数： -Dspring.profiles.active=dev 配置文件加载位置spring boot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring Boot的默认配置文件 file:./config/ file:./ classpath:/config/ classpath:/ 以上是按照优先级从高到底的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 我们也可以通过配置spring.config.location来改变默认配置 Spring Boot会从这四个位置全部加载主配置文件：互补配置； 外部配置加载顺序Spring Boot支持多种外部配置方式 这些方式的优先级如下： 命令行参数 java -jar spring-boot-01-config-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context.path=/abc 多个配置用空格分开；–配置项=值 来自java:comp/env的JNDI属性 java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找 优先加载带profile jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 自动配置原理： SpringBoot启动的时候加载朱配置类，开启了自动配置功能@EnableAutoConfiguration @EnableAutoConfiguration作用： 利用AutoConfigurationImportSelector给容器中导入了一些组件 可以查看selectImports()方法的内容； 1234springFactoriesLoader.loadFactoryName()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把它们添加在容器中 将类路径下的 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到了容器中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 每一个自动配置类进行自动配置功能； 以HttpEncodingAutoConfiguration来为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334@Configuration( //表示这是一个配置类，以前编写的配置文件一样，也可以给容器添加组件 proxyBeanMethods = false)@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中@ConditionalOnWebApplication( //Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；判断当前应用是否是web应用，如果是，当前配置类生效 type = Type.SERVLET)@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断当前项目有没有这个类，CharacterEncodingFilter；Spring MVC中进行乱码解决的过滤器；@ConditionalOnProperty( //判断配置文件是否存在某个配置spring.http.encoding.enabled;如果不存在，判断也是成立的 //即使我们配置文件中不配置spring.http.encoding.enabled=true,也是默认生效的； prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参的构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean //给容器添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 123456@ConfigurationProperties ( //从配置文件中获取指定的值和bean的属性进行绑定 prefix = \"spring.http\")public class HttpProperties &#123; private boolean logRequestDetails; private final HttpProperties.Encoding encoding = new HttpProperties.Encoding(); 精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfiguration：自动配置类； 给容器中添加组件 xxxxProperties：封装配置文件中相关属性； 细节Conditional@Conditional派生注解（可以自己去了解一下原生的作用） 作用：必须是@Conditional指定的条件成立，才给容器添加组件，配置里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符号要求 @ConditionalOnBean 容器中存在指定的Bean @ConditionalOnMissingBean 容器中不存在指定的Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean,或者这个Bean是首先Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在制定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定条件下才能生效 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； Positive matches:（自动配置类启用的） Negative matches：（没有启用，没有匹配成功的自动配置类）","categories":[{"name":"Spring Boot学习笔记","slug":"Spring-Boot学习笔记","permalink":"http://wysblogs.top/categories/Spring-Boot学习笔记/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wysblogs.top/tags/Spring-Boot/"}]},{"title":"SpringBoot（一）入门","slug":"SpringBoot（一）入门","date":"2019-10-19T13:09:06.000Z","updated":"2019-10-20T13:08:31.346Z","comments":true,"path":"2019/10/19/SpringBoot（一）入门/","link":"","permalink":"http://wysblogs.top/2019/10/19/SpringBoot（一）入门/","excerpt":"","text":"Spring Boot入门SpringBoot 简介 简化Spring应用开发的框架； 整个Spring技术栈的大整合； J2EE开发的一站式解决方案； 微服务2014年martin fowler提出的微服务； 微服务是一种架构风格； 一个应用应该是一组小型服务；可以通过HTTP的方式互通； 单体应用：ALL IN ONE； 把整个应用打成war包就可以部署到服务器上； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 详细参照微服务文档 Spring Boot优缺点Spring Boot 官网 Spring Boot 来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。 底层就是Spring技术栈 SpringBoot优点 快速创建独立运行的Spring项目以及主流框架集成 快速嵌入式的Servlet容器，应用无需打成war包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 SpringBoot缺点 入门容易，精通难 SpringBoot封装机制不好懂 对底层api必须特别了解 Spring Boot 例子HelloWorld一个功能 浏览器发送hello请求，服务器接受请求并处理，响应hello world字符串。 1. 创建maven工程 jar包 2. 导入SpringBoot需要的依赖 官网中可以查找到依赖 Maven依赖 12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 编写一个主程序，启动Spring Boot应用 123456789101112131415161718package com.wys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.swing.*;/** * Spring应用 * @SpringBootApplication 来标注一个主程序类,说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldApplication.class,args); &#125;&#125; 4. 编写相关的Controller、Service 123456789101112131415package com.wys.HelloController;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5. 运行主程序测试 6. 简化部署 可执行jar包 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 导入这个maven插件就行，就可以将这个应用打成jar包，直接使用java -jar的命令进行执行 HelloWorld探究POM文件父项目 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本； 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web; spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成了一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 主程序类，主入口类1234567891011121314151617package com.wys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * Spring应用 * @SpringBootApplication 来标注一个主程序类,说明这是一个Spring Boot应用 * 主程序要放在包的位置，不然找不到页面 */@SpringBootApplicationpublic class HelloWorldApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldApplication.class,args); &#125;&#125; @SpringBootApplication： Spring Boot应用标注在某个类上，说明这个类是SpringBoot的主配置类，说明Spring Boot 就应该运行这个累的main方法，来启动SpringBoot应用。 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)@ConfigurationPropertiesScanpublic @interface SpringBootApplication &#123; @SpringBootConfiguration： Spring Boot的配置类； 标注在某个类上，表示这是一个Spring Boot的配置类； @Configuration：配置类上来标注这个注解； 配置类 —— 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置； 这个注解告诉SpringBoot开启自动配置功能；这样自动配置才能生效 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage：自动配置包 @Import({Registrar.class})； Spring的底层注解@Import，给容器导入一个组件；导入的组件Registrar.class 将主配置类（@SpringBootApplication标注的类）所在的包及所有子包里面的所有组件扫描到Spring容器中。 @Import({AutoConfigurationImportSelector.class})： 给容器中导入组件 AutoConfigurationImportSelector：导入哪些组件的选择器 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器导入所有组件，并配置好这些组件； 有了自动配置类，就免去了我们手动编写配置注入功能组件的工作； 以前我们需要自己配置的东西，自动配置类都帮我们配置了； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包中 使用Spring Initializer快速创建Spring Boot项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目 默认生成的Spring Boot项目： 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中的目录结构 static文件夹：保存所有的静态资源；js文件，css文件，图片文件等； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker，thymeleaf）； application.properties：Spring Boot应用的配置文件；","categories":[{"name":"Spring Boot学习笔记","slug":"Spring-Boot学习笔记","permalink":"http://wysblogs.top/categories/Spring-Boot学习笔记/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wysblogs.top/tags/Spring-Boot/"}]},{"title":"Spring和MyBatis整合","slug":"Spring和MyBatis整合","date":"2019-10-15T15:43:54.000Z","updated":"2019-10-15T15:45:09.105Z","comments":true,"path":"2019/10/15/Spring和MyBatis整合/","link":"","permalink":"http://wysblogs.top/2019/10/15/Spring和MyBatis整合/","excerpt":"","text":"Spring和MyBatis整合因为学完了Spring和MyBatis，SpringMVC只看了书，没有敲实际代码，所以现在整合一下Spring和MyBatis然后敲个代码练练手，之后还会更新SSM全部整合。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mybatis_pratices_day(4)&lt;/groupId&gt; &lt;artifactId&gt;mybatis_pratices_day(4)&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context Spring应用上下文 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core Spring核心容器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans Bean模块提供BeanFactory，它是一个工厂模型的复杂实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop 为Spring提供了面向切面的编程方式 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring 整合Spring和MyBatis所需要的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 c3p0数据连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j 提供日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis mybatis核心jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit 测试环境 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test Spring单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring-config.xml因为要整合Spring和MyBatis所以不再使用mybatis-config.xml，统一整合到spring-config.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"com\"&gt;&lt;/context:component-scan&gt; &lt;!--引入配置文件 context:property-placeholder --&gt; &lt;context:property-placeholder location=\"jdbc-config.properties\"&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!--配置信息--&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"initialPoolSize\" value=\"10\"&gt;&lt;/property&gt; &lt;property name=\"maxIdleTime\" value=\"30\"&gt;&lt;/property&gt; &lt;property name=\"maxPoolSize\" value=\"100\"&gt;&lt;/property&gt; &lt;property name=\"minPoolSize\" value=\"10\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--mybatis配置--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--加载数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!--扫描mapper文件--&gt; &lt;property name=\"mapperLocations\" value=\"com/dao/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--dao接口所在包名，Spring会自动查找其下的类 Mybatis MapperScannerConfigurer 自动扫描 将Mapper接口生成代理注入到Spring 整合spring与mybatis --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.dao\"/&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 事务管理 事务是数据库中的概念，就是对数据库的一组操作，由一条或多条sql组成。 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml由于在spring-config.xml中就可以搜索mapper文件了，所以我就没有用这个 dao1234567891011121314151617181920package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * User持久层 */@Mapperpublic interface UserDao &#123; /** * 查找所有用户 * @return */ List&lt;User&gt; selectAllUser();&#125; mapper.xml1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.dao.UserDao\"&gt; &lt;select id=\"selectAllUser\" resultType=\"com.pojo.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类123456789101112131415161718192021package com.test;import com.dao.UserDao;import com.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;\"classpath:spring-config.xml\"&#125;)public class UserTest &#123; @Autowired private UserService userService; @Test public void testDao() &#123; System.out.println(userService.selectAllUser()); &#125;&#125; 整个上面就是一个完整的整合过程，剩下的内容就需要自己添加了 问题在整合过程中出现了很多很多问题，最后发现是在spring-config.xml中配置mybatis时，多写了个参数 1234567&lt;!--mybatis配置--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--加载数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!--扫描mapper文件--&gt; &lt;property name=\"mapperLocations\" value=\"com/dao/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; 这个地方配置了很长时间，是最容易出问题的地方，以后要注意。 上面就是spring与mybatis整合的过程，由于Spring和Spring MVC相近的关系，所以在此配置信息的基础上，加进去spring mvc应该就可以用了。 如果还有问题，我还会继续记录下来。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://wysblogs.top/categories/Spring/"}],"tags":[{"name":"Spring和MyBatis整合","slug":"Spring和MyBatis整合","permalink":"http://wysblogs.top/tags/Spring和MyBatis整合/"}]},{"title":"Maven课上学习（二）","slug":"Maven课上学习（二）","date":"2019-10-10T23:15:39.000Z","updated":"2019-10-20T13:14:48.039Z","comments":true,"path":"2019/10/11/Maven课上学习（二）/","link":"","permalink":"http://wysblogs.top/2019/10/11/Maven课上学习（二）/","excerpt":"","text":"Maven课上学习（二）课前提问1. 介绍一下maven： 答： maven是一个纯java编写的，具有开源，跨平台，标准化的项目管理工具。 2. 跨平台的意思： 答：跨操作系统平台和IDE平台。 3. IDE是什么： 答： IDE是一个集成开发环境，例如 eclipse，idea等工具。 4. 标准化是什么意思： 答：项目构建标准化，可以跨操作系统平台，项目结构标准化，可以跨IDE平台 上课内容手工创建maven项目包的命名包的名称一般由四到五部分构成： 第一部分：甲方公司域名的倒叙，开发方域名倒叙。原因是为了保证当前项目的全球唯一性。 例如：cn.edu.aynu 和 ip 对应一一关系，之前用的ipv4，不够用，现在都在用ipv6，用不完。 第二部分：项目名称。为了保证在当前公司内部当前项目的唯一性。 例如： cn.edu.aynu.sms 第三部分：模块名称。为了保证资源在当前项目中的唯一性。 例如： cn.edu.aynu.sms.aaa.bbb.ccc 第四部分：功能顶层包。其是为了体现当前包中资源的功能特点。 例如：cn.edu.aynu.sms.aaa.bbb.ccc.service 例如：cn.edu.aynu.sms.aaa.bbb.ccc.dao 第五部分：impl子包。用于存放其父包中接口的实现类。 例如：cn.edu.aynu.sms.aaa.bbb.ccc.service.impl 项目结构标准化 maven常用命令查看命令帮助 mvn -h 清理target mvn clean （这个命令一般都是与其他命令结合使用的） 编译 mvn clean compile 测试 mvn clean test 打包 mvn clean package 安装包 mvn clean install 创建项目骨架（maven3） mvn archetype:generate 创建项目骨架（maven2） mvn org.apache.maven.plugins:maven-archetype-plugin:2.0-alpha-5:generate 查看当前项目已解析依赖 mvn dependency:list 查看当前项目的依赖树 mvn dependency:tree 分析当前项目的依赖 mvn dependency:analyze 将项目构建输出的构建部署到配置对应的远程仓库 mvn clean deploy …… 剩下的感觉都用不到，先不写，用到的时候再记录","categories":[{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/categories/Maven学习/"}],"tags":[{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/tags/Maven学习/"}]},{"title":"Ajax","slug":"Ajax","date":"2019-10-07T11:47:39.000Z","updated":"2019-10-07T11:51:24.189Z","comments":true,"path":"2019/10/07/Ajax/","link":"","permalink":"http://wysblogs.top/2019/10/07/Ajax/","excerpt":"","text":"Ajax学习介绍AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面 写法1234567891011121314151617181920//方式一:使用post请求的方式,不通过url传参,采用data传参 $.ajax(&#123; url:\"$&#123;pageContext.request.contextPath&#125;/请求的控制器\",//访问的地址 type:\"post\", data:&#123;key:value&#125;, dataType:'text',//后台返回的数据格式类型 //回调函数 success:function(data,status) &#123; &#125;&#125;)//方式二:使用get请求的方式，通过url传参$.ajax(&#123; url:\"$&#123;pageContext.request.contextPath&#125;/请求的控制器?参数\", type:\"get\", dataType:'text', success:function(data,status) &#123; &#125;&#125;)","categories":[{"name":"Ajax","slug":"Ajax","permalink":"http://wysblogs.top/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://wysblogs.top/tags/Ajax/"}]},{"title":"Spring MVC学习笔记（一）","slug":"Spring-MVC学习笔记（一）","date":"2019-10-07T11:42:42.000Z","updated":"2019-10-07T11:46:38.554Z","comments":true,"path":"2019/10/07/Spring-MVC学习笔记（一）/","link":"","permalink":"http://wysblogs.top/2019/10/07/Spring-MVC学习笔记（一）/","excerpt":"","text":"Spring MVC学习笔记（一）Spring MVC的优势Spring 框架提供了构建Web应用程序的全功能MVC模块——Spring MVC。Spring MVC框架提供了一个DispatcherServlet作用前端控制器来分派请求，同时提供灵活的配置处理程序映射，视图解析，语言环境和主题解析，并支持文件上传。Spring MVC还包含多种视图技术，例如 Java Server Pages（JSP），Velocity，Tiles，iText和POI等。Spring MVC 分离了控制器，模型对象，分派器以及处理程序对象的角色，这种分离让他们更容易进行定制。 Spring MVC的特点 拥有强大的灵活性，非侵入性和可配置性。 提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象。 分工明确，包括控制器，验证器，命令对象，模型对象，处理程序映射视图解析器，等等，每一个功能实现由一个专门的对象完成。 可以自动绑定用户输入，并正确地转换数据类型。例如，Spring MVC能自动解析字符串，并将其设置为模型的int或float类型的属性。 使用一个名称/值Map对象实现更加灵活的模型数据传输。 内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式。 支持国际化，支持根据用户区域显示多国语言，并且国际化的配置非常简单。 支持多种视图技术，最常见的有JSP技术以及其他技术，包括Velocity和FreeMarker。 提供了一个简单而强大的JSP标签库，支持数据绑定功能，使得编写JSP页面更加容易。 第一个应用程序创建maven项目 选择这个创建 改变项目部署路径 导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置web.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--welcome pages--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置springmvc DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置dispatcher.xml作为mvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--把applicationContext.xml加入到配置文件中--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 配置dispatcher-servlet.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--此文件负责整个mvc中的配置--&gt; &lt;!--启用spring的一些annotation --&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源映射--&gt; &lt;!--本项目把静态资源放在了webapp的statics目录下，资源映射如下--&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/statics/css/\"/&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/statics/js/\"/&gt; &lt;mvc:resources mapping=\"/image/**\" location=\"/statics/images/\"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--这句要加上，要不然可能会访问不到静态资源，具体作用自行百度--&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id=\"defaultViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;property name=\"exposeContextBeansAsAttributes\" value=\"true\"/&gt; &lt;/bean&gt; &lt;!-- 自动扫描装配 --&gt; &lt;context:component-scan base-package=\"com.controller\"/&gt;&lt;/beans&gt; 配置spring-config.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; Controller类 123456789101112131415161718package com.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/home\")public class HelloController &#123; @RequestMapping(\"/welcome\") public String welcome()&#123; return \"welcome\"; &#125; @RequestMapping(\"/index\") public String index() &#123; return \"index\"; &#125;&#125; 运行","categories":[{"name":"Spring MVC学习笔记","slug":"Spring-MVC学习笔记","permalink":"http://wysblogs.top/categories/Spring-MVC学习笔记/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://wysblogs.top/tags/Spring-MVC/"}]},{"title":"MyBatis学习笔记（三）","slug":"MyBatis学习笔记（三）","date":"2019-09-26T13:10:42.000Z","updated":"2019-09-26T13:12:02.793Z","comments":true,"path":"2019/09/26/MyBatis学习笔记（三）/","link":"","permalink":"http://wysblogs.top/2019/09/26/MyBatis学习笔记（三）/","excerpt":"","text":"MyBatis学习笔记（三）目标这部分内容是为了实现一次mybatis的增删改查（CRUD）操作，以及一些模糊查询等内容。 实现因为增删改查内容比较集中，所以这次完成操作后，把代码整理到一起 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", address='\" + address + '\\'' + \", sex='\" + sex + '\\'' + \", birthday=\" + birthday + '&#125;'; &#125;&#125; 持久层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.dao;import com.pojo.User;import java.util.List;/** * * 用户持久层接口 */public interface UserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll(); /** * 根据ID查询 * @param id * @return */ User findOneById(Integer id); /** * 保存用户 * @param user * @return */ int saveUser(User user); /** * 更新用户 * @param user * @return */ int updateUser(User user); /** * 删除用户 * @param id * @return */ int deleteUser(Integer id); /** * 模糊查询用户信息 * @param name * @return */ List&lt;User&gt; findByName(String name); /** * 获取用户总记录数 * @return */ int findTotal();&#125; mybatis-config配置文件 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置个mysql环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?useUnicoder=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"wang123\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/dao/UserDao.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper映射文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.dao.UserDao\"&gt; &lt;!--查询所有操作--&gt; &lt;select id=\"findAll\" resultType=\"com.pojo.User\"&gt; select * from user &lt;/select&gt; &lt;!--根据Id查询--&gt; &lt;select id=\"findOneById\" resultType=\"com.pojo.User\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--插入用户操作--&gt; &lt;insert id=\"saveUser\" parameterType=\"com.pojo.User\"&gt; &lt;!--配置插入成功后，获取插入数据的id keyproperty id 实体类的 keyColumn id 数据库的 resultType 映射值类型 order 在什么时候执行 不写这个的时候，执行完插入后，id值为null，写了之后可以获取到具体id值 --&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt; select last_insert_id() &lt;/selectKey&gt; insert into User(username, address, sex, birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;) &lt;/insert&gt; &lt;!--更新用户操作--&gt; &lt;update id=\"updateUser\" parameterType=\"com.pojo.User\"&gt; update User set username = #&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--删除用户操作--&gt; &lt;delete id=\"deleteUser\" parameterType=\"Integer\"&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt; &lt;!--根据用户名称查询--&gt; &lt;select id=\"findByName\" parameterType=\"String\" resultType=\"com.pojo.User\"&gt; &lt;!-- 参数占位符 select * from user where username like #&#123;username&#125; --&gt; &lt;!--字符串拼接写法，比较的话上面那个好--&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!--测试用户总数量--&gt; &lt;select id=\"findTotal\" resultType=\"int\"&gt; select count(id) from user &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;/** * MyBatis的CRUD操作 */public class MyBatisTest &#123; private SqlSession session; private UserDao userDao; @Before public void before() throws Exception&#123; InputStream in = Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); session = sqlSessionFactory.openSession(); userDao = (UserDao)session.getMapper(UserDao.class); &#125; @After public void after() &#123; session.commit(); session.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User i : users) &#123; System.out.println(i); &#125; &#125; /** * 根据ID查询 */ @Test public void testfindOneById() &#123; User user = userDao.findOneById(1); System.out.println(user); &#125; /** * 测试添加用户 */ @Test public void testSaveUser() &#123; User user = new User(); user.setUsername(\"testSaveUser--1\"); user.setSex(\"女\"); user.setAddress(\"北京\"); user.setBirthday(new Date()); //保存操作之前 //System.out.println(user); userDao.saveUser(user); //保存操作之后 System.out.println(user); &#125; /** * 测试用户更新信息 */ @Test public void testUpdateUser() &#123; User user = new User(); //因为没有查询所以，只能指定修改人id user.setId(2); user.setUsername(\"testUpdateUser\"); user.setAddress(\"北京\"); user.setSex(\"女\"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; /** * 测试用户删除操作 */ @Test public void testDeleteUser() &#123; userDao.deleteUser(1); &#125; /** * 根据用户姓名进行模糊查询 */ @Test public void testUserByName() &#123; //模糊查询是需要有百分号的，但是xml文件中的执行语句是没有的，需要自己添加 //第一种写法参数占位符 这个好，使用了预处理 //List&lt;User&gt; users = userDao.findByName(\"%老%\"); //第二种写法字符串拼接写法 List&lt;User&gt; users = userDao.findByName(\"老\"); for(User i : users) &#123; System.out.println(i); &#125; &#125; @Test public void testfindTotal() &#123; int total = userDao.findTotal(); System.out.println(total); &#125;&#125; 数据库文件的话自己可以根据上面的实体类来创建 详细内容都在代码上有注释，可以参考参考","categories":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/categories/MyBatis学习/"}],"tags":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/tags/MyBatis学习/"}]},{"title":"JAVAEE框架第二次作业","slug":"JAVAEE框架第二次作业","date":"2019-09-25T16:05:06.000Z","updated":"2019-09-25T16:13:05.439Z","comments":true,"path":"2019/09/26/JAVAEE框架第二次作业/","link":"","permalink":"http://wysblogs.top/2019/09/26/JAVAEE框架第二次作业/","excerpt":"","text":"JAVAEE框架第二次作业一对多（one-to-many）分析首先思考一下，一对多的关系都有哪些，很容易我们就可以想到，文章，一个人可以发很多篇文章，但是每篇文章只能对应一个人，这就是一对多关系，除此之外，还可以想到父子关系，一个父亲可以有多个孩子，但是每个孩子只能对应一个父亲，了解完关系之后，我们就能开始着手写了。 建表我们以作者和文章的关系来创建数据库的表，首先了解作者和文章的属性，然后确定数据库表的主键和外键。 作者（Author）属性: 作者编号，作者名称；其中主键是作者编号。编号为自增序列。 文章（Article）属性： 文章编号，文章名称，文章内容； 其中主键是文章编号，编号是自增序列。 建表： 理清楚上面关系后我们建表开始，sql命令如下： 12345678910111213create table article( article_id int not null auto_increment, name varchar(35) not null, content varchar(255), author_id int not null, primary key(article_id));create table author( author_id int not null auto_increment, name varchar(35) not null, primary key(author_id)); 这样我们就有了一个article表和author表，然后就可以写后台了。 pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pojo;import java.util.AbstractList;import java.util.ArrayList;import java.util.List;/** * 作者的实体类 */public class Author &#123; //作者编号 private int id; //作者名称 private String name; //作者所著文章 建立一对多关系 private List&lt;Article&gt; articles; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Article&gt; getArticles() &#123; return articles; &#125; public void setArticles(List&lt;Article&gt; articles) &#123; this.articles = articles; &#125; @Override public String toString() &#123; return \"Author&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", articles=\" + articles + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.pojo;/** * 文章的实体类 */public class Article &#123; //文章编号 private int id; //文章名称 private String name; //文章内容 private String content; //作者 建立多对一关系 private Author author; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Author getAuthor() &#123; return author; &#125; public void setAuthor(Author author) &#123; this.author = author; &#125; @Override public String toString() &#123; return \"Article&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", content='\" + content + '\\'' + \", author=\" + author + '&#125;'; &#125;&#125; 导入依赖（包名省略） 创建持久层 12345678910111213141516171819202122package com.dao;import com.pojo.Article;import com.pojo.Author;import java.util.List;/** * 作者的持久层 * 我们这个只需要完成一个一对多查询就行 * 所以只写了一个方法 */public interface AuthorDao &#123; /** * 查询作者所有文章 * @param id * @return */ Author selectArticlesList(int id);&#125; 创建mybatis配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;!--这个密码是我自己的，有需要可以修改--&gt; &lt;property name=\"password\" value=\"wang123\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;!--可以XML配置，可以注解，这里就用xml配置了--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/dao/Author.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建mapper映射文件 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.dao.AuthorDao\"&gt; &lt;!--一对多写法--&gt; &lt;resultMap id=\"AuthorMap\" type=\"com.pojo.Author\"&gt; &lt;id column=\"author_id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"author_name\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"articles\" ofType=\"com.pojo.Article\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"content\" property=\"content\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--别名要加空格--&gt; &lt;select id=\"selectArticlesList\" parameterType=\"int\" resultMap=\"AuthorMap\"&gt; select a.id author_id,a.name author_name, b.* from author a left join article b on a.id = b.author_id where a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import java.io.*;import java.util.List;import com.dao.AuthorDao;import com.pojo.Article;import com.pojo.Author;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;public class AuthorTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before() throws IOException &#123; InputStream in = Resources.getResourceAsStream(\"mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); &#125; /** * 获取作者所写的所有文章 */ @Test public void getArticles() &#123; SqlSession session = sqlSessionFactory.openSession(); AuthorDao authorDao = session.getMapper(AuthorDao.class); Author author = authorDao.selectArticlesList(1); for(Article i : author.getArticles()) &#123; System.out.println(i.getName()); &#125; &#125;&#125; 多对一多对一在一对一基础上进行修改，增加了一个持久层和mapper文件，就是根据多个文章查找到作者信息。 持久层 1234567891011121314151617package com.dao;import com.pojo.Article;import com.pojo.Author;/** * 文章持久层 */public interface ArticleDao &#123; /** * 根据帖子ID查找作者信息 * @param id * @return */ Article selectAuthorByArticle(int id);&#125; mapper 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dao.ArticleDao\"&gt; &lt;resultMap id=\"ArticleMap\" type=\"com.pojo.Article\"&gt; &lt;id column=\"article_id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"article_name\" property=\"name\"&gt;&lt;/result&gt; &lt;result column=\"content\" property=\"content\"&gt;&lt;/result&gt; &lt;!--存储查询的用户所属信息--&gt; &lt;association property=\"author\" javaType=\"com.pojo.Author\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"selectAuthorByArticle\" resultMap=\"ArticleMap\" parameterType=\"int\"&gt; select b.* from article a,author b where b.id= a.author_id and a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789@Testpublic void getAuthor() &#123; SqlSession session = sqlSessionFactory.openSession(); ArticleDao articleDao = session.getMapper(ArticleDao.class); Article article = articleDao.selectAuthorByArticle(1); System.out.println(article.getAuthor().getName()); session.close();&#125; 大概就上面那么多了，剩下的等上完课再进行修改吧。。。 还是有很多知识都不懂，很难受。。。","categories":[{"name":"JAVAEE框架作业","slug":"JAVAEE框架作业","permalink":"http://wysblogs.top/categories/JAVAEE框架作业/"}],"tags":[{"name":"JAVAEE框架作业","slug":"JAVAEE框架作业","permalink":"http://wysblogs.top/tags/JAVAEE框架作业/"}]},{"title":"JAVAEE读书笔记（四）","slug":"JAVAEE读书笔记（四）","date":"2019-09-23T14:56:22.000Z","updated":"2019-09-23T15:09:27.985Z","comments":true,"path":"2019/09/23/JAVAEE读书笔记（四）/","link":"","permalink":"http://wysblogs.top/2019/09/23/JAVAEE读书笔记（四）/","excerpt":"","text":"JAVAEE读书笔记（四）Spring AOP的基本概念AOP（Aspect-Oriented Programming）即面向切面编程，他与OOP（Object-Oriented Programming,面向对象编程）相辅相成。 在OOP中，以类作为程序的基本单元，而AOP中的基本单元是Aspect（切面）。Struts2的拦截器设计就是基于AOP的思想，是一个比较经典的应用。 在业务处理代码中通常由日志记录，性能统计，安全控制，事务处理，异常处理等操作，尽管使用OOP可以封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中，因此，采用OOP等日志记录等操作不仅增加了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题，AOP思想应允而生。 AOP采取横向抽取机制，即将分散在各个方法中的重复代码提取出来，然后在程序编译或者运行阶段，将这些抽取出来的代码应用到需要执行的地方。这种横向抽取机制采用传统的OOP是无法办到的，因为OOP实现的是父子关系的纵向重用。但是AOP不是OOP的替代品，而是OOP的补充，他们是相辅相成的。 在AOP中，横向抽取机制的类与切面的关系如图所示： AOP的术语 名称 意义 切面 切面（Aspect）是指封装横切到系统功能（例如事务处理）的类。 连接点 连接点（Joinpoint）是指程序运行中的一些时间点，例如方法的调用或异常的抛出。 切入点 切入点（Pointcut）是指需要处理的连接点。在Spring Aop中，所有的方法执行都是连接点，二切入点是一个面熟信息，他修饰的是连接点，通过切入点确定那些连接点需要被处理。 通知 通知（Advice）是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。 引入 引入（Introduction）允许在现有的实现类中添加自定义的方法和属性 目标对象 目标对象（Target Object）是指所有被通知的对象。如果AOP框架使用运行时代代理的方式（动态AOP）来实现切面，那么通知对象总是一个代理对象。 代理 代理（Proxy）是通知应用到目标对象之后被动态创建的对象。 织入 织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术，AOP织入有3种方式：编译器织入，需要有特殊的java编译器；类装载期织入，需要有特殊的类装载器；动态代理织入，在运行期为目标类添加通知生成子类的方式。Spring AOP框架默认采用动态代理织入，而AspectJ（基于java语言的AOP框架）采用编译期织入和类装载期织入。 AOP依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 这些是aop依赖的核心部分 剩下的就是spring核心jar包了，此处就不一一列举 基于XML的AOPxml配置 12345678910111213141516&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* *.*(..))\"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=\"MyAspect\"&gt; &lt;!--前置通知--&gt; &lt;aop:before method=\"beforeAdvice\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:before&gt; &lt;!--后置通知--&gt; &lt;aop:after method=\"afterAdvice\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:after&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method=\"exceptionAdvice\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:after-throwing&gt; &lt;!--最终通知--&gt; &lt;aop:after-returning method=\"finallyAdvice\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:after-returning&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 实现类 12345678910111213141516171819202122232425262728293031323334353637package com.util;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面 */public class MyAspect &#123; public void beforeAdvice() &#123; System.out.println(\"这是前置通知!-----比如创建连接对象\"); &#125; public void afterAdvice() &#123; System.out.println(\"这是后置通知!------比如提交事务\"); &#125; public void finallyAdvice() &#123; System.out.println(\"这是最终通知-------比如关闭连接\"); &#125; public void exceptionAdvice() &#123; System.out.println(\"这是异常通知-------比如回滚事务\"); &#125; public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println(\"这是前置通知!-----比如创建连接对象\"); try&#123; joinPoint.proceed(); System.out.println(\"这是后置通知!------比如提交事务\"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(\"这是异常通知-------比如回滚事务\"); &#125;finally &#123; System.out.println(\"这是最终通知-------比如关闭连接\"); &#125; &#125;&#125; 环绕通知 123456789&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* *.*(..))\"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=\"MyAspect\"&gt; &lt;aop:around method=\"aroundAdvice\" pointcut-ref=\"pointcut\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 执行顺序 前置通知： 在方法执行前执行 后置通知： 在方法执行后执行，如果有异常，就不会执行这个 最终通知： 执行完所有通知之后执行 异常通知： 发生异常的时候执行 环绕通知： 包含了以上四种通知类型 基于注解的AOP注解 名称 作用 @Aspect 表示这是一个切面类 @Before 在方法执行前执行 @After 在方法执行后执行，如果有异常，就不会执行这个 @AfterReturning 执行完所有通知之后执行 @AfterThrowing 发生异常的时候执行 @Around 包含了以上四种通知类型 @Pointcut 切入点表达式 切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.util;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * 切面 */@Aspect@Componentpublic class MyAspect &#123; @Pointcut(\"execution(* *.*(..))\") public void pointcut()&#123;&#125; @Before(\"pointcut()\") public void beforeAdvice() &#123; System.out.println(\"这是前置通知!\"); &#125; @After(\"pointcut()\") public void afterAdvice() &#123; System.out.println(\"这是后置通知!\"); &#125; @AfterReturning(\"pointcut()\") public void finallyAdvice() &#123; System.out.println(\"这是最终通知\"); &#125; @AfterThrowing(\"pointcut()\") public void exceptionAdvice() &#123; System.out.println(\"这是异常通知\"); &#125; @Around(\"pointcut()\") public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println(\"前置通知\"); try&#123; joinPoint.proceed(); System.out.println(\"后置通知\"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(\"异常通知\"); &#125;finally &#123; System.out.println(\"最终通知\"); &#125; &#125;&#125; 一定要给这个类使用Component注解，不然不会把这个加入Spring容器中 在XML中开启注解支持 12&lt;!--启动基于注解的Aspect的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 测试类不变 结果和上面一致 课后习题1. 什么是AOP？AOP有哪些术语？为什么要学习AOP编程？ AOP就是面向切面编程，术语的话参考上面的AOP术语。 AOP可以处理OOP不能处理的问题，AOP可以减少大量代码编写，抽取重复代码块，增加代码复用率，减少耦合性，使开发者逻辑更清晰，工作更简单。 2. 在Java中有哪些常用的动态代理技术？ Proxy Cglib 3. AspectJ框架的AOP开发方式有几种？ 基于XML的开发方式 基于注解的开发方式","categories":[{"name":"JAVAEE读书笔记","slug":"JAVAEE读书笔记","permalink":"http://wysblogs.top/categories/JAVAEE读书笔记/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/tags/学习/"}]},{"title":"Junit单元测试","slug":"Junit单元测试","date":"2019-09-23T13:17:08.000Z","updated":"2019-09-23T15:07:27.701Z","comments":true,"path":"2019/09/23/Junit单元测试/","link":"","permalink":"http://wysblogs.top/2019/09/23/Junit单元测试/","excerpt":"","text":"整合JUnit单元测试JUnit概述JUnit是一个基于java语言的单元测试框架，Junit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。 依赖所依赖的导包 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; spring-test是整合spring时所需要依赖的包 junit就是进行单元测试所需要依赖的包 还需要其他的Spring核心jar包，这就不一一列举了 注解RunWith@RunWith：就是一个运行器 @RunWith(JUnit4.class)：就是指用JUnit4来运行 @RunWith(SpringJUnit4ClassRunner.class)： 让测试运行于Spring测试环境 @RunWith(Suite.class)： 一套测试集合 ContextConfiguration概念： Spring整合JUnit4测试时，使用注解引入多个配置文件 单个文件： @ContextConfiguration(Locations=&quot;classpath:spring-config.xml&quot;) @ContextConfigruation(classes=Configuration.class) 多个文件： @ContextConfiguration(locations={&quot;classpath:spring-config1.xml&quot;,&quot;classpath:spring-config2.xml&quot;}) 样例123456789101112131415161718192021222324252627package com.test;import com.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * 初始化Spring容器 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:spring-config.xml\")public class AccountTest &#123; @Resource(name=\"accountService\") private AccountService accountService; @Test public void Test() &#123; accountService.saveAccount(); &#125;&#125;","categories":[{"name":"Junit","slug":"Junit","permalink":"http://wysblogs.top/categories/Junit/"}],"tags":[{"name":"Junit","slug":"Junit","permalink":"http://wysblogs.top/tags/Junit/"}]},{"title":"JAVAEE框架第一次作业","slug":"JAVAEE框架第一次作业","date":"2019-09-18T15:06:55.000Z","updated":"2019-09-18T15:22:00.417Z","comments":true,"path":"2019/09/18/JAVAEE框架第一次作业/","link":"","permalink":"http://wysblogs.top/2019/09/18/JAVAEE框架第一次作业/","excerpt":"","text":"JAVAEE框架第一次作业分析&nbsp;&nbsp;&nbsp;&nbsp;首先，我之前认为是为了优化实现类中的方法，所以想到了整合Spring然后利用AOP的事务通知来使持久层的实现类中方法解耦，后来才明白原来是直接将实现类中的方法整合在测试类中进行使用（是我太菜了，确信！） 代码整合删除实现类 &nbsp;&nbsp;&nbsp;&nbsp;这个过程是为了使测试类中提示错误，从而有针对性，便于修改 修改测试类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.abc;import static org.junit.Assert.assertTrue;import com.abc.beans.Student;import com.abc.dao.IStudentDao;import com.abc.utils.MyBatisUtil;import org.apache.ibatis.session.SqlSession;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Unit test for simple App. */public class MyTest&#123; private IStudentDao dao; private SqlSession sqlSession; @Before public void before() throws IOException &#123; sqlSession = MyBatisUtil.getSqlSession(); dao = sqlSession.getMapper(IStudentDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; /** * Rigorous Test :-) */ //插入学生信息 @Test public void Test01() &#123; Student student = new Student(\"王五\",21,80.5); System.out.println(\"插入前：\"+student); dao.insertStudent(student); sqlSession.commit(); System.out.println(\"插入后：\"+student); System.out.println(\"插入成功！\"); &#125; //获取新插入学生id @Test public void Test02() &#123; Student student = new Student(\"李四\",19,90.5); System.out.println(\"插入前：\"+student); dao.insertStudentCatchId(student); sqlSession.commit(); System.out.println(\"插入后：\"+student); System.out.println(\"插入成功！\"); &#125; //删除学生信息 @Test public void Test03() &#123; dao.deleteStudentById(29); sqlSession.commit(); System.out.println(\"删除成功！\"); &#125; //修改学生信息 @Test public void Test04() &#123; Student student = new Student(\"小绿\",22,96); student.setId(30); dao.updateStudent(student); sqlSession.commit(); System.out.println(\"修改成功！\"); &#125; //查询全部学生信息List @Test public void Test05() &#123; List&lt;Student&gt; students = dao.selectAllStudent(); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //查询全部学生信息Map @Test public void Test06() &#123; Map&lt;String,Student&gt; map = dao.selectAllStudentMap(); System.out.println(map.get(\"李四\")); &#125; //按照id查询学生信息 @Test public void Test07() &#123; Student student = dao.selectStudentById(30); System.out.println(student); &#125; //按照name查询学生信息 @Test public void Test08() &#123; List&lt;Student&gt; students = dao.selectStudentByName(\"小绿\"); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息1 //把多个参数封装到对象 @Test public void Test09() &#123; Student student = new Student(\"小\",20,-1); List&lt;Student&gt; students = dao.selectStudentByCondition(student); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息2 //把多个查询条件封装到map @Test public void Test10() &#123; Map map = new HashMap(); Student student1 = new Student(null,18,-1); Student student2 = new Student(null,22,-1); map.put(\"stu1\",student1); map.put(\"stu2\",student2); List&lt;Student&gt; students = dao.selectStudentByCondition2(map); for (Student s:students)&#123; System.out.println(s); &#125; &#125;&#125; Mapper配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.abc.dao.IStudentDao\"&gt; &lt;!-- 1.parameterType可以省略，但若不省略一定把后边的类型填写正确 2.sql语句中value中的内容，必须是#&#123;&#125;，其中name，age，score指的 是传入参数对象的属性，其底层是通过反射机制从参数对象的get方法获取相应的属性值 --&gt; &lt;insert id=\"insertStudent\" parameterType=\"com.abc.beans.Student\"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;/insert&gt; &lt;insert id=\"insertStudentCatchId\"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;selectKey resultType=\"int\" keyProperty=\"id\" order=\"AFTER\"&gt; select last_insert_id() &lt;!--select @@identity--&gt; &lt;/selectKey&gt; &lt;/insert&gt; &lt;delete id=\"deleteStudentById\" parameterType=\"int\"&gt; delete from student where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id=\"updateStudent\"&gt; update student set name=#&#123;name&#125;,age=#&#123;age&#125;,score=#&#123;score&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--resultType不是最终需要的结果类型，而是查询出每一条数据封装的结果类型--&gt; &lt;select id=\"selectAllStudent\" resultType=\"Student\"&gt; select id,name,age,score from student &lt;/select&gt; &lt;select id=\"selectStudentById\" resultType=\"Student\"&gt; select id,name,age,score from student where id = #&#123;xx&#125; &lt;/select&gt; &lt;select id=\"selectStudentByName\" resultType=\"Student\"&gt; &lt;!--select id,name,age,score from student where name like '%小%'--&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' &lt;!--select id,name,age,score from student where name like concat('%',#&#123;name&#125;,'%')--&gt; &lt;!--select id,name,age,score from student where name like '%$&#123;value&#125;%'--&gt; &lt;/select&gt; &lt;select id=\"selectStudentByCondition\" resultType=\"Student\"&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' and age &amp;lt; #&#123;age&#125; &lt;/select&gt; &lt;select id=\"selectStudentByCondition2\" resultType=\"Student\"&gt; &lt;!--select id,name,age,score from student where age &gt; #&#123;min&#125; and age &amp;lt; #&#123;max&#125;--&gt; select id,name,age,score from student where age &gt; #&#123;stu1.age&#125; and age &amp;lt; #&#123;stu2.age&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;中可以写什么内容： 1.若传入参数为基本数据类型，可以为任意字符，起占位符的作用 2.若传入参数为对象，必须为对象的属性 3.若传入参数为map 1）如果map中的值为基础数据类型，可以放map的key 2）如果map中的值为对象，可以放map的key.属性 --&gt;&lt;/mapper&gt; 由于配置文件和持久层中有些方法命名不匹配，所以我都进行了修改，持久层代码 12345678910111213141516171819202122232425262728package com.abc.dao;import com.abc.beans.Student;import java.util.List;import java.util.Map;public interface IStudentDao &#123; void insertStudent(Student student); void deleteStudentById(int id); void insertStudentCatchId(Student student); void updateStudent(Student student); List&lt;Student&gt; selectAllStudent(); Map&lt;String, Student&gt; selectAllStudentMap(); Student selectStudentById(int id); List&lt;Student&gt; selectStudentByName(String name); List&lt;Student&gt; selectStudentByCondition(Student student); List&lt;Student&gt; selectStudentByCondition2(Map map);&#125; &nbsp;&nbsp;&nbsp;&nbsp;同时如果出现无法连接数据库等问题，请到MyBatis配置文件中修改数据库连接的信息，或者也需要去修改你自己的MySQL数据库中的数据库或者表的信息。 以上便是整个过程，如果有错误，我会及时修改。","categories":[{"name":"JAVAEE框架作业","slug":"JAVAEE框架作业","permalink":"http://wysblogs.top/categories/JAVAEE框架作业/"}],"tags":[{"name":"JAVAEE框架作业","slug":"JAVAEE框架作业","permalink":"http://wysblogs.top/tags/JAVAEE框架作业/"}]},{"title":"JAVA代理","slug":"JAVA代理","date":"2019-09-18T13:08:47.000Z","updated":"2019-09-18T13:10:57.904Z","comments":true,"path":"2019/09/18/JAVA代理/","link":"","permalink":"http://wysblogs.top/2019/09/18/JAVA代理/","excerpt":"","text":"jAVA代理代理模式​ 使用一个代理对象将对象包装起来，然后用该代理对象来取代该对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时调用原始对象的方法 静态代理​ 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。如下图： ​ Client调用Source的method()方法，实际上是Proxy来调用method()方法，静态代理中Source跟Proxy都要实现接口Sourceable。 实现方式创建接口 123456789package com.proxy;public interface ClientDao &#123; /** * 主体内容 */ void content();&#125; 创建实现类 1234567891011package com.proxy;public class ClientDaoImpl implements ClientDao&#123; /** * 实现的方法 */ @Override public void content() &#123; System.out.println(\"这是主体内容\"); &#125;&#125; 创建代理类 12345678910111213141516package com.proxy;public class ClientStaticProxy implements ClientDao&#123; private ClientDao clientDao; public void setClientDao(ClientDao clientDao) &#123; this.clientDao = clientDao; &#125; @Override public void content() &#123; System.out.println(\"对方法增强前\"); clientDao.content(); System.out.println(\"对方法增强后\"); &#125;&#125; 测试类 1234567891011121314package com.test;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientStaticProxy clientStaticProxy = new ClientStaticProxy(); ClientDao clientDao = new ClientDaoImpl(); clientStaticProxy.setClientDao(clientDao); clientStaticProxy.content(); &#125;&#125; 结果 优点 可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截 缺点 因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增强方法，则目标对象和代理类都需要维护。 动态代理JDK代理​ 动态代理是指动态在内存中构建代理对象（需要我们指定要代理的目标对象实现的接口类型），利用JDK的API生成指定接口的对象，也称为JDK代理或者接口代理。 ​ 下面是原理图片： ​ 因为上面创建过类了，所以现在只需要创建动态代理类即可 1234567891011121314151617181920212223242526272829303132333435package com.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 动态代理类 */public class ClientAutoProxy &#123; //被代理的对象 private Object targetObject; public ClientAutoProxy(Object targetObject) &#123; this.targetObject = targetObject; &#125; public Object getProxyInstance() &#123; return Proxy.newProxyInstance( //代理对象的类加载器 targetObject.getClass().getClassLoader(), //目标对象实现的接口，因为需要根据接口动态生成对象 targetObject.getClass().getInterfaces(), //InvocationHandler:事件处理器，即对目标对象方法的执行进行处理 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"方法增强前\"); Object resultValue = method.invoke(targetObject, args); System.out.println(\"方法增强后\"); return resultValue; &#125; &#125;); &#125;&#125; 测试类 123456789101112131415package com.test;import com.proxy.ClientAutoProxy;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientDao clientDao = new ClientDaoImpl(); ClientAutoProxy clientAutoProxy = new ClientAutoProxy(clientDao); ClientDao clientDaoProxy = (ClientDao)clientAutoProxy.getProxyInstance(); clientDaoProxy.content(); &#125;&#125; 结果与之前一样 需要注意的地方： 1Object resultValue = method.invoke(targetObject, args); ​ 这条语句在执行的时候，一开始我把targetObject对象写成了proxy对象，导致程序进入了死循环，经百度之后，了解到，因为proxy对象表示当前代理对象，这么调用之后又会调用到SimpleInvocationHandler的invoke方法，这个就要涉及到底层原理知识了，现阶段不过多讨论。 ​ 还有就是，在测试类中，因为返回类型为Object类型的对象，所以需要强转为所需要的类型。 优点 ​ 代理对象不需要实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需要在事件处理器中添加对方法的判断即可。 缺点 ​ 代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。","categories":[{"name":"JAVA代理","slug":"JAVA代理","permalink":"http://wysblogs.top/categories/JAVA代理/"}],"tags":[{"name":"JAVA代理","slug":"JAVA代理","permalink":"http://wysblogs.top/tags/JAVA代理/"}]},{"title":"Maven课上学习（一）","slug":"Maven课上学习（一）","date":"2019-09-18T13:06:08.000Z","updated":"2019-09-18T15:38:50.799Z","comments":true,"path":"2019/09/18/Maven课上学习（一）/","link":"","permalink":"http://wysblogs.top/2019/09/18/Maven课上学习（一）/","excerpt":"","text":"Maven课上学习（一）Maven概述maven特性 纯java编写： 具有跨平台特性，只需要一套程序就行 开源： 可以对源码修改 互联网思维： 分享，共享 树立自己的IP，让自己流量变大，然后使自己变得有价值 跨平台： 跨两个平台： 跨OS平台（操作系统），跨IDE平台 IDE（Integrated Development Enviroment）：用于提供程序开发环境的应用程序 不同的IDE工具创建的项目结构不同，不能互相导入项目 maven把项目结构标准化，在哪开发都能导入项目 标准化的： 项目构建标准化： 跨操作系统平台（跨OS平台） 项目结构标准化： 跨IDE平台 Maven项目本身是和IDE没有任何关系的 基于项目对象模型（POM）： pom文件可以继承，具有继承性 一般导入依赖是通过 groupId，artifactId，version，简称gav坐标 maven核心都是由插件完成的，导入坐标可以自动下载插 项目构建： maven的管理模块来生成一些必要的组件，节省人工 依赖管理，对jar包进行管理，只需要导入坐标就行 报告生成： Maven 可以生成站点报告, 可以较为方便的实现对项目的管理。 Maven工作原理 maven寻找依赖过程 本地仓库 -&gt; maven私服（阿里云或者公司内部） -&gt; maven中心仓库 依次，到各级库的范围越来越广 Maven的安装与配置官网下载maven https://maven.apache.org/download.cgi 解压到某个文件夹 例如F盘 设置环境变量 在系统变量中创建 MAVEN_HOME ，内容填Maven的目录 例如 F:\\apache-maven-3.6.2-bin\\apache-maven-3.6.2 然后在path中添加MAVEN_HOME的bin目录 %MAVEN_HOME%\\bin; 然后在cmd中测试一下，输入 mvn -v查看版本 如果有的话就没问题了 Maven换源（这个是最重要的）setting.xml文件 这个文件在maven文件夹下的conf文件夹中，找到后用编辑器打开 需要设置两个地方： 首先是本地仓库： 找到localRepository这个标签所在位置，一般来说都是注释状态，我们把注释去掉，然后把标签内内容改成maven文件夹的绝对路径就行 接下来最重要了，更换镜像： ​ 找到mirrors标签，然后把阿里云镜像添加进去即可： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 课外内容： 英语口语发音要注意，发音正确不一定学习好，但发音错误说明一定不是好学校 tar.gz文件夹： 高度压缩过的文件夹 zip： 普遍压缩 bin文件夹： 编译过的文件，二进制文件 src： 源码，未经过编译的","categories":[{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/categories/Maven学习/"}],"tags":[{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/tags/Maven学习/"}]},{"title":"MyBatis学习笔记（二）","slug":"MyBatis学习笔记（二）","date":"2019-09-17T11:35:39.000Z","updated":"2019-09-17T11:44:51.301Z","comments":true,"path":"2019/09/17/MyBatis学习笔记（二）/","link":"","permalink":"http://wysblogs.top/2019/09/17/MyBatis学习笔记（二）/","excerpt":"","text":"MyBatis学习笔记视频篇（二）紧接着上面的入门案例，这次使用注解的方式 准备​ 首先新建一个maven项目，然后将java和resources文件夹复制过来，然后test文件夹也复制过来，还有pom.xml依赖也复制过来。 ​ 紧接着将resources文件夹下的com文件夹删除 修改​ 我们首先把sqlMapConfig.xml内容修改一下 123456&lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果使用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt; &lt;mapper class=\"com.dao.UserDao\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 只需要把最下面的mapper换成类名即可 ​ 然后是类中添加注解 12345678910111213141516171819package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();&#125; ​ 在方法名上面添加注解标签Select，代表查询语句，参数则是具体查询语句，进行测试，发现结果与xml方式时的运行结果一致。 明确： ​ 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式，不管是使用XML还是注解配置，但是MyBatis它是支持写实现类的。 ​ 因此我们下来就手写一次实现类，来试一试。 开始手写实现类还是基于第一次的xml来实现的 创建一个dao的实现类 1234567891011121314151617181920212223242526package com.dao.impl;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; //使用工厂创建session对象 SqlSession session = factory.openSession(); //使用session进行查询 List&lt;User&gt; users = session.selectList(\"com.dao.UserDao.findAll\"); session.close(); return users; &#125;&#125; UserDao的mapper不做修改 修改测试类内容 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import com.dao.UserDao;import com.dao.impl.UserDaoImpl;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream(\"sqlMapConfig.xml\"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂创建dao对象 UserDao userdao = new UserDaoImpl(factory); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 in.close(); &#125;&#125; 因为session转移到实现类中，所以此处只需要new一个实现类就行 实际开发中并不使用这种方式，写这个是为了告诉我们，在mapper.xml中，只靠id是无法定位到具体的方法中的，还需要我们加上namespace才能找到执行语句。 mybatis入门案例模式中的设计模式分析","categories":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/categories/MyBatis学习/"}],"tags":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/tags/MyBatis学习/"}]},{"title":"MyBatis学习笔记（一）","slug":"MyBatis学习笔记（一）","date":"2019-09-17T11:35:31.000Z","updated":"2019-09-17T11:39:14.906Z","comments":true,"path":"2019/09/17/MyBatis学习笔记（一）/","link":"","permalink":"http://wysblogs.top/2019/09/17/MyBatis学习笔记（一）/","excerpt":"","text":"MyBits学习笔记视频篇（一）框架1. 什么是框架 ​ 他是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题，例如，MyBits解决的是持久层的问题，Spring和Spring MVC 解决的是表现层的问题。 2. 使用框架的好处 ​ 框架风阻航了很多细节，是开发者可以使用极简的方式实现功能，大大提高开发效率。 三层架构​ 表现层：用于展示数据的 ​ 业务层：处理业务需求 ​ 持久层：和数据库交互的 持久层技术解决方案1. JDBC技术 ​ Connection ​ PreparedStatement ​ ResultSet 2. Spring的JdbcTemplate： ​ Spring中对jdbc的简单封装 3. Apache的DBUtils ​ 它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装 4. 以上这些都不是框架 ​ JDBC是规范 ​ Spring的JdbcTemplate和Apache的DBUtils都只是工具类 MyBatis框架概述​ mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，是开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等复杂的过程。 ​ 它使用了ORM思想，实现了结果集的封装，Object Relational Mapping 对象关系映射，简单地说，就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。 ​ 实体类中的属性和数据库表的字段名名称保持一致。 MyBatis的入门mybatis的环境搭建 ​ 首先创建一个maven项目 ​ 在pom.xml中导入相关的包 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;my_pratices_mybits_day_1&lt;/groupId&gt; &lt;artifactId&gt;my_pratices_mybits_day_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '&#125;'; &#125;&#125; 创建接口 1234567891011121314151617package com.dao;import com.pojo.User;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ List&lt;User&gt; findAll();&#125; 创建Mybatis-config.xml整体配置文件 因为我这里没有，所以创建了一个模板 创建模板过程就是： 打开idea设置中的File and Code Templates中的Files 然后点击“+”号，Name输入MyBatis-config.xml，Extendsion填写 xml 然后下面模板中添加如下代码 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;/configuration&gt; 整个模板就配置完毕了，然后创建就行 在MyBatis-config.xml配置文件中写入以下代码 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"wang123\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=\"com/dao/UserDao.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意上面一定要把environments的default和environment的id都写上去 创建映射配置文件UserDao.xml 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.dao.UserDao\"&gt; &lt;!--配置查询所有--&gt; &lt;select id=\"findAll\" resultType=\"com.pojo.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 这个地方会报错，原因是没有写resultType参数，结果集不知道封装到哪里去。 而且那个sql语句末尾不能加“；”符号 环境搭建注意的事项： ​ 第一个是： 创建UserDao.xml和UserDao.java时名称是为了和我们之前的知识保持一致。在MyBatis中它把持久层的操作接口名称和映射文件，也叫做Mapper，所以UserDao和UserMapper是一样的。​ 第二个是： 在idea中创建目录时，他和包是不一样的，包在创建时，com.dao他是二级结构，而创建目录的时候，com.dao他是一级结构，所以必须要一层一层创建​ 第三个是：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个是：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 ​ 第五个是：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 ​ 当我们遵从了第三，四，五点之后，我们在开发中就无须再写doa的实现类了。 创建log4j.properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344# priority :debug&lt;info&lt;warn&lt;error#you cannot specify every priority with different file for log4j log4j.rootLogger=debug,stdout,info,debug,warn,error #consolelog4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern= [%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n#info loglog4j.logger.info=infolog4j.appender.info=org.apache.log4j.DailyRollingFileAppender log4j.appender.info.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.info.File=./src/com/hp/log/info.loglog4j.appender.info.Append=truelog4j.appender.info.Threshold=INFOlog4j.appender.info.layout=org.apache.log4j.PatternLayout log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#debug loglog4j.logger.debug=debuglog4j.appender.debug=org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.debug.File=./src/com/hp/log/debug.loglog4j.appender.debug.Append=truelog4j.appender.debug.Threshold=DEBUGlog4j.appender.debug.layout=org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#warn loglog4j.logger.warn=warnlog4j.appender.warn=org.apache.log4j.DailyRollingFileAppender log4j.appender.warn.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.warn.File=./src/com/hp/log/warn.loglog4j.appender.warn.Append=truelog4j.appender.warn.Threshold=WARNlog4j.appender.warn.layout=org.apache.log4j.PatternLayout log4j.appender.warn.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#errorlog4j.logger.error=errorlog4j.appender.error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.error.File = ./src/com/hp/log/error.log log4j.appender.error.Append = truelog4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n 创建测试类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream(\"MyBatis-config.xml\"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 UserDao userdao = session.getMapper(UserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 结果展示 mybatis的入门案例 ​ 第一步： 读取配置文件 ​ 第二步： 创建SqlSessionFactory工厂 ​ 第三步：创建SqlSession ​ 第四步：创建Dao接口的代理对象 ​ 第五步：执行dao中的方法 ​ 第六步：释放资源 ​ 注意事项： ​ 不要忘记在映射配置中告知mybits要封装到哪个实体类中 ​ 配置的方式：指定实体类的全限定类名","categories":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/categories/MyBatis学习/"}],"tags":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/tags/MyBatis学习/"}]},{"title":"Junit的基本注解","slug":"Junit的基本注解","date":"2019-09-17T11:33:17.000Z","updated":"2019-09-17T11:34:54.305Z","comments":true,"path":"2019/09/17/Junit的基本注解/","link":"","permalink":"http://wysblogs.top/2019/09/17/Junit的基本注解/","excerpt":"","text":"Junit的基本注解注解类型 注解名称 注解作用 @Before 表示在任意使用@Test注解标注的public static void 方法执行之前执行 @After 表示在任意使用@Test注解标注的public static void 方法执行之后执行 @Test 使用该注解标注的public void 方法会表示为一个测试方法，可以直接执行 @BeforeClass 表示在类中的任意public static void 方法执行之前执行 @AfterClass 表示在类中的任意public static void 方法执行之后执行 下面是测试样例： 1234567891011121314151617181920212223242526package com.test;import org.junit.*;public class BasicAnnotationTest &#123; @BeforeClass public static void beforeClass() &#123; System.out.println(\"这是beforeClass前置通知\"); &#125; @AfterClass public static void afterClass() &#123; System.out.println(\"这是afterClass后置通知\"); &#125; @Before public void before() &#123; System.out.println(\"这是before前置通知\"); &#125; @After public void after() &#123; System.out.println(\"这是after后置通知\"); &#125; @Test public void test1() &#123; System.out.println(\"这是test1\"); &#125;&#125; 结果：","categories":[{"name":"Junit","slug":"Junit","permalink":"http://wysblogs.top/categories/Junit/"}],"tags":[{"name":"Junit","slug":"Junit","permalink":"http://wysblogs.top/tags/Junit/"}]},{"title":"GitHub学习笔记","slug":"GitHub学习笔记","date":"2019-09-16T13:59:08.000Z","updated":"2019-09-16T14:16:27.216Z","comments":true,"path":"2019/09/16/GitHub学习笔记/","link":"","permalink":"http://wysblogs.top/2019/09/16/GitHub学习笔记/","excerpt":"","text":"GitHub学习笔记基本概念仓库（Repository）仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目存在多个仓库。 收藏（Star）收藏项目，方便查看 复制克隆项目（Fork）点击之后，会别人的仓库完整的复制一份给你，该fork仓库之独立存在的，而且上面会有从哪个地方克隆的。 发起合并请求（Push Request）这个是基于Fork的，如果想要克隆来源的地方也更新同样的代码，然后可以点击之后，会发起合并请求，查看同意之后就可以合并了。 关注（Watch）关注项目之后，项目更新可以接受到通知 事物卡片（Issue）发现代码有BUG，但是目前没有成型代码，需要讨论时用 Github主页账号登录成功之后，点击左上角就回到github主页，显示自己的动态和关注的动态，右边显示git库 仓库主页显示项目信息，如：项目代码，版本，收藏/关注/fork情况等 创建仓库 仓库主页 仓库管理点击create new file新建文件 写好之后，填写提交的目的，原因：为了方便其他开发者知道本次添加或修改的原因 创建完毕跳转到主页 点击目的之后可以看到文件的详细描述，还有文件的修改内容 编辑文件 点击之后回来到编辑模式之下 删除文件同上面一样 上传文件 可以拖动文件也可以点击上传多个文件 下面是写上传文件的信息 搜索文件 输入文件名进行筛选 也可以按快捷键T就可以进行查找文件 下载文件","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://wysblogs.top/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://wysblogs.top/tags/GitHub/"}]},{"title":"一些常用的网站","slug":"一些常用的网站","date":"2019-09-16T13:42:32.000Z","updated":"2019-09-16T13:43:23.806Z","comments":true,"path":"2019/09/16/一些常用的网站/","link":"","permalink":"http://wysblogs.top/2019/09/16/一些常用的网站/","excerpt":"","text":"一些常用的网站链接Spring官方文档（涵盖各个版本的）https://docs.spring.io/spring/docs/ Maven仓库https://mvnrepository.com/ Json格式化网站https://www.json.cn/ 不错的java学习网站http://how2j.cn/stage/39.html CMD Markdown网站https://www.zybuluo.com/mdeditor （可以在线记录markdown文档，缺点是有些功能收费） Leetcodehttps://leetcode-cn.com/ 站长工具http://tool.chinaz.com/ 谷歌网上应用商店https://chrome.google.com/webstore/category/extensions?h1=zh 慕课网https://www.imooc.com/ 牛客https://www.nowcoder.com/ 代码托管平台Githubhttps://github.com/ 待更新。。。。。。","categories":[{"name":"工具","slug":"工具","permalink":"http://wysblogs.top/categories/工具/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://wysblogs.top/tags/网站/"}]},{"title":"MyBatis配置文件整理","slug":"MyBatis配置文件整理","date":"2019-09-16T13:05:32.000Z","updated":"2019-09-18T13:11:38.966Z","comments":true,"path":"2019/09/16/MyBatis配置文件整理/","link":"","permalink":"http://wysblogs.top/2019/09/16/MyBatis配置文件整理/","excerpt":"","text":"MyBatis配置文件整理log4j.properties123456789101112131415161718192021222324 ### 设置###log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n ### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n mybatis模板123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--属性--&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!--设置--&gt; &lt;settings&gt; &lt;setting name=\"\" value=\"\"/&gt; &lt;/settings&gt; &lt;!--别名--&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!--类型处理器--&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!--对象工厂--&gt; &lt;objectFactory type=\"\"&gt;&lt;/objectFactory&gt; &lt;!--插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=\"\"&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;!--配置环境--&gt; &lt;environments default=\"\"&gt; &lt;!--环境变量--&gt; &lt;environment id=\"\"&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type=\"\"&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=\"\"&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--数据库厂商标识--&gt; &lt;databaseIdProvider type=\"\"&gt;&lt;/databaseIdProvider&gt; &lt;!--映射器,告诉mybatis去哪里找映射文件--&gt; &lt;mappers&gt; &lt;mapper&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper模板12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 在MyBatis中，Mapper中的namespace用于绑定Dao接口的，即面向接口编程。 它的好处在于当使用了namespace之后就可以不用写接口实现类， 业务逻辑会直接通过这个绑定寻找到相对应的SQL语句进行对应的数据处理--&gt;&lt;mapper namespace=\"\"&gt; &lt;!--查询--&gt; &lt;select id=\"\"&gt;&lt;/select&gt; &lt;!--增加--&gt; &lt;insert id=\"\"&gt;&lt;/insert&gt; &lt;!--删除--&gt; &lt;delete id=\"\"&gt;&lt;/delete&gt; &lt;!--修改--&gt; &lt;update id=\"\"&gt;&lt;/update&gt; &lt;!--提供缓存支持--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!--参照缓存,用来引用另一个缓存--&gt; &lt;cache-ref namespace=\"\"/&gt; &lt;!-- ParameterMap和ResultMap类似，设置入参字段映射，很少使用（不建议使用）--&gt; &lt;parameterMap id=\"\" type=\"\"&gt;&lt;/parameterMap&gt; &lt;!--查询结果集，映射java对象--&gt; &lt;resultMap id=\"\" type=\"\"&gt;&lt;/resultMap&gt;&lt;/mapper&gt; Spring整合模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--配置数据源--&gt; &lt;bean id=\"dataSouce\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt; &lt;!--加载数据库驱动--&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8\"&gt;&lt;/property&gt; &lt;!--账户--&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;!--密码--&gt; &lt;property name=\"password\" value=\"wang123\"&gt;&lt;/property&gt; &lt;!--最大连接数--&gt; &lt;property name=\"maxTotal\" value=\"30\"&gt;&lt;/property&gt; &lt;!--最大空闲数--&gt; &lt;property name=\"maxIdle\" value=\"10\"&gt;&lt;/property&gt; &lt;!--初始化连接数--&gt; &lt;property name=\"initialSize\" value=\"5\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--添加事务支持--&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSouce\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; &lt;!--配置MyBatis工厂,同时指定数据源，并于MyBatis完美整合--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--指定数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSouce\"&gt;&lt;/property&gt; &lt;!--configLocation的属性值为MyBatis的核心配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配 (Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口) --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!--mybatis-spring组件的扫描器--&gt; &lt;property name=\"basePackage\" value=\"\"&gt;&lt;/property&gt; &lt;!--注入工厂--&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring5约束头1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;/beans&gt; 整合Spring和MyBatis所使用的pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.my_priatices.aop&lt;/groupId&gt; &lt;artifactId&gt;my_priatices.aop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 待更新。。。。。。","categories":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/categories/MyBatis学习/"}],"tags":[{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/tags/MyBatis学习/"}]},{"title":"JAVAEE读书笔记（三）","slug":"JAVAEE读书笔记（三）","date":"2019-09-11T16:25:19.000Z","updated":"2019-09-11T16:29:59.988Z","comments":true,"path":"2019/09/12/JAVAEE读书笔记（三）/","link":"","permalink":"http://wysblogs.top/2019/09/12/JAVAEE读书笔记（三）/","excerpt":"","text":"JAVAEE读书笔记（三）基于XML装配Spring提供了两种基于XML的装配方式，分别是setter注入和构造方法注入 首先创建Bean的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;/** * 复杂数据的注入 */public class ComplexUser &#123; private String name; private List&lt;String&gt; hobbyList; private Map&lt;String,String&gt; residenceMap; private Set&lt;String&gt; aliasSet; private String[] array; public ComplexUser(String name, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array) &#123; this.name = name; this.hobbyList = hobbyList; this.residenceMap = residenceMap; this.aliasSet = aliasSet; this.array = array; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getHobbyList() &#123; return hobbyList; &#125; public void setHobbyList(List&lt;String&gt; hobbyList) &#123; this.hobbyList = hobbyList; &#125; public Map&lt;String, String&gt; getResidenceMap() &#123; return residenceMap; &#125; public void setResidenceMap(Map&lt;String, String&gt; residenceMap) &#123; this.residenceMap = residenceMap; &#125; public Set&lt;String&gt; getAliasSet() &#123; return aliasSet; &#125; public void setAliasSet(Set&lt;String&gt; aliasSet) &#123; this.aliasSet = aliasSet; &#125; public String[] getArray() &#123; return array; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; @Override public String toString() &#123; return \"ComplexUser&#123;\" + \"name='\" + name + '\\'' + \", hobbyList=\" + hobbyList + \", residenceMap=\" + residenceMap + \", aliasSet=\" + aliasSet + \", array=\" + Arrays.toString(array) + '&#125;'; &#125;&#125; 配置Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id=\"u1\" class=\"com.bean.ComplexUser\"&gt; &lt;!--构造方法注入--&gt; &lt;constructor-arg index=\"0\" value=\"myname\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=\"1\"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;码代码&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=\"2\"&gt; &lt;map&gt; &lt;entry key=\"anyang\" value=\"安阳\"&gt;&lt;/entry&gt; &lt;entry key=\"beijing\" value=\"北京\"&gt;&lt;/entry&gt; &lt;entry key=\"jiyuan\" value=\"济源\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=\"3\"&gt; &lt;set&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang1&lt;/value&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang2&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index=\"4\"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"u2\" class=\"com.bean.ComplexUser\"&gt; &lt;property name=\"name\" value=\"shuai\"&gt;&lt;/property&gt; &lt;property name=\"hobbyList\"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;搬砖&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"residenceMap\"&gt; &lt;map&gt; &lt;entry key=\"jiyuan\" value=\"济源\"&gt;&lt;/entry&gt; &lt;entry key=\"anyang\" value=\"安阳\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"aliasSet\"&gt; &lt;set&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s2&lt;/value&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"array\"&gt; &lt;array&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;你太美&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类 123456789101112131415161718package com.test;import com.bean.ComplexUser;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-config.xml\"); ComplexUser u1 = (ComplexUser)applicationContext.getBean(\"u1\"); System.out.println(u1.toString()); ComplexUser u2 = (ComplexUser)applicationContext.getBean(\"u2\"); System.out.println(u2.toString()); &#125;&#125; 结果 基于注解的装配因为要用到注解，所以我们来看看都有哪些基础的注解： 名称 作用 Component 代表一个组件对象，就是把普通的pojo实例到Spring容器中 Repository 此注解用于数据访问层（DAO），功能与Component相同 Service 此注解用于业务逻辑组件层（Service层），功能与Component相同 Controller 此注解用于标注一个控制器组件类（SpringMVC的Controller），功能与Component相同 AutoWired 此诸结可以对类成员变量，方法及构造方法进行标注，完成自动装配的工作。通过使用Autowired来消除setter和getter方法。默认按照Bean的类型进行装配，如果想按照名称来注入，就必须要和Qualifier搭配使用。 Resource 此注解与AutoWired相同，区别在于这个注解是按照名称来装配注入的，只有当找不到与名称匹配的名称时，才按照Bean的类型进行装配。 Qualifier 此注解要和AutoWired配合使用，Bean的实例名称有此注解的参数指定。 首先创建一个DAO层，和他的实现类，然后标上注解： TestDao 12345678910111213package com.dao;import org.springframework.stereotype.Repository;/** * 创建dao接口 */public interface TestDao &#123; /** * 保存 */ void save();&#125; TestDaoImpl 12345678910111213package com.dao.impl;import com.dao.TestDao;import org.springframework.stereotype.Repository;@Repository(\"testDao\")public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println(\"TestDao save\"); &#125;&#125; TestService 1234567891011package com.servlet;import org.springframework.stereotype.Service;/** * 业务层接口 */public interface TestService &#123; void save();&#125; TestServiceImpl 1234567891011121314151617181920212223package com.servlet.impl;import com.dao.TestDao;import com.servlet.TestService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * 业务层实现类 */@Service(\"testService\")public class TestServiceImpl implements TestService &#123; @Resource(name=\"testDao\") private TestDao testDao; @Override public void save() &#123; testDao.save(); System.out.println(\"TestService save\"); &#125;&#125; TestController 12345678910111213141516171819package com.controller;import com.servlet.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controllerpublic class TestController &#123; @Autowired private TestService testService; public void save()&#123; testService.save(); System.out.println(\"TestController save\"); &#125;&#125; 测试类 12345678910111213package com.test;import com.controller.TestController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-config.xml\"); TestController testController = (TestController)applicationContext.getBean(\"testController\"); testController.save(); &#125;&#125; 结果 课后题Bean的实例化有哪几种常见的方法？ ​ 答： 三种，构造方法，静态工厂，实例工厂 简述基于注解装配方式的基本用法？ ​ 答： 见上面的表格。 @AutoWired和@Resource有什么区别？ ​ 答：一个是按类别，一个是按名称 Bean的默认作用域是什么？ ​ 答：singleton 单例模式 使用类似于@Controller一样的注解的时候，Bean的id是什么？ ​ 答： 默认是首字母小写的类名","categories":[{"name":"JAVAEE读书笔记","slug":"JAVAEE读书笔记","permalink":"http://wysblogs.top/categories/JAVAEE读书笔记/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/tags/学习/"}]},{"title":"java学习路线","slug":"java学习路线","date":"2019-09-11T13:37:25.000Z","updated":"2019-09-11T13:41:45.937Z","comments":true,"path":"2019/09/11/java学习路线/","link":"","permalink":"http://wysblogs.top/2019/09/11/java学习路线/","excerpt":"","text":"基础部分 javaSE MySQL，刚开始只需要了解一些基础的sql语句，例如增删改查，复杂一点的后面可以在学。 idea可以直接连接数据库 database，一开始可以多用用，熟悉熟悉 javaWeb：jsp（了解即可），（Servlet ，Filter，Listener），重点放在Listener 现在大多数都是异步机制和回调机制，Listener监听用的多，Filter用的少 （重点部分）SSM：Spring + MyBatis+Spring MVC Spring MVC：是Spring中的一部分 Spring：本身是一个容器 响应式编程 WebFlux，在开发中用的也不是很多，主要解决的是高并发问题，建议了解一下 Lambda表达式，基于接口实现的，建议学习 项目管理工具 Maven，得了解原理。 项目管理工具Git，也是分布式版本管理工具，然后项目要放到github上面 （重点部分）Spring Boot （快速开发框架），使用这个原因是因为SSM配置文件非常多，基本上都是样板式代码，因此必须把可重用性代码封装起来，所以这个Spring Boot必须得好好学习，重点！ 分布式开发技术（进阶部分） linux基础，因为服务器现在基本上都是搭建在无可视化界面的linux上面的 本地服务器搭建的工具（VMware（搭建虚拟机）+secureCRT（客户端）+CentOS 7 Mini版本（只有操作界面） 分布式协调服务器Zookeeper 反向代理服务器 Nginx 真正请求的服务器在后面，这个是代理集群，集群里面部署的应用都是一样的，一般都会选一个master作为主要的 正解：正向解析，把域名解析成ip地址 反解：反向代理，把ip地址解析成域名 正代：由内向外作代理 反代：由外向内做代理 分布式内存数据库Redis（NoSql非关系型数据库） 分布式消息队列Kafka，RocketMQ，RabbitMQ（ActiveMQ不用管它） 应用方面：削减峰值，并发量高的时候需要使用 分布式RPC框架Dubbo（阿里的框架）和微服务框架Spring Cloud 微服务：把服务分散开，每一个都是独立的工程，用哪个调哪个 高内聚，低耦合，便于复用 Spring Boot 一定要好好学习！！！","categories":[{"name":"java学习","slug":"java学习","permalink":"http://wysblogs.top/categories/java学习/"}],"tags":[{"name":"前进方向","slug":"前进方向","permalink":"http://wysblogs.top/tags/前进方向/"}]},{"title":"JAVAEE读书笔记（二）","slug":"JAVAEE读书笔记（二）","date":"2019-09-03T23:24:34.000Z","updated":"2019-09-03T23:30:50.665Z","comments":true,"path":"2019/09/04/JAVAEE读书笔记（二）/","link":"","permalink":"http://wysblogs.top/2019/09/04/JAVAEE读书笔记（二）/","excerpt":"","text":"SpringBeanBean的配置​ Spring用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持Xml和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 ​ &lt;bean&gt;元素的常用属性及其子元素 描述 属性或子元素名称 id Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称 class Bean的具体实现类，使用类的名（例如dao.TestDIDaoImpl） scope 指定Bean实例的作用域 &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值 &lt;property&gt; &lt;bean&gt;元素的子元素用于设置一个属性，该元素的name属性指定Bean实例中相应的属性名称，value属性指定Bean的属性值，ref属性指定属性对BeanFactory中其他Bean的引用关系 &lt;list&gt; &lt;property&gt;元素的子元素，用于封装List或数组类型的依赖注入 &lt;map&gt; &lt;property&gt;元素的子元素，用于封装Map类型的依赖注入 &lt;set&gt; &lt;property&gt;元素的子元素，用于封装Set类型的依赖注入 &lt;entry&gt; &lt;map&gt;元素的子元素，用于设置一个键值对 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg ref=\"accountDao\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.dao.impl.AccountDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，也需要实例化Bean，Spring框架实例化Bean有三种方式 即，构造方法实例化、静态工厂实例化和实例工厂实例化（最常用就是构造方法实例化）。 1. 构造方法实例化 spring-config.xml配置 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg ref=\"accountDao\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.dao.impl.AccountDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213package com.test;import com.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-config.xml\"); AccountService accountService = (AccountService)applicationContext.getBean(\"accountService\"); accountService.addAccountMoney(\"张三\",1000f); &#125;&#125; 2. 静态工厂实例化对象（开发中不使用，再次不列举使用方法）3. 实例工厂实例化对象（这个也不列举）Bean的作用域 作用域名称 描述 singleton 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例 prototype Spring容器每次获取protopyte定义的Bean，容器都将创建一个新的Bean实例 request 在一次Http请求中容器将返回一个Bean实例，不同的Http请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用 session 在一个HTTP Session 中，容器将返回同一个Bean实例。尽在Web Spring应用程序上下文中使用 application 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例，尽在Web Spring应用程序上下文中使用 websocket 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用 1. singleton作用域​ 由于singleton是bean的scope默认设置，所以写好bean之后就可以进行测试 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.test.AccountServiceImpl\" scope=\"singleton\"&gt;&lt;/bean&gt;&lt;/beans&gt; 代码如下 123456789101112131415package com.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-config.xml\"); //第一个对象 AccountServiceImpl a1 = (AccountServiceImpl)applicationContext.getBean(\"accountService\"); //第二个对象 AccountServiceImpl a2 = (AccountServiceImpl)applicationContext.getBean(\"accountService\"); System.out.println(a1 == a2); &#125;&#125; 结果展示： 2. prototype作用域代码如上所述，然后只设置scope作用域即可 结果展示: Bean的生命周期​ 一个对象的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段，在Spring中，Bean对象周期也遵循这一过程，但是Spring提供了许多对外接口，允许开发者对3个过程（实例化、初始化、销毁）的前后做一些操作。在Spring Bean中，实例化是为Bean对象开辟空间，初始化则是对属性的初始化。 ​ Bean生命周期整个过程如下： ​ （1）根据Bean的配置情况实例化一个Bean。 ​ （2）根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。 ​ （3）如果Bean实现了BeanNameAware 接口，将调用它实现的，setBeanName（String beanId）方法， 此处参数传递的是Spring配置文件中Bean的id。 ​ （4）如果Bean实现BeanFactoryAware接口，将调用它实现的setBeanFactory方法，此处参数传递的是当前Spring工厂实例的引用。 ​ （5）如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext（ApplicationContext）方法，此处参数传递的是Spring上下文实例的引用。 ​ （6）如果Bean关联了BeanPostProcessor接口，将调用初始化方法postProcessBeforeInitialization（Object obj， String s）对Bean进行操作。 ​ （7）如果Bean实现了InitializingBean接口， 将调用afterPropertiesSet方法。 ​ （8）如果Bean在Spring配置文件中配置了 init-method 属性，将自动调用其配置的初始化方法。 ​ （9）如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization（Object obj，String s）方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。 ​ （10）当Bean不再需要时将进入销毁阶段，如果Bean实现了DisposableBean接口，则调用其实现的destroy方法将Spring中的Bean销毁。 ​ （11）如果在配置文件中通过destory-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。 ​ 在Spring中，通过特定的接口或通过&lt;bean&gt;元素的属性设置可以对Bean的生命周期过程产生影响。 ​ 例子： ​ 创建Bean的实现类 12345678910111213package com.test;/** * @author wys */public class BeanLife &#123; public void initMyself()&#123; System.out.println(this.getClass().getName()+\"执行了自定义的初始化方法\"); &#125; public void destroyMyself() &#123; System.out.println(this.getClass().getName()+\"执行了自定义的销毁方法\"); &#125;&#125; ​ 配置Bean 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id=\"beanLife\" class=\"com.test.BeanLife\" init-method=\"initMyself\" destroy-method=\"destroyMyself\"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 测试生命周期 12345678910111213141516package com.test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"spring-config.xml\"); System.out.println(\"获得对象前\"); BeanLife beanLife = (BeanLife)ctx.getBean(\"beanLife\"); System.out.println(\"获得对象后\"+beanLife); ctx.close(); &#125;&#125; 结果如下:","categories":[{"name":"JAVAEE读书笔记","slug":"JAVAEE读书笔记","permalink":"http://wysblogs.top/categories/JAVAEE读书笔记/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/tags/学习/"}]},{"title":"hexo的next界面美化","slug":"hexo的next界面美化","date":"2019-08-10T07:57:00.000Z","updated":"2019-08-10T08:08:13.680Z","comments":true,"path":"2019/08/10/hexo的next界面美化/","link":"","permalink":"http://wysblogs.top/2019/08/10/hexo的next界面美化/","excerpt":"","text":"设置中文首先查看一下next/theme/language中的语言类型，一般就是zh-CN或者是zh-Hans`这个类型 然后在hexo的配置文件_config.yml把写上去就行 主题风格将next中的_config.yml配置文件修改一下 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 这个把前面的#去掉换另一种就行，我觉得第三种就挺好看的。个人喜好 设置分类还是在next中的_config.yml配置文件修改 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把对应菜单的选项注释去掉就好 然后创建目录,不同标签对应不同的代码 1$ hexo new page categories 创建完毕之后，进去修改一下 类似于categories这种的 123456---title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: \"categories\"--- 添加头像搜索next中的_config.yml配置文件 搜索Sidebar Avatar这个关键字，去掉avatar前面的# 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.gif 然后把头像放到指定的文件夹 设置侧边栏的的社交链接打开themes/next/_config.yml文件，搜索关键字social，然后添加社交站点名称与地址即可。 1234567891011social: GitHub: https://github.com/wyscoder|| github E-Mail: mailto:714133840@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 修改底部的声明和版权主题配置文件下，搜索关键字post_copyright，enable改为true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 去掉强力驱动 找到hexo根目录&gt;&gt;themes&gt;&gt;next&gt;&gt;layout&gt;&gt;_partials下的footer.swig文件 然后打开删除 123456789101112131415161718&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 这部分内容就好 最后修改一下hexo中的配置文件名字就行 添加搜索功能首先安装一下搜索插件 $ npm install hexo-generator-searchdb --save 打开Hexo站点的_config.yml，添加配置 : 12345search: path: search.xml field: post format: html limit: 10000 打开themes/next/_config.yml，搜索关键字local_search，设置为true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 本地站点推送到GitHub上安装插件 1$ npm install hexo-deployer-git --save 在Hexo站点的_config.yml中配置deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo g -d 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=110 src=&quot;//music.163.com/outchain/player?type=0&amp;id=408443429&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 就好了 添加背景动画效果 修改_layout.swig 打开 next/layout/_layout.swig 在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\\（￣︶￣）/ 如果你感觉默认的线条太多的话 可以这么设置====&gt; 在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加代码复制功能首先找到这个目录themes/next/layout/_third-party/ 然后在此文件夹下创建名为copy-code.swig的文件，在此文件中输入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125;&lt;/style&gt;&lt;script&gt; $('.highlight').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap') $(e).after($wrap) $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text() &#125;).toArray().join('\\n') var ta = document.createElement('textarea') document.body.appendChild(ta) ta.style.position = 'absolute' ta.style.top = '0px' ta.style.left = '0px' ta.value = code ta.select() ta.focus() var result = document.execCommand('copy') document.body.removeChild(ta) if(result)$(this).text('复制成功') else $(this).text('复制失败') $(this).blur() &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn') setTimeout(function () &#123; $b.text('复制') &#125;, 300) &#125;).append(e) &#125;)&lt;/script&gt; 然后返回上一层目录，即layout文件夹下，编辑_layout.swig， 在最底部，&lt;/body&gt;上面添加 1&#123;% include &apos;_third-party/copy-code.swig&apos; %&#125; 这句话接着就能用了","categories":[{"name":"博客","slug":"博客","permalink":"http://wysblogs.top/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://wysblogs.top/tags/博客/"}]},{"title":"HEXO搭建博客（搭建在github上面）","slug":"hexo搭建博客","date":"2019-08-10T07:23:04.000Z","updated":"2019-08-10T07:48:52.398Z","comments":true,"path":"2019/08/10/hexo搭建博客/","link":"","permalink":"http://wysblogs.top/2019/08/10/hexo搭建博客/","excerpt":"","text":"前言学长给的几个教程链接 https://blog.csdn.net/u013332124/article/details/80680156 https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html#validate-next-theme https://blog.csdn.net/llmmll08/article/details/70246150 1.什么是hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.安装1.前提​ 必须有Node.js 和 Git, 还有Github账号，都具备之后就开始了 2.创建github pages页面 首先创建仓库（repository ），然后仓库名字必须得是 yourname.github.io 这个，比如我的github名称是wyscoder，所以仓库名称就是 wyscoder.github.io 然后记住这个仓库的git地址 https://github.com/wyscoder/wyscoder.github.io 3.安装hexo 这个是需要node.js和git作为前置的，如果没有就去下载node.js和git 接下来就只需要npm就可以完成安装了 使用这个命令进行安装hexo$ npm install -g hexo-cli 等待下载完毕就行 4. 建站 安装hexo完成之后，执行下面命令就会在指定文件夹创建需要的文件 1234node.js$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 具体参数信息请查看官方文档 https://hexo.io/zh-cn/docs/configuration package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.8.0\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-renderer-marked\": \"^0.3.2\", \"hexo-server\": \"^0.3.3\" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 5.上传站点生成后,就可以开始写文章了。dos界面下,进入所在站点目录，输入hexo new [layout] &lt;title&gt;命令。hexo会自动帮你生成一个 &lt;title&gt;.md 的文件。然后你就可以在这个文件上编写你的博客内容了。 写完博客后,我们先试着在本地部署一下服务。还是在dos命令下，进入站点目录。一次输入: 123hexo clean # 清除缓存,之后会经常用到hexo g # 生成站点静态文件hexo s # 部署服务 上面是本地部署，之后就可以通过localhost:4000来访问博客了 但是如果想让别人访问你的还需要提交到git上面 打开cmd 然后输入npm install hexo-deployer-git --save安装git工具 开站点目录下面的配置文件_config.yml(用任意编辑器),配置deploy参数。一开始配置文件是这样的: 12deploy: type: 我们把它改成我们的git仓库地址。 1234deploy: type: git repository: ssh://git@github.com/wyscoder/wyscoder.github.io branch: master 修改好之后执行 123hexo clean hexo g hexo d # 部署到远程仓库 令全部执行完后。我们就可以访问我们的博客网站了。https://wyscoder.github.io 6.问题在使用hexo d提交的时候出现了几个问题 首先是你得使用git命令来设置用户和邮箱 config --global user.name \"nameVal\" ```12```git config --global user.email &quot;eamil@qq.com&quot; 其中我还测试了一下那个git的基本命令，都是卡在提交那一点，原因是没有密匙 如果电脑上没有ssh密匙我建议还是要安装一下 7.美化博客：使用nexT主题博客是搭建好了, 但是我们发现hexo的默认主题风格比较丑。好在hexo的主题是可定制的。所以我们可以更换别人已经做好的主题。nexT就是其中一个比较强大的主题。下面简单的教大家怎么切换到这个主题。​ 先去nexT的github页面下载nexT项目。https://github.com/iissnan/hexo-theme-next。然后放到站点目录下面的一个themes文件夹中。解压。 解压后会得到一个hexo-theme-next-master文件夹。重命名成next。 修改站点配置文件_config.yml里面的theme参数,修改值为next。 ​ 重新清除缓存,生成新的资源文件，然后部署,主题就切换成next了。","categories":[{"name":"博客","slug":"博客","permalink":"http://wysblogs.top/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://wysblogs.top/tags/博客/"}]},{"title":"JAVAEE读书笔记（一）","slug":"JAVAEE读书笔记（一）","date":"2019-08-10T07:21:10.000Z","updated":"2019-09-18T15:22:50.582Z","comments":true,"path":"2019/08/10/JAVAEE读书笔记（一）/","link":"","permalink":"http://wysblogs.top/2019/08/10/JAVAEE读书笔记（一）/","excerpt":"","text":"Spring简介1. Spring由来 目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题 2. Spring体系结构 核心容器（Core Container） 数据访问/ 集成（Data Access/Integration）层 Web层 AOP（Aspect Oriented Programming，面向切面的编程）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test） Spring体系结构 SpringIOC1. Spring IOC基本概念控制反转是一个比较抽象的概念，是Spring框架的核心，用来削减计算机程序的耦合问题。 依赖注入是IOC的另外一种说法。 解释 &nbsp;&nbsp;当某个java对象需要调用另一个对象时，在传统编程模式下，调用者通常会采用 “new 被调用者” 的方式来创建对象，这种方式会增加调用者和被调用者之间的耦合性，不利于后期代码的维护。 &nbsp;&nbsp;当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 &nbsp;&nbsp;从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入他所依赖的实例，这就是Spring依赖注入。 &nbsp;&nbsp;综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方产生或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入。 2. SpringIOC容器SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口。 BeanFactory(1). 概念&nbsp;&nbsp;BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，它提供了完整的Ioc服务支持，是一个管理BeanFactory的工厂，主要负责初始化各种Bean。BeanFactory接口有许多实现类，比较常用的就是org.springframework.beans.factory.xml.XmlBeanFactory.这个类会根据XML来装配Bean，创建时候需要提供XML文件的绝对路径。 123456public static void main(String[] args)&#123; //初始化Spring容器，加载配置文件 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource(\"绝对路径\")); TestDao testDao = (TestDao)beanFactory.getBean(\"testDao\"); testDao.sayHello();&#125; 这种写法开发中一般不常见，了解即可。 ApplicationContext&nbsp;&nbsp;ApplicationContext是BeanFactory的子接口，也称为应用上下文，org.springwork.context.ApplicationContext接口定义，ApplicationContext接口除了包含BeanFactory的所有功能外，还添加了国际化，资源访问，事件传播等内容的支持。 &nbsp;&nbsp;创建ApplicationContext接口实例通常有以下三种方式: (1). *通过ClassPathXmlApplicationContext创建 *：&nbsp;&nbsp;ClassPathXmlApplicationContext将类路径目录（src根目录）中寻找指定的XML配置文件，代码如下： 1234567public static void main(String[] args)&#123; //初始化Spring容器ApplicationContext,加载配置文件 ApplicationContext ac = ClassPathXmlApplicationContext(\"spring-config.xml\"); //通过容器获取实例对象 TestDao testDao = (TestDao)ac.getBean(\"testDao\"); testDao.sayHello();&#125; (2). 通过FileSystemXmlApplicationContext创建：&nbsp;&nbsp;FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public stsatic void main(String[] args)&#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext ac = new FileSystemXmlApplication(\"C:\\Users\\hp\\IdeaProjects\\my_pratices_account_day_01\\src\\main\\resources\\spring-config.xml\"); //获取实例对象 TestDao testDao = (TestDao)ac.getBean(\"testDao\"); testDao.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。 (3). 通过Web服务器实例化ApplicationContext容器&nbsp;&nbsp;在Web服务器实例化ApplicationContext容器时，一般使用org.springframework.web.context.ContextLoaderListener的实现方式（需要导入spring-web.5.0.2.RELEASE.jar包），此方法只需在web.xml中添加如下代码： 1234567891011&lt;context-param&gt; &lt;!--加载src目录下的spring-config.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3. 依赖注入的类型构造方法注入&nbsp;&nbsp;Spring框架可以采用java的反射机制，通过构造方法完成依赖注入 首先创建持久层接口 1234567891011package com.test.dao;/** * 创建持久层 */public interface TestDao &#123; /** * Hello方法 */ void sayHello();&#125; 然后创建持久层实现类 1234567891011package com.test.dao.impl;import com.test.dao.TestDao;public class TestDaoImpl implements TestDao &#123; @Override public void sayHello()&#123; System.out.println(\"Hello World\"); &#125;&#125; 创建业务层接口 12345678package com.test.service;/** * 业务层 */public interface TestService &#123; void sayHello();&#125; 创建业务层实现类 12345678910111213141516171819package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public TestServiceImpl(TestDao testDao)&#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 配置spring-config.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"testService\" class=\"com.test.service.impl.TestServiceImpl\"&gt; &lt;constructor-arg ref=\"testDao\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"testDao\" class=\"com.test.dao.impl.TestDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后在测试类中测试一下 1234567891011121314package com.test;import com.test.service.TestService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"spring-config.xml\"); TestService testService = (TestService)ac.getBean(\"testService\"); testService.sayHello(); &#125;&#125; 然后看一下结果 以上就是构造注入 属性的setter注入&nbsp;&nbsp;和上面创建一样，只需要更改一下TestServiceImpl中的代码和spring-config.xml就行 123456789101112131415161718192021package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public void setTestDao(TestDao testDao) &#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"testService\" class=\"com.test.service.impl.TestServiceImpl\"&gt; &lt;property name=\"testDao\" ref=\"testDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"testDao\" class=\"com.test.dao.impl.TestDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 4. 课后习题 举例说明IOC容器的实现方式有哪些？ 控制反转和依赖注入 spring中什么是控制反转？什么是依赖注入？使用控制反转与依赖注入的优点？ 控制反转：是一种通过描述并通过第三方去产生去获取特定对象的方式 依赖注入：使用spring框架创建对象时动态的将其所依赖的对象注入到Bean组件中。 控制反转优点： ​ 1.获取对象可以通过注解等方式获取对象，打破传统的获取方式 ​ 2.对象不再由程序本身进行创建，而是交给spring容器创建，降低了程序的耦合性 ​ 3.控制反转能做到更多的事情，例如事务控制 ​ 4.后期维护方便 依赖注入优点： ​ 1.项目开发讲究高内聚，低耦合 ​ 2.使用依赖注入可以避免使用new关键字创建对象，从而降低类与类之间的耦合度 spring框架采用java的反射机制进行依赖注入.","categories":[{"name":"JAVAEE读书笔记","slug":"JAVAEE读书笔记","permalink":"http://wysblogs.top/categories/JAVAEE读书笔记/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/tags/学习/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/categories/java基础/"},{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/categories/mysql/"},{"name":"java基础知识","slug":"java基础知识","permalink":"http://wysblogs.top/categories/java基础知识/"},{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/categories/数据结构/"},{"name":"反射","slug":"反射","permalink":"http://wysblogs.top/categories/反射/"},{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/categories/并发/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://wysblogs.top/categories/计算机网络/"},{"name":"linux","slug":"linux","permalink":"http://wysblogs.top/categories/linux/"},{"name":"面经","slug":"面经","permalink":"http://wysblogs.top/categories/面经/"},{"name":"jvm","slug":"jvm","permalink":"http://wysblogs.top/categories/jvm/"},{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/categories/redis/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wysblogs.top/categories/设计模式/"},{"name":"dubbo","slug":"dubbo","permalink":"http://wysblogs.top/categories/dubbo/"},{"name":"经验","slug":"经验","permalink":"http://wysblogs.top/categories/经验/"},{"name":"Serializable","slug":"Serializable","permalink":"http://wysblogs.top/categories/Serializable/"},{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/categories/面试/"},{"name":"Netty","slug":"Netty","permalink":"http://wysblogs.top/categories/Netty/"},{"name":"算法","slug":"算法","permalink":"http://wysblogs.top/categories/算法/"},{"name":"开发经验","slug":"开发经验","permalink":"http://wysblogs.top/categories/开发经验/"},{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/categories/centos/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://wysblogs.top/categories/Mybatis/"},{"name":"java设计模式","slug":"java设计模式","permalink":"http://wysblogs.top/categories/java设计模式/"},{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/categories/Maven学习/"},{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/categories/学习/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://wysblogs.top/categories/thymeleaf/"},{"name":"Docker","slug":"Docker","permalink":"http://wysblogs.top/categories/Docker/"},{"name":"Spring Boot学习笔记","slug":"Spring-Boot学习笔记","permalink":"http://wysblogs.top/categories/Spring-Boot学习笔记/"},{"name":"IDEA","slug":"IDEA","permalink":"http://wysblogs.top/categories/IDEA/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://wysblogs.top/categories/Spring-MVC/"},{"name":"Spring","slug":"Spring","permalink":"http://wysblogs.top/categories/Spring/"},{"name":"Ajax","slug":"Ajax","permalink":"http://wysblogs.top/categories/Ajax/"},{"name":"Spring MVC学习笔记","slug":"Spring-MVC学习笔记","permalink":"http://wysblogs.top/categories/Spring-MVC学习笔记/"},{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/categories/MyBatis学习/"},{"name":"JAVAEE框架作业","slug":"JAVAEE框架作业","permalink":"http://wysblogs.top/categories/JAVAEE框架作业/"},{"name":"JAVAEE读书笔记","slug":"JAVAEE读书笔记","permalink":"http://wysblogs.top/categories/JAVAEE读书笔记/"},{"name":"Junit","slug":"Junit","permalink":"http://wysblogs.top/categories/Junit/"},{"name":"JAVA代理","slug":"JAVA代理","permalink":"http://wysblogs.top/categories/JAVA代理/"},{"name":"GitHub","slug":"GitHub","permalink":"http://wysblogs.top/categories/GitHub/"},{"name":"工具","slug":"工具","permalink":"http://wysblogs.top/categories/工具/"},{"name":"java学习","slug":"java学习","permalink":"http://wysblogs.top/categories/java学习/"},{"name":"博客","slug":"博客","permalink":"http://wysblogs.top/categories/博客/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://wysblogs.top/tags/java基础/"},{"name":"mysql","slug":"mysql","permalink":"http://wysblogs.top/tags/mysql/"},{"name":"java基础知识","slug":"java基础知识","permalink":"http://wysblogs.top/tags/java基础知识/"},{"name":"数据结构","slug":"数据结构","permalink":"http://wysblogs.top/tags/数据结构/"},{"name":"反射","slug":"反射","permalink":"http://wysblogs.top/tags/反射/"},{"name":"并发","slug":"并发","permalink":"http://wysblogs.top/tags/并发/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://wysblogs.top/tags/计算机网络/"},{"name":"linux","slug":"linux","permalink":"http://wysblogs.top/tags/linux/"},{"name":"面经","slug":"面经","permalink":"http://wysblogs.top/tags/面经/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wysblogs.top/tags/设计模式/"},{"name":"jvm","slug":"jvm","permalink":"http://wysblogs.top/tags/jvm/"},{"name":"redis","slug":"redis","permalink":"http://wysblogs.top/tags/redis/"},{"name":"dubbo","slug":"dubbo","permalink":"http://wysblogs.top/tags/dubbo/"},{"name":"经验","slug":"经验","permalink":"http://wysblogs.top/tags/经验/"},{"name":"Serializable","slug":"Serializable","permalink":"http://wysblogs.top/tags/Serializable/"},{"name":"面试","slug":"面试","permalink":"http://wysblogs.top/tags/面试/"},{"name":"Netty","slug":"Netty","permalink":"http://wysblogs.top/tags/Netty/"},{"name":"算法","slug":"算法","permalink":"http://wysblogs.top/tags/算法/"},{"name":"开发经验","slug":"开发经验","permalink":"http://wysblogs.top/tags/开发经验/"},{"name":"centos","slug":"centos","permalink":"http://wysblogs.top/tags/centos/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://wysblogs.top/tags/MyBatis/"},{"name":"java设计模式","slug":"java设计模式","permalink":"http://wysblogs.top/tags/java设计模式/"},{"name":"Maven学习","slug":"Maven学习","permalink":"http://wysblogs.top/tags/Maven学习/"},{"name":"学习","slug":"学习","permalink":"http://wysblogs.top/tags/学习/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://wysblogs.top/tags/thymeleaf/"},{"name":"Docker","slug":"Docker","permalink":"http://wysblogs.top/tags/Docker/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://wysblogs.top/tags/Spring-Boot/"},{"name":"IDEA","slug":"IDEA","permalink":"http://wysblogs.top/tags/IDEA/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://wysblogs.top/tags/Spring-MVC/"},{"name":"Spring和MyBatis整合","slug":"Spring和MyBatis整合","permalink":"http://wysblogs.top/tags/Spring和MyBatis整合/"},{"name":"Ajax","slug":"Ajax","permalink":"http://wysblogs.top/tags/Ajax/"},{"name":"MyBatis学习","slug":"MyBatis学习","permalink":"http://wysblogs.top/tags/MyBatis学习/"},{"name":"JAVAEE框架作业","slug":"JAVAEE框架作业","permalink":"http://wysblogs.top/tags/JAVAEE框架作业/"},{"name":"Junit","slug":"Junit","permalink":"http://wysblogs.top/tags/Junit/"},{"name":"JAVA代理","slug":"JAVA代理","permalink":"http://wysblogs.top/tags/JAVA代理/"},{"name":"GitHub","slug":"GitHub","permalink":"http://wysblogs.top/tags/GitHub/"},{"name":"网站","slug":"网站","permalink":"http://wysblogs.top/tags/网站/"},{"name":"前进方向","slug":"前进方向","permalink":"http://wysblogs.top/tags/前进方向/"},{"name":"博客","slug":"博客","permalink":"http://wysblogs.top/tags/博客/"}]}