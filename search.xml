<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis配置文件整理]]></title>
    <url>%2F2019%2F09%2F16%2FMyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MyBatis配置文件整理log4j.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 ### 设置###log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n ### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n mybatis模板123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--属性--&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!--设置--&gt; &lt;settings&gt; &lt;setting name="" value=""/&gt; &lt;/settings&gt; &lt;!--别名--&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!--类型处理器--&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!--对象工厂--&gt; &lt;objectFactory type=""&gt;&lt;/objectFactory&gt; &lt;!--插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=""&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;!--配置环境--&gt; &lt;environments default=""&gt; &lt;!--环境变量--&gt; &lt;environment id=""&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type=""&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=""&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--数据库厂商标识--&gt; &lt;databaseIdProvider type=""&gt;&lt;/databaseIdProvider&gt; &lt;!--映射器,告诉mybatis去哪里找映射文件--&gt; &lt;mappers&gt; &lt;mapper&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper模板12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 在MyBatis中，Mapper中的namespace用于绑定Dao接口的，即面向接口编程。 它的好处在于当使用了namespace之后就可以不用写接口实现类， 业务逻辑会直接通过这个绑定寻找到相对应的SQL语句进行对应的数据处理--&gt;&lt;mapper namespace=""&gt; &lt;!--查询--&gt; &lt;select id=""&gt;&lt;/select&gt; &lt;!--增加--&gt; &lt;insert id=""&gt;&lt;/insert&gt; &lt;!--删除--&gt; &lt;delete id=""&gt;&lt;/delete&gt; &lt;!--修改--&gt; &lt;update id=""&gt;&lt;/update&gt; &lt;!--提供缓存支持--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!--参照缓存,用来引用另一个缓存--&gt; &lt;cache-ref namespace=""/&gt; &lt;!-- ParameterMap和ResultMap类似，设置入参字段映射，很少使用（不建议使用）--&gt; &lt;parameterMap id="" type=""&gt;&lt;/parameterMap&gt; &lt;!--查询结果集，映射java对象--&gt; &lt;resultMap id="" type=""&gt;&lt;/resultMap&gt;&lt;/mapper&gt; Spring整合模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSouce" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;!--加载数据库驱动--&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8"&gt;&lt;/property&gt; &lt;!--账户--&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;!--密码--&gt; &lt;property name="password" value="wang123"&gt;&lt;/property&gt; &lt;!--最大连接数--&gt; &lt;property name="maxTotal" value="30"&gt;&lt;/property&gt; &lt;!--最大空闲数--&gt; &lt;property name="maxIdle" value="10"&gt;&lt;/property&gt; &lt;!--初始化连接数--&gt; &lt;property name="initialSize" value="5"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--添加事务支持--&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager="txManager" /&gt; &lt;!--配置MyBatis工厂,同时指定数据源，并于MyBatis完美整合--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--指定数据源--&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;!--configLocation的属性值为MyBatis的核心配置文件--&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配 (Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口) --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!--mybatis-spring组件的扫描器--&gt; &lt;property name="basePackage" value=""&gt;&lt;/property&gt; &lt;!--注入工厂--&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring5约束头1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;/beans&gt; 整合Spring和MyBatis所使用的pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.my_priatices.aop&lt;/groupId&gt; &lt;artifactId&gt;my_priatices.aop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 待更新。。。。。。]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（三）]]></title>
    <url>%2F2019%2F09%2F12%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（三）基于XML装配Spring提供了两种基于XML的装配方式，分别是setter注入和构造方法注入 首先创建Bean的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;/** * 复杂数据的注入 */public class ComplexUser &#123; private String name; private List&lt;String&gt; hobbyList; private Map&lt;String,String&gt; residenceMap; private Set&lt;String&gt; aliasSet; private String[] array; public ComplexUser(String name, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array) &#123; this.name = name; this.hobbyList = hobbyList; this.residenceMap = residenceMap; this.aliasSet = aliasSet; this.array = array; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getHobbyList() &#123; return hobbyList; &#125; public void setHobbyList(List&lt;String&gt; hobbyList) &#123; this.hobbyList = hobbyList; &#125; public Map&lt;String, String&gt; getResidenceMap() &#123; return residenceMap; &#125; public void setResidenceMap(Map&lt;String, String&gt; residenceMap) &#123; this.residenceMap = residenceMap; &#125; public Set&lt;String&gt; getAliasSet() &#123; return aliasSet; &#125; public void setAliasSet(Set&lt;String&gt; aliasSet) &#123; this.aliasSet = aliasSet; &#125; public String[] getArray() &#123; return array; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; @Override public String toString() &#123; return "ComplexUser&#123;" + "name='" + name + '\'' + ", hobbyList=" + hobbyList + ", residenceMap=" + residenceMap + ", aliasSet=" + aliasSet + ", array=" + Arrays.toString(array) + '&#125;'; &#125;&#125; 配置Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="u1" class="com.bean.ComplexUser"&gt; &lt;!--构造方法注入--&gt; &lt;constructor-arg index="0" value="myname"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;码代码&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;map&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;entry key="beijing" value="北京"&gt;&lt;/entry&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;set&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang1&lt;/value&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang2&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="u2" class="com.bean.ComplexUser"&gt; &lt;property name="name" value="shuai"&gt;&lt;/property&gt; &lt;property name="hobbyList"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;搬砖&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="residenceMap"&gt; &lt;map&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="aliasSet"&gt; &lt;set&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s2&lt;/value&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="array"&gt; &lt;array&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;你太美&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类 123456789101112131415161718package com.test;import com.bean.ComplexUser;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); ComplexUser u1 = (ComplexUser)applicationContext.getBean("u1"); System.out.println(u1.toString()); ComplexUser u2 = (ComplexUser)applicationContext.getBean("u2"); System.out.println(u2.toString()); &#125;&#125; 结果 基于注解的装配因为要用到注解，所以我们来看看都有哪些基础的注解： 名称 作用 Component 代表一个组件对象，就是把普通的pojo实例到Spring容器中 Repository 此注解用于数据访问层（DAO），功能与Component相同 Service 此注解用于业务逻辑组件层（Service层），功能与Component相同 Controller 此注解用于标注一个控制器组件类（SpringMVC的Controller），功能与Component相同 AutoWired 此诸结可以对类成员变量，方法及构造方法进行标注，完成自动装配的工作。通过使用Autowired来消除setter和getter方法。默认按照Bean的类型进行装配，如果想按照名称来注入，就必须要和Qualifier搭配使用。 Resource 此注解与AutoWired相同，区别在于这个注解是按照名称来装配注入的，只有当找不到与名称匹配的名称时，才按照Bean的类型进行装配。 Qualifier 此注解要和AutoWired配合使用，Bean的实例名称有此注解的参数指定。 首先创建一个DAO层，和他的实现类，然后标上注解： TestDao 12345678910111213package com.dao;import org.springframework.stereotype.Repository;/** * 创建dao接口 */public interface TestDao &#123; /** * 保存 */ void save();&#125; TestDaoImpl 12345678910111213package com.dao.impl;import com.dao.TestDao;import org.springframework.stereotype.Repository;@Repository("testDao")public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println("TestDao save"); &#125;&#125; TestService 1234567891011package com.servlet;import org.springframework.stereotype.Service;/** * 业务层接口 */public interface TestService &#123; void save();&#125; TestServiceImpl 1234567891011121314151617181920212223package com.servlet.impl;import com.dao.TestDao;import com.servlet.TestService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * 业务层实现类 */@Service("testService")public class TestServiceImpl implements TestService &#123; @Resource(name="testDao") private TestDao testDao; @Override public void save() &#123; testDao.save(); System.out.println("TestService save"); &#125;&#125; TestController 12345678910111213141516171819package com.controller;import com.servlet.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controllerpublic class TestController &#123; @Autowired private TestService testService; public void save()&#123; testService.save(); System.out.println("TestController save"); &#125;&#125; 测试类 12345678910111213package com.test;import com.controller.TestController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); TestController testController = (TestController)applicationContext.getBean("testController"); testController.save(); &#125;&#125; 结果 课后题Bean的实例化有哪几种常见的方法？ ​ 答： 三种，构造方法，静态工厂，实例工厂 简述基于注解装配方式的基本用法？ ​ 答： 见上面的表格。 @AutoWired和@Resource有什么区别？ ​ 答：一个是按类别，一个是按名称 Bean的默认作用域是什么？ ​ 答：singleton 单例模式 使用类似于@Controller一样的注解的时候，Bean的id是什么？ ​ 答： 默认是首字母小写的类名]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F09%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[基础部分 javaSE MySQL，刚开始只需要了解一些基础的sql语句，例如增删改查，复杂一点的后面可以在学。 idea可以直接连接数据库 database，一开始可以多用用，熟悉熟悉 javaWeb：jsp（了解即可），（Servlet ，Filter，Listener），重点放在Listener 现在大多数都是异步机制和回调机制，Listener监听用的多，Filter用的少 （重点部分）SSM：Spring + MyBatis+Spring MVC Spring MVC：是Spring中的一部分 Spring：本身是一个容器 响应式编程 WebFlux，在开发中用的也不是很多，主要解决的是高并发问题，建议了解一下 Lambda表达式，基于接口实现的，建议学习 项目管理工具 Maven，得了解原理。 项目管理工具Git，也是分布式版本管理工具，然后项目要放到github上面 （重点部分）Spring Boot （快速开发框架），使用这个原因是因为SSM配置文件非常多，基本上都是样板式代码，因此必须把可重用性代码封装起来，所以这个Spring Boot必须得好好学习，重点！ 分布式开发技术（进阶部分） linux基础，因为服务器现在基本上都是搭建在无可视化界面的linux上面的 本地服务器搭建的工具（VMware（搭建虚拟机）+secureCRT（客户端）+CentOS 7 Mini版本（只有操作界面） 分布式协调服务器Zookeeper 反向代理服务器 Nginx 真正请求的服务器在后面，这个是代理集群，集群里面部署的应用都是一样的，一般都会选一个master作为主要的 正解：正向解析，把域名解析成ip地址 反解：反向代理，把ip地址解析成域名 正代：由内向外作代理 反代：由外向内做代理 分布式内存数据库Redis（NoSql非关系型数据库） 分布式消息队列Kafka，RocketMQ，RabbitMQ（ActiveMQ不用管它） 应用方面：削减峰值，并发量高的时候需要使用 分布式RPC框架Dubbo（阿里的框架）和微服务框架Spring Cloud 微服务：把服务分散开，每一个都是独立的工程，用哪个调哪个 高内聚，低耦合，便于复用 Spring Boot 一定要好好学习！！！]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>前进方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（二）]]></title>
    <url>%2F2019%2F09%2F04%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBeanBean的配置​ Spring用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持Xml和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 ​ &lt;bean&gt;元素的常用属性及其子元素 描述 属性或子元素名称 id Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称 class Bean的具体实现类，使用类的名（例如dao.TestDIDaoImpl） scope 指定Bean实例的作用域 &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值 &lt;property&gt; &lt;bean&gt;元素的子元素用于设置一个属性，该元素的name属性指定Bean实例中相应的属性名称，value属性指定Bean的属性值，ref属性指定属性对BeanFactory中其他Bean的引用关系 &lt;list&gt; &lt;property&gt;元素的子元素，用于封装List或数组类型的依赖注入 &lt;map&gt; &lt;property&gt;元素的子元素，用于封装Map类型的依赖注入 &lt;set&gt; &lt;property&gt;元素的子元素，用于封装Set类型的依赖注入 &lt;entry&gt; &lt;map&gt;元素的子元素，用于设置一个键值对 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，也需要实例化Bean，Spring框架实例化Bean有三种方式 即，构造方法实例化、静态工厂实例化和实例工厂实例化（最常用就是构造方法实例化）。 1. 构造方法实例化 spring-config.xml配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213package com.test;import com.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); AccountService accountService = (AccountService)applicationContext.getBean("accountService"); accountService.addAccountMoney("张三",1000f); &#125;&#125; 2. 静态工厂实例化对象（开发中不使用，再次不列举使用方法）3. 实例工厂实例化对象（这个也不列举）Bean的作用域 作用域名称 描述 singleton 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例 prototype Spring容器每次获取protopyte定义的Bean，容器都将创建一个新的Bean实例 request 在一次Http请求中容器将返回一个Bean实例，不同的Http请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用 session 在一个HTTP Session 中，容器将返回同一个Bean实例。尽在Web Spring应用程序上下文中使用 application 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例，尽在Web Spring应用程序上下文中使用 websocket 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用 1. singleton作用域​ 由于singleton是bean的scope默认设置，所以写好bean之后就可以进行测试 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.test.AccountServiceImpl" scope="singleton"&gt;&lt;/bean&gt;&lt;/beans&gt; 代码如下 123456789101112131415package com.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); //第一个对象 AccountServiceImpl a1 = (AccountServiceImpl)applicationContext.getBean("accountService"); //第二个对象 AccountServiceImpl a2 = (AccountServiceImpl)applicationContext.getBean("accountService"); System.out.println(a1 == a2); &#125;&#125; 结果展示： 2. prototype作用域代码如上所述，然后只设置scope作用域即可 结果展示: Bean的生命周期​ 一个对象的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段，在Spring中，Bean对象周期也遵循这一过程，但是Spring提供了许多对外接口，允许开发者对3个过程（实例化、初始化、销毁）的前后做一些操作。在Spring Bean中，实例化是为Bean对象开辟空间，初始化则是对属性的初始化。 ​ Bean生命周期整个过程如下： ​ （1）根据Bean的配置情况实例化一个Bean。 ​ （2）根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。 ​ （3）如果Bean实现了BeanNameAware 接口，将调用它实现的，setBeanName（String beanId）方法， 此处参数传递的是Spring配置文件中Bean的id。 ​ （4）如果Bean实现BeanFactoryAware接口，将调用它实现的setBeanFactory方法，此处参数传递的是当前Spring工厂实例的引用。 ​ （5）如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext（ApplicationContext）方法，此处参数传递的是Spring上下文实例的引用。 ​ （6）如果Bean关联了BeanPostProcessor接口，将调用初始化方法postProcessBeforeInitialization（Object obj， String s）对Bean进行操作。 ​ （7）如果Bean实现了InitializingBean接口， 将调用afterPropertiesSet方法。 ​ （8）如果Bean在Spring配置文件中配置了 init-method 属性，将自动调用其配置的初始化方法。 ​ （9）如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization（Object obj，String s）方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。 ​ （10）当Bean不再需要时将进入销毁阶段，如果Bean实现了DisposableBean接口，则调用其实现的destroy方法将Spring中的Bean销毁。 ​ （11）如果在配置文件中通过destory-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。 ​ 在Spring中，通过特定的接口或通过&lt;bean&gt;元素的属性设置可以对Bean的生命周期过程产生影响。 ​ 例子： ​ 创建Bean的实现类 12345678910111213package com.test;/** * @author wys */public class BeanLife &#123; public void initMyself()&#123; System.out.println(this.getClass().getName()+"执行了自定义的初始化方法"); &#125; public void destroyMyself() &#123; System.out.println(this.getClass().getName()+"执行了自定义的销毁方法"); &#125;&#125; ​ 配置Bean 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="beanLife" class="com.test.BeanLife" init-method="initMyself" destroy-method="destroyMyself"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 测试生命周期 12345678910111213141516package com.test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("spring-config.xml"); System.out.println("获得对象前"); BeanLife beanLife = (BeanLife)ctx.getBean("beanLife"); System.out.println("获得对象后"+beanLife); ctx.close(); &#125;&#125; 结果如下:]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next界面美化]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E7%9A%84next%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[设置中文首先查看一下next/theme/language中的语言类型，一般就是zh-CN或者是zh-Hans`这个类型 然后在hexo的配置文件_config.yml把写上去就行 主题风格将next中的_config.yml配置文件修改一下 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 这个把前面的#去掉换另一种就行，我觉得第三种就挺好看的。个人喜好 设置分类还是在next中的_config.yml配置文件修改 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把对应菜单的选项注释去掉就好 然后创建目录,不同标签对应不同的代码 1$ hexo new page categories 创建完毕之后，进去修改一下 类似于categories这种的 123456---title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: "categories"--- 添加头像搜索next中的_config.yml配置文件 搜索Sidebar Avatar这个关键字，去掉avatar前面的# 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.gif 然后把头像放到指定的文件夹 设置侧边栏的的社交链接打开themes/next/_config.yml文件，搜索关键字social，然后添加社交站点名称与地址即可。 1234567891011social: GitHub: https://github.com/wyscoder|| github E-Mail: mailto:714133840@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 修改底部的声明和版权主题配置文件下，搜索关键字post_copyright，enable改为true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 去掉强力驱动 找到hexo根目录&gt;&gt;themes&gt;&gt;next&gt;&gt;layout&gt;&gt;_partials下的footer.swig文件 然后打开删除 123456789101112131415161718&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 这部分内容就好 最后修改一下hexo中的配置文件名字就行 添加搜索功能首先安装一下搜索插件 $ npm install hexo-generator-searchdb --save 打开Hexo站点的_config.yml，添加配置 : 12345search: path: search.xml field: post format: html limit: 10000 打开themes/next/_config.yml，搜索关键字local_search，设置为true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 本地站点推送到GitHub上安装插件 1$ npm install hexo-deployer-git --save 在Hexo站点的_config.yml中配置deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo g -d 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=110 src=&quot;//music.163.com/outchain/player?type=0&amp;id=408443429&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 就好了 添加背景动画效果 修改_layout.swig 打开 next/layout/_layout.swig 在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话 可以这么设置====&gt; 在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加代码复制功能首先找到这个目录themes/next/layout/_third-party/ 然后在此文件夹下创建名为copy-code.swig的文件，在此文件中输入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125;&lt;/style&gt;&lt;script&gt; $('.highlight').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap') $(e).after($wrap) $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text() &#125;).toArray().join('\n') var ta = document.createElement('textarea') document.body.appendChild(ta) ta.style.position = 'absolute' ta.style.top = '0px' ta.style.left = '0px' ta.value = code ta.select() ta.focus() var result = document.execCommand('copy') document.body.removeChild(ta) if(result)$(this).text('复制成功') else $(this).text('复制失败') $(this).blur() &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn') setTimeout(function () &#123; $b.text('复制') &#125;, 300) &#125;).append(e) &#125;)&lt;/script&gt; 然后返回上一层目录，即layout文件夹下，编辑_layout.swig， 在最底部，&lt;/body&gt;上面添加 1&#123;% include &apos;_third-party/copy-code.swig&apos; %&#125; 这句话接着就能用了]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO搭建博客（搭建在github上面）]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言学长给的几个教程链接 https://blog.csdn.net/u013332124/article/details/80680156 https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html#validate-next-theme https://blog.csdn.net/llmmll08/article/details/70246150 1.什么是hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.安装1.前提​ 必须有Node.js 和 Git, 还有Github账号，都具备之后就开始了 2.创建github pages页面 首先创建仓库（repository ），然后仓库名字必须得是 yourname.github.io 这个，比如我的github名称是wyscoder，所以仓库名称就是 wyscoder.github.io 然后记住这个仓库的git地址 https://github.com/wyscoder/wyscoder.github.io 3.安装hexo 这个是需要node.js和git作为前置的，如果没有就去下载node.js和git 接下来就只需要npm就可以完成安装了 使用这个命令进行安装hexo$ npm install -g hexo-cli 等待下载完毕就行 4. 建站 安装hexo完成之后，执行下面命令就会在指定文件夹创建需要的文件 1234node.js$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 具体参数信息请查看官方文档 https://hexo.io/zh-cn/docs/configuration package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-stylus": "^0.3.3", "hexo-renderer-marked": "^0.3.2", "hexo-server": "^0.3.3" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 5.上传站点生成后,就可以开始写文章了。dos界面下,进入所在站点目录，输入hexo new [layout] &lt;title&gt;命令。hexo会自动帮你生成一个 &lt;title&gt;.md 的文件。然后你就可以在这个文件上编写你的博客内容了。 写完博客后,我们先试着在本地部署一下服务。还是在dos命令下，进入站点目录。一次输入: 123hexo clean # 清除缓存,之后会经常用到hexo g # 生成站点静态文件hexo s # 部署服务 上面是本地部署，之后就可以通过localhost:4000来访问博客了 但是如果想让别人访问你的还需要提交到git上面 打开cmd 然后输入npm install hexo-deployer-git --save安装git工具 开站点目录下面的配置文件_config.yml(用任意编辑器),配置deploy参数。一开始配置文件是这样的: 12deploy: type: 我们把它改成我们的git仓库地址。 1234deploy: type: git repository: ssh://git@github.com/wyscoder/wyscoder.github.io branch: master 修改好之后执行 123hexo clean hexo g hexo d # 部署到远程仓库 令全部执行完后。我们就可以访问我们的博客网站了。https://wyscoder.github.io 6.问题在使用hexo d提交的时候出现了几个问题 首先是你得使用git命令来设置用户和邮箱 config --global user.name "nameVal" ```12```git config --global user.email &quot;eamil@qq.com&quot; 其中我还测试了一下那个git的基本命令，都是卡在提交那一点，原因是没有密匙 如果电脑上没有ssh密匙我建议还是要安装一下 7.美化博客：使用nexT主题博客是搭建好了, 但是我们发现hexo的默认主题风格比较丑。好在hexo的主题是可定制的。所以我们可以更换别人已经做好的主题。nexT就是其中一个比较强大的主题。下面简单的教大家怎么切换到这个主题。​ 先去nexT的github页面下载nexT项目。https://github.com/iissnan/hexo-theme-next。然后放到站点目录下面的一个themes文件夹中。解压。 解压后会得到一个hexo-theme-next-master文件夹。重命名成next。 修改站点配置文件_config.yml里面的theme参数,修改值为next。 ​ 重新清除缓存,生成新的资源文件，然后部署,主题就切换成next了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（一）]]></title>
    <url>%2F2019%2F08%2F10%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring简介1. Spring由来 目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题 2. Spring体系结构 核心容器（Core Container） 数据访问/ 集成（Data Access/Integration）层 Web层 AOP（Aspect Oriented Programming，面向切面的编程）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test） Spring体系结构 SpringIOC1. Spring IOC基本概念控制反转是一个比较抽象的概念，是Spring框架的核心，用来削减计算机程序的耦合问题。 依赖注入是IOC的另外一种说法。 解释 ​ 当某个java对象需要调用另一个对象时，在传统编程模式下，调用者通常会采用 “new 被调用者” 的方式来创建对象，这种方式会增加调用者和被调用者之间的耦合性，不利于后期代码的维护。 ​ 当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 ​ 从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入他所依赖的实例，这就是Spring依赖注入。 ​ 综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方产生或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入。 2. SpringIOC容器SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口。 BeanFactory(1). 概念​ BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，它提供了完整的Ioc服务支持，是一个管理BeanFactory的工厂，主要负责初始化各种Bean。BeanFactory接口有许多实现类，比较常用的就是org.springframework.beans.factory.xml.XmlBeanFactory.这个类会根据XML来装配Bean，创建时候需要提供XML文件的绝对路径。 123456public static void main(String[] args)&#123; //初始化Spring容器，加载配置文件 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("绝对路径")); TestDao testDao = (TestDao)beanFactory.getBean("testDao"); testDao.sayHello();&#125; 这种写法开发中一般不常见，了解即可。 ApplicationContext​ ApplicationContext是BeanFactory的子接口，也称为应用上下文，org.springwork.context.ApplicationContext接口定义，ApplicationContext接口除了包含BeanFactory的所有功能外，还添加了国际化，资源访问，事件传播等内容的支持。 ​ 创建ApplicationContext接口实例通常有以下三种方式: (1). *通过ClassPathXmlApplicationContext创建 *：​ ClassPathXmlApplicationContext将类路径目录（src根目录）中寻找指定的XML配置文件，代码如下： 1234567public static void main(String[] args)&#123; //初始化Spring容器ApplicationContext,加载配置文件 ApplicationContext ac = ClassPathXmlApplicationContext("spring-config.xml"); //通过容器获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; (2). 通过FileSystemXmlApplicationContext创建：​ FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public stsatic void main(String[] args)&#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext ac = new FileSystemXmlApplication("C:\Users\hp\IdeaProjects\my_pratices_account_day_01\src\main\resources\spring-config.xml"); //获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。 (3). 通过Web服务器实例化ApplicationContext容器​ 在Web服务器实例化ApplicationContext容器时，一般使用org.springframework.web.context.ContextLoaderListener的实现方式（需要导入spring-web.5.0.2.RELEASE.jar包），此方法只需在web.xml中添加如下代码： 1234567891011&lt;context-param&gt; &lt;!--加载src目录下的spring-config.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3. 依赖注入的类型构造方法注入Spring框架可以采用java的反射机制，通过构造方法完成依赖注入 首先创建持久层接口 1234567891011package com.test.dao;/** * 创建持久层 */public interface TestDao &#123; /** * Hello方法 */ void sayHello();&#125; 然后创建持久层实现类 1234567891011package com.test.dao.impl;import com.test.dao.TestDao;public class TestDaoImpl implements TestDao &#123; @Override public void sayHello()&#123; System.out.println("Hello World"); &#125;&#125; 创建业务层接口 12345678package com.test.service;/** * 业务层 */public interface TestService &#123; void sayHello();&#125; 创建业务层实现类 12345678910111213141516171819package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public TestServiceImpl(TestDao testDao)&#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 配置spring-config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;constructor-arg ref="testDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后在测试类中测试一下 1234567891011121314package com.test;import com.test.service.TestService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-config.xml"); TestService testService = (TestService)ac.getBean("testService"); testService.sayHello(); &#125;&#125; 然后看一下结果 以上就是构造注入 属性的setter注入和上面创建一样，只需要更改一下TestServiceImpl中的代码和spring-config.xml就行 123456789101112131415161718192021package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public void setTestDao(TestDao testDao) &#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;property name="testDao" ref="testDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 4. 课后习题 举例说明IOC容器的实现方式有哪些？ 控制反转和依赖注入 spring中什么是控制反转？什么是依赖注入？使用控制反转与依赖注入的优点？ 控制反转：是一种通过描述并通过第三方去产生去获取特定对象的方式 依赖注入：使用spring框架创建对象时动态的将其所依赖的对象注入到Bean组件中。 控制反转优点： ​ 1.获取对象可以通过注解等方式获取对象，打破传统的获取方式 ​ 2.对象不再由程序本身进行创建，而是交给spring容器创建，降低了程序的耦合性 ​ 3.控制反转能做到更多的事情，例如事务控制 ​ 4.后期维护方便 依赖注入优点： ​ 1.项目开发讲究高内聚，低耦合 ​ 2.使用依赖注入可以避免使用new关键字创建对象，从而降低类与类之间的耦合度 spring框架采用java的反射机制进行依赖注入.]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
