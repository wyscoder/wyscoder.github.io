<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVAEE框架第二次作业]]></title>
    <url>%2F2019%2F09%2F26%2FJAVAEE%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[JAVAEE框架第二次作业一对多（one-to-many）分析首先思考一下，一对多的关系都有哪些，很容易我们就可以想到，文章，一个人可以发很多篇文章，但是每篇文章只能对应一个人，这就是一对多关系，除此之外，还可以想到父子关系，一个父亲可以有多个孩子，但是每个孩子只能对应一个父亲，了解完关系之后，我们就能开始着手写了。 建表我们以作者和文章的关系来创建数据库的表，首先了解作者和文章的属性，然后确定数据库表的主键和外键。 作者（Author）属性: 作者编号，作者名称；其中主键是作者编号。编号为自增序列。 文章（Article）属性： 文章编号，文章名称，文章内容； 其中主键是文章编号，编号是自增序列。 建表： 理清楚上面关系后我们建表开始，sql命令如下： 12345678910111213create table article( article_id int not null auto_increment, name varchar(35) not null, content varchar(255), author_id int not null, primary key(article_id));create table author( author_id int not null auto_increment, name varchar(35) not null, primary key(author_id)); 这样我们就有了一个article表和author表，然后就可以写后台了。 pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pojo;import java.util.AbstractList;import java.util.ArrayList;import java.util.List;/** * 作者的实体类 */public class Author &#123; //作者编号 private int id; //作者名称 private String name; //作者所著文章 建立一对多关系 private List&lt;Article&gt; articles; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Article&gt; getArticles() &#123; return articles; &#125; public void setArticles(List&lt;Article&gt; articles) &#123; this.articles = articles; &#125; @Override public String toString() &#123; return "Author&#123;" + "id=" + id + ", name='" + name + '\'' + ", articles=" + articles + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.pojo;/** * 文章的实体类 */public class Article &#123; //文章编号 private int id; //文章名称 private String name; //文章内容 private String content; //作者 建立多对一关系 private Author author; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Author getAuthor() &#123; return author; &#125; public void setAuthor(Author author) &#123; this.author = author; &#125; @Override public String toString() &#123; return "Article&#123;" + "id=" + id + ", name='" + name + '\'' + ", content='" + content + '\'' + ", author=" + author + '&#125;'; &#125;&#125; 导入依赖（包名省略） 创建持久层 12345678910111213141516171819202122package com.dao;import com.pojo.Article;import com.pojo.Author;import java.util.List;/** * 作者的持久层 * 我们这个只需要完成一个一对多查询就行 * 所以只写了一个方法 */public interface AuthorDao &#123; /** * 查询作者所有文章 * @param id * @return */ Author selectArticlesList(int id);&#125; 创建mybatis配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;!--这个密码是我自己的，有需要可以修改--&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;!--可以XML配置，可以注解，这里就用xml配置了--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/Author.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建mapper映射文件 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.AuthorDao"&gt; &lt;!--一对多写法--&gt; &lt;resultMap id="AuthorMap" type="com.pojo.Author"&gt; &lt;id column="author_id" property="id"&gt;&lt;/id&gt; &lt;result column="author_name" property="name"&gt;&lt;/result&gt; &lt;collection property="articles" ofType="com.pojo.Article"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="name" property="name"&gt;&lt;/result&gt; &lt;result column="content" property="content"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--别名要加空格--&gt; &lt;select id="selectArticlesList" parameterType="int" resultMap="AuthorMap"&gt; select a.id author_id,a.name author_name, b.* from author a left join article b on a.id = b.author_id where a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import java.io.*;import java.util.List;import com.dao.AuthorDao;import com.pojo.Article;import com.pojo.Author;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;public class AuthorTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before() throws IOException &#123; InputStream in = Resources.getResourceAsStream("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); &#125; /** * 获取作者所写的所有文章 */ @Test public void getArticles() &#123; SqlSession session = sqlSessionFactory.openSession(); AuthorDao authorDao = session.getMapper(AuthorDao.class); Author author = authorDao.selectArticlesList(1); for(Article i : author.getArticles()) &#123; System.out.println(i.getName()); &#125; &#125;&#125; 多对一多对一在一对一基础上进行修改，增加了一个持久层和mapper文件，就是根据多个文章查找到作者信息。 持久层 1234567891011121314151617package com.dao;import com.pojo.Article;import com.pojo.Author;/** * 文章持久层 */public interface ArticleDao &#123; /** * 根据帖子ID查找作者信息 * @param id * @return */ Article selectAuthorByArticle(int id);&#125; mapper 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dao.ArticleDao"&gt; &lt;resultMap id="ArticleMap" type="com.pojo.Article"&gt; &lt;id column="article_id" property="id"&gt;&lt;/id&gt; &lt;result column="article_name" property="name"&gt;&lt;/result&gt; &lt;result column="content" property="content"&gt;&lt;/result&gt; &lt;!--存储查询的用户所属信息--&gt; &lt;association property="author" javaType="com.pojo.Author"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="name" property="name"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectAuthorByArticle" resultMap="ArticleMap" parameterType="int"&gt; select b.* from article a,author b where b.id= a.author_id and a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789@Testpublic void getAuthor() &#123; SqlSession session = sqlSessionFactory.openSession(); ArticleDao articleDao = session.getMapper(ArticleDao.class); Article article = articleDao.selectAuthorByArticle(1); System.out.println(article.getAuthor().getName()); session.close();&#125; 大概就上面那么多了，剩下的等上完课再进行修改吧。。。 还是有很多知识都不懂，很难受。。。]]></content>
      <categories>
        <category>JAVAEE框架作业</category>
      </categories>
      <tags>
        <tag>JAVAEE框架作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（四）]]></title>
    <url>%2F2019%2F09%2F23%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（四）Spring AOP的基本概念AOP（Aspect-Oriented Programming）即面向切面编程，他与OOP（Object-Oriented Programming,面向对象编程）相辅相成。 在OOP中，以类作为程序的基本单元，而AOP中的基本单元是Aspect（切面）。Struts2的拦截器设计就是基于AOP的思想，是一个比较经典的应用。 在业务处理代码中通常由日志记录，性能统计，安全控制，事务处理，异常处理等操作，尽管使用OOP可以封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中，因此，采用OOP等日志记录等操作不仅增加了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题，AOP思想应允而生。 AOP采取横向抽取机制，即将分散在各个方法中的重复代码提取出来，然后在程序编译或者运行阶段，将这些抽取出来的代码应用到需要执行的地方。这种横向抽取机制采用传统的OOP是无法办到的，因为OOP实现的是父子关系的纵向重用。但是AOP不是OOP的替代品，而是OOP的补充，他们是相辅相成的。 在AOP中，横向抽取机制的类与切面的关系如图所示： AOP的术语 名称 意义 切面 切面（Aspect）是指封装横切到系统功能（例如事务处理）的类。 连接点 连接点（Joinpoint）是指程序运行中的一些时间点，例如方法的调用或异常的抛出。 切入点 切入点（Pointcut）是指需要处理的连接点。在Spring Aop中，所有的方法执行都是连接点，二切入点是一个面熟信息，他修饰的是连接点，通过切入点确定那些连接点需要被处理。 通知 通知（Advice）是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。 引入 引入（Introduction）允许在现有的实现类中添加自定义的方法和属性 目标对象 目标对象（Target Object）是指所有被通知的对象。如果AOP框架使用运行时代代理的方式（动态AOP）来实现切面，那么通知对象总是一个代理对象。 代理 代理（Proxy）是通知应用到目标对象之后被动态创建的对象。 织入 织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术，AOP织入有3种方式：编译器织入，需要有特殊的java编译器；类装载期织入，需要有特殊的类装载器；动态代理织入，在运行期为目标类添加通知生成子类的方式。Spring AOP框架默认采用动态代理织入，而AspectJ（基于java语言的AOP框架）采用编译期织入和类装载期织入。 AOP依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 这些是aop依赖的核心部分 剩下的就是spring核心jar包了，此处就不一一列举 基于XML的AOPxml配置 12345678910111213141516&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* *.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref="MyAspect"&gt; &lt;!--前置通知--&gt; &lt;aop:before method="beforeAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt; &lt;!--后置通知--&gt; &lt;aop:after method="afterAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method="exceptionAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after-throwing&gt; &lt;!--最终通知--&gt; &lt;aop:after-returning method="finallyAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after-returning&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 实现类 12345678910111213141516171819202122232425262728293031323334353637package com.util;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面 */public class MyAspect &#123; public void beforeAdvice() &#123; System.out.println("这是前置通知!-----比如创建连接对象"); &#125; public void afterAdvice() &#123; System.out.println("这是后置通知!------比如提交事务"); &#125; public void finallyAdvice() &#123; System.out.println("这是最终通知-------比如关闭连接"); &#125; public void exceptionAdvice() &#123; System.out.println("这是异常通知-------比如回滚事务"); &#125; public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println("这是前置通知!-----比如创建连接对象"); try&#123; joinPoint.proceed(); System.out.println("这是后置通知!------比如提交事务"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("这是异常通知-------比如回滚事务"); &#125;finally &#123; System.out.println("这是最终通知-------比如关闭连接"); &#125; &#125;&#125; 环绕通知 123456789&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* *.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref="MyAspect"&gt; &lt;aop:around method="aroundAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 执行顺序 前置通知： 在方法执行前执行 后置通知： 在方法执行后执行，如果有异常，就不会执行这个 最终通知： 执行完所有通知之后执行 异常通知： 发生异常的时候执行 环绕通知： 包含了以上四种通知类型 基于注解的AOP注解 名称 作用 @Aspect 表示这是一个切面类 @Before 在方法执行前执行 @After 在方法执行后执行，如果有异常，就不会执行这个 @AfterReturning 执行完所有通知之后执行 @AfterThrowing 发生异常的时候执行 @Around 包含了以上四种通知类型 @Pointcut 切入点表达式 切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.util;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * 切面 */@Aspect@Componentpublic class MyAspect &#123; @Pointcut("execution(* *.*(..))") public void pointcut()&#123;&#125; @Before("pointcut()") public void beforeAdvice() &#123; System.out.println("这是前置通知!"); &#125; @After("pointcut()") public void afterAdvice() &#123; System.out.println("这是后置通知!"); &#125; @AfterReturning("pointcut()") public void finallyAdvice() &#123; System.out.println("这是最终通知"); &#125; @AfterThrowing("pointcut()") public void exceptionAdvice() &#123; System.out.println("这是异常通知"); &#125; @Around("pointcut()") public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println("前置通知"); try&#123; joinPoint.proceed(); System.out.println("后置通知"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("异常通知"); &#125;finally &#123; System.out.println("最终通知"); &#125; &#125;&#125; 一定要给这个类使用Component注解，不然不会把这个加入Spring容器中 在XML中开启注解支持 12&lt;!--启动基于注解的Aspect的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 测试类不变 结果和上面一致 课后习题1. 什么是AOP？AOP有哪些术语？为什么要学习AOP编程？ AOP就是面向切面编程，术语的话参考上面的AOP术语。 AOP可以处理OOP不能处理的问题，AOP可以减少大量代码编写，抽取重复代码块，增加代码复用率，减少耦合性，使开发者逻辑更清晰，工作更简单。 2. 在Java中有哪些常用的动态代理技术？ Proxy Cglib 3. AspectJ框架的AOP开发方式有几种？ 基于XML的开发方式 基于注解的开发方式]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit单元测试]]></title>
    <url>%2F2019%2F09%2F23%2FJunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[整合JUnit单元测试JUnit概述JUnit是一个基于java语言的单元测试框架，Junit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。 依赖所依赖的导包 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; spring-test是整合spring时所需要依赖的包 junit就是进行单元测试所需要依赖的包 还需要其他的Spring核心jar包，这就不一一列举了 注解RunWith@RunWith：就是一个运行器 @RunWith(JUnit4.class)：就是指用JUnit4来运行 @RunWith(SpringJUnit4ClassRunner.class)： 让测试运行于Spring测试环境 @RunWith(Suite.class)： 一套测试集合 ContextConfiguration概念： Spring整合JUnit4测试时，使用注解引入多个配置文件 单个文件： @ContextConfiguration(Locations=&quot;classpath:spring-config.xml&quot;) @ContextConfigruation(classes=Configuration.class) 多个文件： @ContextConfiguration(locations={&quot;classpath:spring-config1.xml&quot;,&quot;classpath:spring-config2.xml&quot;}) 样例123456789101112131415161718192021222324252627package com.test;import com.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * 初始化Spring容器 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:spring-config.xml")public class AccountTest &#123; @Resource(name="accountService") private AccountService accountService; @Test public void Test() &#123; accountService.saveAccount(); &#125;&#125;]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE框架第一次作业]]></title>
    <url>%2F2019%2F09%2F18%2FJAVAEE%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[JAVAEE框架第一次作业分析&nbsp;&nbsp;&nbsp;&nbsp;首先，我之前认为是为了优化实现类中的方法，所以想到了整合Spring然后利用AOP的事务通知来使持久层的实现类中方法解耦，后来才明白原来是直接将实现类中的方法整合在测试类中进行使用（是我太菜了，确信！） 代码整合删除实现类 &nbsp;&nbsp;&nbsp;&nbsp;这个过程是为了使测试类中提示错误，从而有针对性，便于修改 修改测试类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.abc;import static org.junit.Assert.assertTrue;import com.abc.beans.Student;import com.abc.dao.IStudentDao;import com.abc.utils.MyBatisUtil;import org.apache.ibatis.session.SqlSession;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Unit test for simple App. */public class MyTest&#123; private IStudentDao dao; private SqlSession sqlSession; @Before public void before() throws IOException &#123; sqlSession = MyBatisUtil.getSqlSession(); dao = sqlSession.getMapper(IStudentDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; /** * Rigorous Test :-) */ //插入学生信息 @Test public void Test01() &#123; Student student = new Student("王五",21,80.5); System.out.println("插入前："+student); dao.insertStudent(student); sqlSession.commit(); System.out.println("插入后："+student); System.out.println("插入成功！"); &#125; //获取新插入学生id @Test public void Test02() &#123; Student student = new Student("李四",19,90.5); System.out.println("插入前："+student); dao.insertStudentCatchId(student); sqlSession.commit(); System.out.println("插入后："+student); System.out.println("插入成功！"); &#125; //删除学生信息 @Test public void Test03() &#123; dao.deleteStudentById(29); sqlSession.commit(); System.out.println("删除成功！"); &#125; //修改学生信息 @Test public void Test04() &#123; Student student = new Student("小绿",22,96); student.setId(30); dao.updateStudent(student); sqlSession.commit(); System.out.println("修改成功！"); &#125; //查询全部学生信息List @Test public void Test05() &#123; List&lt;Student&gt; students = dao.selectAllStudent(); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //查询全部学生信息Map @Test public void Test06() &#123; Map&lt;String,Student&gt; map = dao.selectAllStudentMap(); System.out.println(map.get("李四")); &#125; //按照id查询学生信息 @Test public void Test07() &#123; Student student = dao.selectStudentById(30); System.out.println(student); &#125; //按照name查询学生信息 @Test public void Test08() &#123; List&lt;Student&gt; students = dao.selectStudentByName("小绿"); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息1 //把多个参数封装到对象 @Test public void Test09() &#123; Student student = new Student("小",20,-1); List&lt;Student&gt; students = dao.selectStudentByCondition(student); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息2 //把多个查询条件封装到map @Test public void Test10() &#123; Map map = new HashMap(); Student student1 = new Student(null,18,-1); Student student2 = new Student(null,22,-1); map.put("stu1",student1); map.put("stu2",student2); List&lt;Student&gt; students = dao.selectStudentByCondition2(map); for (Student s:students)&#123; System.out.println(s); &#125; &#125;&#125; Mapper配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.abc.dao.IStudentDao"&gt; &lt;!-- 1.parameterType可以省略，但若不省略一定把后边的类型填写正确 2.sql语句中value中的内容，必须是#&#123;&#125;，其中name，age，score指的 是传入参数对象的属性，其底层是通过反射机制从参数对象的get方法获取相应的属性值 --&gt; &lt;insert id="insertStudent" parameterType="com.abc.beans.Student"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;/insert&gt; &lt;insert id="insertStudentCatchId"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select last_insert_id() &lt;!--select @@identity--&gt; &lt;/selectKey&gt; &lt;/insert&gt; &lt;delete id="deleteStudentById" parameterType="int"&gt; delete from student where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id="updateStudent"&gt; update student set name=#&#123;name&#125;,age=#&#123;age&#125;,score=#&#123;score&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--resultType不是最终需要的结果类型，而是查询出每一条数据封装的结果类型--&gt; &lt;select id="selectAllStudent" resultType="Student"&gt; select id,name,age,score from student &lt;/select&gt; &lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id = #&#123;xx&#125; &lt;/select&gt; &lt;select id="selectStudentByName" resultType="Student"&gt; &lt;!--select id,name,age,score from student where name like '%小%'--&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' &lt;!--select id,name,age,score from student where name like concat('%',#&#123;name&#125;,'%')--&gt; &lt;!--select id,name,age,score from student where name like '%$&#123;value&#125;%'--&gt; &lt;/select&gt; &lt;select id="selectStudentByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' and age &amp;lt; #&#123;age&#125; &lt;/select&gt; &lt;select id="selectStudentByCondition2" resultType="Student"&gt; &lt;!--select id,name,age,score from student where age &gt; #&#123;min&#125; and age &amp;lt; #&#123;max&#125;--&gt; select id,name,age,score from student where age &gt; #&#123;stu1.age&#125; and age &amp;lt; #&#123;stu2.age&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;中可以写什么内容： 1.若传入参数为基本数据类型，可以为任意字符，起占位符的作用 2.若传入参数为对象，必须为对象的属性 3.若传入参数为map 1）如果map中的值为基础数据类型，可以放map的key 2）如果map中的值为对象，可以放map的key.属性 --&gt;&lt;/mapper&gt; 由于配置文件和持久层中有些方法命名不匹配，所以我都进行了修改，持久层代码 12345678910111213141516171819202122232425262728package com.abc.dao;import com.abc.beans.Student;import java.util.List;import java.util.Map;public interface IStudentDao &#123; void insertStudent(Student student); void deleteStudentById(int id); void insertStudentCatchId(Student student); void updateStudent(Student student); List&lt;Student&gt; selectAllStudent(); Map&lt;String, Student&gt; selectAllStudentMap(); Student selectStudentById(int id); List&lt;Student&gt; selectStudentByName(String name); List&lt;Student&gt; selectStudentByCondition(Student student); List&lt;Student&gt; selectStudentByCondition2(Map map);&#125; &nbsp;&nbsp;&nbsp;&nbsp;同时如果出现无法连接数据库等问题，请到MyBatis配置文件中修改数据库连接的信息，或者也需要去修改你自己的MySQL数据库中的数据库或者表的信息。 以上便是整个过程，如果有错误，我会及时修改。]]></content>
      <categories>
        <category>JAVAEE框架作业</category>
      </categories>
      <tags>
        <tag>JAVAEE框架作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA代理]]></title>
    <url>%2F2019%2F09%2F18%2FJAVA%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[jAVA代理代理模式​ 使用一个代理对象将对象包装起来，然后用该代理对象来取代该对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时调用原始对象的方法 静态代理​ 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。如下图： ​ Client调用Source的method()方法，实际上是Proxy来调用method()方法，静态代理中Source跟Proxy都要实现接口Sourceable。 实现方式创建接口 123456789package com.proxy;public interface ClientDao &#123; /** * 主体内容 */ void content();&#125; 创建实现类 1234567891011package com.proxy;public class ClientDaoImpl implements ClientDao&#123; /** * 实现的方法 */ @Override public void content() &#123; System.out.println("这是主体内容"); &#125;&#125; 创建代理类 12345678910111213141516package com.proxy;public class ClientStaticProxy implements ClientDao&#123; private ClientDao clientDao; public void setClientDao(ClientDao clientDao) &#123; this.clientDao = clientDao; &#125; @Override public void content() &#123; System.out.println("对方法增强前"); clientDao.content(); System.out.println("对方法增强后"); &#125;&#125; 测试类 1234567891011121314package com.test;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientStaticProxy clientStaticProxy = new ClientStaticProxy(); ClientDao clientDao = new ClientDaoImpl(); clientStaticProxy.setClientDao(clientDao); clientStaticProxy.content(); &#125;&#125; 结果 优点 可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截 缺点 因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增强方法，则目标对象和代理类都需要维护。 动态代理JDK代理​ 动态代理是指动态在内存中构建代理对象（需要我们指定要代理的目标对象实现的接口类型），利用JDK的API生成指定接口的对象，也称为JDK代理或者接口代理。 ​ 下面是原理图片： ​ 因为上面创建过类了，所以现在只需要创建动态代理类即可 1234567891011121314151617181920212223242526272829303132333435package com.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 动态代理类 */public class ClientAutoProxy &#123; //被代理的对象 private Object targetObject; public ClientAutoProxy(Object targetObject) &#123; this.targetObject = targetObject; &#125; public Object getProxyInstance() &#123; return Proxy.newProxyInstance( //代理对象的类加载器 targetObject.getClass().getClassLoader(), //目标对象实现的接口，因为需要根据接口动态生成对象 targetObject.getClass().getInterfaces(), //InvocationHandler:事件处理器，即对目标对象方法的执行进行处理 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("方法增强前"); Object resultValue = method.invoke(targetObject, args); System.out.println("方法增强后"); return resultValue; &#125; &#125;); &#125;&#125; 测试类 123456789101112131415package com.test;import com.proxy.ClientAutoProxy;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientDao clientDao = new ClientDaoImpl(); ClientAutoProxy clientAutoProxy = new ClientAutoProxy(clientDao); ClientDao clientDaoProxy = (ClientDao)clientAutoProxy.getProxyInstance(); clientDaoProxy.content(); &#125;&#125; 结果与之前一样 需要注意的地方： 1Object resultValue = method.invoke(targetObject, args); ​ 这条语句在执行的时候，一开始我把targetObject对象写成了proxy对象，导致程序进入了死循环，经百度之后，了解到，因为proxy对象表示当前代理对象，这么调用之后又会调用到SimpleInvocationHandler的invoke方法，这个就要涉及到底层原理知识了，现阶段不过多讨论。 ​ 还有就是，在测试类中，因为返回类型为Object类型的对象，所以需要强转为所需要的类型。 优点 ​ 代理对象不需要实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需要在事件处理器中添加对方法的判断即可。 缺点 ​ 代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。]]></content>
      <categories>
        <category>JAVA代理</category>
      </categories>
      <tags>
        <tag>JAVA代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（一）]]></title>
    <url>%2F2019%2F09%2F18%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（一）Maven概述maven特性 纯java编写： 具有跨平台特性，只需要一套程序就行 开源： 可以对源码修改 互联网思维： 分享，共享 树立自己的IP，让自己流量变大，然后使自己变得有价值 跨平台： 跨两个平台： 跨OS平台（操作系统），跨IDE平台 IDE（Integrated Development Enviroment）：用于提供程序开发环境的应用程序 不同的IDE工具创建的项目结构不同，不能互相导入项目 maven把项目结构标准化，在哪开发都能导入项目 标准化的： 项目构建标准化： 跨操作系统平台（跨OS平台） 项目结构标准化： 跨IDE平台 Maven项目本身是和IDE没有任何关系的 基于项目对象模型（POM）： pom文件可以继承，具有继承性 一般导入依赖是通过 groupId，artifactId，version，简称gav坐标 maven核心都是由插件完成的，导入坐标可以自动下载插 项目构建： maven的管理模块来生成一些必要的组件，节省人工 依赖管理，对jar包进行管理，只需要导入坐标就行 报告生成： Maven 可以生成站点报告, 可以较为方便的实现对项目的管理。 Maven工作原理 maven寻找依赖过程 本地仓库 -&gt; maven私服（阿里云或者公司内部） -&gt; maven中心仓库 依次，到各级库的范围越来越广 Maven的安装与配置官网下载maven https://maven.apache.org/download.cgi 解压到某个文件夹 例如F盘 设置环境变量 在系统变量中创建 MAVEN_HOME ，内容填Maven的目录 例如 F:\apache-maven-3.6.2-bin\apache-maven-3.6.2 然后在path中添加MAVEN_HOME的bin目录 %MAVEN_HOME%\bin; 然后在cmd中测试一下，输入 mvn -v查看版本 如果有的话就没问题了 Maven换源（这个是最重要的）setting.xml文件 这个文件在maven文件夹下的conf文件夹中，找到后用编辑器打开 需要设置两个地方： 首先是本地仓库： 找到localRepository这个标签所在位置，一般来说都是注释状态，我们把注释去掉，然后把标签内内容改成maven文件夹的绝对路径就行 接下来最重要了，更换镜像： ​ 找到mirrors标签，然后把阿里云镜像添加进去即可： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 课外内容： 英语口语发音要注意，发音正确不一定学习好，但发音错误说明一定不是好学校 tar.gz文件夹： 高度压缩过的文件夹 zip： 普遍压缩 bin文件夹： 编译过的文件，二进制文件 src： 源码，未经过编译的]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二）]]></title>
    <url>%2F2019%2F09%2F17%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记视频篇（二）紧接着上面的入门案例，这次使用注解的方式 准备​ 首先新建一个maven项目，然后将java和resources文件夹复制过来，然后test文件夹也复制过来，还有pom.xml依赖也复制过来。 ​ 紧接着将resources文件夹下的com文件夹删除 修改​ 我们首先把sqlMapConfig.xml内容修改一下 123456&lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果使用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt; &lt;mapper class="com.dao.UserDao"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 只需要把最下面的mapper换成类名即可 ​ 然后是类中添加注解 12345678910111213141516171819package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ @Select("select * from user") List&lt;User&gt; findAll();&#125; ​ 在方法名上面添加注解标签Select，代表查询语句，参数则是具体查询语句，进行测试，发现结果与xml方式时的运行结果一致。 明确： ​ 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式，不管是使用XML还是注解配置，但是MyBatis它是支持写实现类的。 ​ 因此我们下来就手写一次实现类，来试一试。 开始手写实现类还是基于第一次的xml来实现的 创建一个dao的实现类 1234567891011121314151617181920212223242526package com.dao.impl;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; //使用工厂创建session对象 SqlSession session = factory.openSession(); //使用session进行查询 List&lt;User&gt; users = session.selectList("com.dao.UserDao.findAll"); session.close(); return users; &#125;&#125; UserDao的mapper不做修改 修改测试类内容 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import com.dao.UserDao;import com.dao.impl.UserDaoImpl;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream("sqlMapConfig.xml"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂创建dao对象 UserDao userdao = new UserDaoImpl(factory); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 in.close(); &#125;&#125; 因为session转移到实现类中，所以此处只需要new一个实现类就行 实际开发中并不使用这种方式，写这个是为了告诉我们，在mapper.xml中，只靠id是无法定位到具体的方法中的，还需要我们加上namespace才能找到执行语句。 mybatis入门案例模式中的设计模式分析]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一）]]></title>
    <url>%2F2019%2F09%2F17%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBits学习笔记视频篇（一）框架1. 什么是框架 ​ 他是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题，例如，MyBits解决的是持久层的问题，Spring和Spring MVC 解决的是表现层的问题。 2. 使用框架的好处 ​ 框架风阻航了很多细节，是开发者可以使用极简的方式实现功能，大大提高开发效率。 三层架构​ 表现层：用于展示数据的 ​ 业务层：处理业务需求 ​ 持久层：和数据库交互的 持久层技术解决方案1. JDBC技术 ​ Connection ​ PreparedStatement ​ ResultSet 2. Spring的JdbcTemplate： ​ Spring中对jdbc的简单封装 3. Apache的DBUtils ​ 它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装 4. 以上这些都不是框架 ​ JDBC是规范 ​ Spring的JdbcTemplate和Apache的DBUtils都只是工具类 MyBatis框架概述​ mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，是开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等复杂的过程。 ​ 它使用了ORM思想，实现了结果集的封装，Object Relational Mapping 对象关系映射，简单地说，就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。 ​ 实体类中的属性和数据库表的字段名名称保持一致。 MyBatis的入门mybatis的环境搭建 ​ 首先创建一个maven项目 ​ 在pom.xml中导入相关的包 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;my_pratices_mybits_day_1&lt;/groupId&gt; &lt;artifactId&gt;my_pratices_mybits_day_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 创建接口 1234567891011121314151617package com.dao;import com.pojo.User;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ List&lt;User&gt; findAll();&#125; 创建Mybatis-config.xml整体配置文件 因为我这里没有，所以创建了一个模板 创建模板过程就是： 打开idea设置中的File and Code Templates中的Files 然后点击“+”号，Name输入MyBatis-config.xml，Extendsion填写 xml 然后下面模板中添加如下代码 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 整个模板就配置完毕了，然后创建就行 在MyBatis-config.xml配置文件中写入以下代码 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意上面一定要把environments的default和environment的id都写上去 创建映射配置文件UserDao.xml 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;!--配置查询所有--&gt; &lt;select id="findAll" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 这个地方会报错，原因是没有写resultType参数，结果集不知道封装到哪里去。 而且那个sql语句末尾不能加“；”符号 环境搭建注意的事项： ​ 第一个是： 创建UserDao.xml和UserDao.java时名称是为了和我们之前的知识保持一致。在MyBatis中它把持久层的操作接口名称和映射文件，也叫做Mapper，所以UserDao和UserMapper是一样的。​ 第二个是： 在idea中创建目录时，他和包是不一样的，包在创建时，com.dao他是二级结构，而创建目录的时候，com.dao他是一级结构，所以必须要一层一层创建​ 第三个是：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个是：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 ​ 第五个是：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 ​ 当我们遵从了第三，四，五点之后，我们在开发中就无须再写doa的实现类了。 创建log4j.properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344# priority :debug&lt;info&lt;warn&lt;error#you cannot specify every priority with different file for log4j log4j.rootLogger=debug,stdout,info,debug,warn,error #consolelog4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern= [%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n#info loglog4j.logger.info=infolog4j.appender.info=org.apache.log4j.DailyRollingFileAppender log4j.appender.info.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.info.File=./src/com/hp/log/info.loglog4j.appender.info.Append=truelog4j.appender.info.Threshold=INFOlog4j.appender.info.layout=org.apache.log4j.PatternLayout log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#debug loglog4j.logger.debug=debuglog4j.appender.debug=org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.debug.File=./src/com/hp/log/debug.loglog4j.appender.debug.Append=truelog4j.appender.debug.Threshold=DEBUGlog4j.appender.debug.layout=org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#warn loglog4j.logger.warn=warnlog4j.appender.warn=org.apache.log4j.DailyRollingFileAppender log4j.appender.warn.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.warn.File=./src/com/hp/log/warn.loglog4j.appender.warn.Append=truelog4j.appender.warn.Threshold=WARNlog4j.appender.warn.layout=org.apache.log4j.PatternLayout log4j.appender.warn.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#errorlog4j.logger.error=errorlog4j.appender.error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.error.File = ./src/com/hp/log/error.log log4j.appender.error.Append = truelog4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n 创建测试类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream("MyBatis-config.xml"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 UserDao userdao = session.getMapper(UserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 结果展示 mybatis的入门案例 ​ 第一步： 读取配置文件 ​ 第二步： 创建SqlSessionFactory工厂 ​ 第三步：创建SqlSession ​ 第四步：创建Dao接口的代理对象 ​ 第五步：执行dao中的方法 ​ 第六步：释放资源 ​ 注意事项： ​ 不要忘记在映射配置中告知mybits要封装到哪个实体类中 ​ 配置的方式：指定实体类的全限定类名]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit的基本注解]]></title>
    <url>%2F2019%2F09%2F17%2FJunit%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Junit的基本注解注解类型 注解名称 注解作用 @Before 表示在任意使用@Test注解标注的public static void 方法执行之前执行 @After 表示在任意使用@Test注解标注的public static void 方法执行之后执行 @Test 使用该注解标注的public void 方法会表示为一个测试方法，可以直接执行 @BeforeClass 表示在类中的任意public static void 方法执行之前执行 @AfterClass 表示在类中的任意public static void 方法执行之后执行 下面是测试样例： 1234567891011121314151617181920212223242526package com.test;import org.junit.*;public class BasicAnnotationTest &#123; @BeforeClass public static void beforeClass() &#123; System.out.println("这是beforeClass前置通知"); &#125; @AfterClass public static void afterClass() &#123; System.out.println("这是afterClass后置通知"); &#125; @Before public void before() &#123; System.out.println("这是before前置通知"); &#125; @After public void after() &#123; System.out.println("这是after后置通知"); &#125; @Test public void test1() &#123; System.out.println("这是test1"); &#125;&#125; 结果：]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub学习笔记]]></title>
    <url>%2F2019%2F09%2F16%2FGitHub%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[GitHub学习笔记基本概念仓库（Repository）仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目存在多个仓库。 收藏（Star）收藏项目，方便查看 复制克隆项目（Fork）点击之后，会别人的仓库完整的复制一份给你，该fork仓库之独立存在的，而且上面会有从哪个地方克隆的。 发起合并请求（Push Request）这个是基于Fork的，如果想要克隆来源的地方也更新同样的代码，然后可以点击之后，会发起合并请求，查看同意之后就可以合并了。 关注（Watch）关注项目之后，项目更新可以接受到通知 事物卡片（Issue）发现代码有BUG，但是目前没有成型代码，需要讨论时用 Github主页账号登录成功之后，点击左上角就回到github主页，显示自己的动态和关注的动态，右边显示git库 仓库主页显示项目信息，如：项目代码，版本，收藏/关注/fork情况等 创建仓库 仓库主页 仓库管理点击create new file新建文件 写好之后，填写提交的目的，原因：为了方便其他开发者知道本次添加或修改的原因 创建完毕跳转到主页 点击目的之后可以看到文件的详细描述，还有文件的修改内容 编辑文件 点击之后回来到编辑模式之下 删除文件同上面一样 上传文件 可以拖动文件也可以点击上传多个文件 下面是写上传文件的信息 搜索文件 输入文件名进行筛选 也可以按快捷键T就可以进行查找文件 下载文件]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用的网站]]></title>
    <url>%2F2019%2F09%2F16%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一些常用的网站链接Spring官方文档（涵盖各个版本的）https://docs.spring.io/spring/docs/ Maven仓库https://mvnrepository.com/ Json格式化网站https://www.json.cn/ 不错的java学习网站http://how2j.cn/stage/39.html CMD Markdown网站https://www.zybuluo.com/mdeditor （可以在线记录markdown文档，缺点是有些功能收费） Leetcodehttps://leetcode-cn.com/ 站长工具http://tool.chinaz.com/ 谷歌网上应用商店https://chrome.google.com/webstore/category/extensions?h1=zh 慕课网https://www.imooc.com/ 牛客https://www.nowcoder.com/ 代码托管平台Githubhttps://github.com/ 待更新。。。。。。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置文件整理]]></title>
    <url>%2F2019%2F09%2F16%2FMyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MyBatis配置文件整理log4j.properties123456789101112131415161718192021222324 ### 设置###log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n ### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n mybatis模板123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--属性--&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!--设置--&gt; &lt;settings&gt; &lt;setting name="" value=""/&gt; &lt;/settings&gt; &lt;!--别名--&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!--类型处理器--&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!--对象工厂--&gt; &lt;objectFactory type=""&gt;&lt;/objectFactory&gt; &lt;!--插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=""&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;!--配置环境--&gt; &lt;environments default=""&gt; &lt;!--环境变量--&gt; &lt;environment id=""&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type=""&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=""&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--数据库厂商标识--&gt; &lt;databaseIdProvider type=""&gt;&lt;/databaseIdProvider&gt; &lt;!--映射器,告诉mybatis去哪里找映射文件--&gt; &lt;mappers&gt; &lt;mapper&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper模板12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 在MyBatis中，Mapper中的namespace用于绑定Dao接口的，即面向接口编程。 它的好处在于当使用了namespace之后就可以不用写接口实现类， 业务逻辑会直接通过这个绑定寻找到相对应的SQL语句进行对应的数据处理--&gt;&lt;mapper namespace=""&gt; &lt;!--查询--&gt; &lt;select id=""&gt;&lt;/select&gt; &lt;!--增加--&gt; &lt;insert id=""&gt;&lt;/insert&gt; &lt;!--删除--&gt; &lt;delete id=""&gt;&lt;/delete&gt; &lt;!--修改--&gt; &lt;update id=""&gt;&lt;/update&gt; &lt;!--提供缓存支持--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!--参照缓存,用来引用另一个缓存--&gt; &lt;cache-ref namespace=""/&gt; &lt;!-- ParameterMap和ResultMap类似，设置入参字段映射，很少使用（不建议使用）--&gt; &lt;parameterMap id="" type=""&gt;&lt;/parameterMap&gt; &lt;!--查询结果集，映射java对象--&gt; &lt;resultMap id="" type=""&gt;&lt;/resultMap&gt;&lt;/mapper&gt; Spring整合模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSouce" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;!--加载数据库驱动--&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8"&gt;&lt;/property&gt; &lt;!--账户--&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;!--密码--&gt; &lt;property name="password" value="wang123"&gt;&lt;/property&gt; &lt;!--最大连接数--&gt; &lt;property name="maxTotal" value="30"&gt;&lt;/property&gt; &lt;!--最大空闲数--&gt; &lt;property name="maxIdle" value="10"&gt;&lt;/property&gt; &lt;!--初始化连接数--&gt; &lt;property name="initialSize" value="5"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--添加事务支持--&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager="txManager" /&gt; &lt;!--配置MyBatis工厂,同时指定数据源，并于MyBatis完美整合--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--指定数据源--&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;!--configLocation的属性值为MyBatis的核心配置文件--&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配 (Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口) --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!--mybatis-spring组件的扫描器--&gt; &lt;property name="basePackage" value=""&gt;&lt;/property&gt; &lt;!--注入工厂--&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring5约束头1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;/beans&gt; 整合Spring和MyBatis所使用的pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.my_priatices.aop&lt;/groupId&gt; &lt;artifactId&gt;my_priatices.aop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 待更新。。。。。。]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（三）]]></title>
    <url>%2F2019%2F09%2F12%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（三）基于XML装配Spring提供了两种基于XML的装配方式，分别是setter注入和构造方法注入 首先创建Bean的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;/** * 复杂数据的注入 */public class ComplexUser &#123; private String name; private List&lt;String&gt; hobbyList; private Map&lt;String,String&gt; residenceMap; private Set&lt;String&gt; aliasSet; private String[] array; public ComplexUser(String name, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array) &#123; this.name = name; this.hobbyList = hobbyList; this.residenceMap = residenceMap; this.aliasSet = aliasSet; this.array = array; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getHobbyList() &#123; return hobbyList; &#125; public void setHobbyList(List&lt;String&gt; hobbyList) &#123; this.hobbyList = hobbyList; &#125; public Map&lt;String, String&gt; getResidenceMap() &#123; return residenceMap; &#125; public void setResidenceMap(Map&lt;String, String&gt; residenceMap) &#123; this.residenceMap = residenceMap; &#125; public Set&lt;String&gt; getAliasSet() &#123; return aliasSet; &#125; public void setAliasSet(Set&lt;String&gt; aliasSet) &#123; this.aliasSet = aliasSet; &#125; public String[] getArray() &#123; return array; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; @Override public String toString() &#123; return "ComplexUser&#123;" + "name='" + name + '\'' + ", hobbyList=" + hobbyList + ", residenceMap=" + residenceMap + ", aliasSet=" + aliasSet + ", array=" + Arrays.toString(array) + '&#125;'; &#125;&#125; 配置Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="u1" class="com.bean.ComplexUser"&gt; &lt;!--构造方法注入--&gt; &lt;constructor-arg index="0" value="myname"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;码代码&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;map&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;entry key="beijing" value="北京"&gt;&lt;/entry&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;set&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang1&lt;/value&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang2&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="u2" class="com.bean.ComplexUser"&gt; &lt;property name="name" value="shuai"&gt;&lt;/property&gt; &lt;property name="hobbyList"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;搬砖&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="residenceMap"&gt; &lt;map&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="aliasSet"&gt; &lt;set&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s2&lt;/value&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="array"&gt; &lt;array&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;你太美&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类 123456789101112131415161718package com.test;import com.bean.ComplexUser;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); ComplexUser u1 = (ComplexUser)applicationContext.getBean("u1"); System.out.println(u1.toString()); ComplexUser u2 = (ComplexUser)applicationContext.getBean("u2"); System.out.println(u2.toString()); &#125;&#125; 结果 基于注解的装配因为要用到注解，所以我们来看看都有哪些基础的注解： 名称 作用 Component 代表一个组件对象，就是把普通的pojo实例到Spring容器中 Repository 此注解用于数据访问层（DAO），功能与Component相同 Service 此注解用于业务逻辑组件层（Service层），功能与Component相同 Controller 此注解用于标注一个控制器组件类（SpringMVC的Controller），功能与Component相同 AutoWired 此诸结可以对类成员变量，方法及构造方法进行标注，完成自动装配的工作。通过使用Autowired来消除setter和getter方法。默认按照Bean的类型进行装配，如果想按照名称来注入，就必须要和Qualifier搭配使用。 Resource 此注解与AutoWired相同，区别在于这个注解是按照名称来装配注入的，只有当找不到与名称匹配的名称时，才按照Bean的类型进行装配。 Qualifier 此注解要和AutoWired配合使用，Bean的实例名称有此注解的参数指定。 首先创建一个DAO层，和他的实现类，然后标上注解： TestDao 12345678910111213package com.dao;import org.springframework.stereotype.Repository;/** * 创建dao接口 */public interface TestDao &#123; /** * 保存 */ void save();&#125; TestDaoImpl 12345678910111213package com.dao.impl;import com.dao.TestDao;import org.springframework.stereotype.Repository;@Repository("testDao")public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println("TestDao save"); &#125;&#125; TestService 1234567891011package com.servlet;import org.springframework.stereotype.Service;/** * 业务层接口 */public interface TestService &#123; void save();&#125; TestServiceImpl 1234567891011121314151617181920212223package com.servlet.impl;import com.dao.TestDao;import com.servlet.TestService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * 业务层实现类 */@Service("testService")public class TestServiceImpl implements TestService &#123; @Resource(name="testDao") private TestDao testDao; @Override public void save() &#123; testDao.save(); System.out.println("TestService save"); &#125;&#125; TestController 12345678910111213141516171819package com.controller;import com.servlet.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controllerpublic class TestController &#123; @Autowired private TestService testService; public void save()&#123; testService.save(); System.out.println("TestController save"); &#125;&#125; 测试类 12345678910111213package com.test;import com.controller.TestController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); TestController testController = (TestController)applicationContext.getBean("testController"); testController.save(); &#125;&#125; 结果 课后题Bean的实例化有哪几种常见的方法？ ​ 答： 三种，构造方法，静态工厂，实例工厂 简述基于注解装配方式的基本用法？ ​ 答： 见上面的表格。 @AutoWired和@Resource有什么区别？ ​ 答：一个是按类别，一个是按名称 Bean的默认作用域是什么？ ​ 答：singleton 单例模式 使用类似于@Controller一样的注解的时候，Bean的id是什么？ ​ 答： 默认是首字母小写的类名]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F09%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[基础部分 javaSE MySQL，刚开始只需要了解一些基础的sql语句，例如增删改查，复杂一点的后面可以在学。 idea可以直接连接数据库 database，一开始可以多用用，熟悉熟悉 javaWeb：jsp（了解即可），（Servlet ，Filter，Listener），重点放在Listener 现在大多数都是异步机制和回调机制，Listener监听用的多，Filter用的少 （重点部分）SSM：Spring + MyBatis+Spring MVC Spring MVC：是Spring中的一部分 Spring：本身是一个容器 响应式编程 WebFlux，在开发中用的也不是很多，主要解决的是高并发问题，建议了解一下 Lambda表达式，基于接口实现的，建议学习 项目管理工具 Maven，得了解原理。 项目管理工具Git，也是分布式版本管理工具，然后项目要放到github上面 （重点部分）Spring Boot （快速开发框架），使用这个原因是因为SSM配置文件非常多，基本上都是样板式代码，因此必须把可重用性代码封装起来，所以这个Spring Boot必须得好好学习，重点！ 分布式开发技术（进阶部分） linux基础，因为服务器现在基本上都是搭建在无可视化界面的linux上面的 本地服务器搭建的工具（VMware（搭建虚拟机）+secureCRT（客户端）+CentOS 7 Mini版本（只有操作界面） 分布式协调服务器Zookeeper 反向代理服务器 Nginx 真正请求的服务器在后面，这个是代理集群，集群里面部署的应用都是一样的，一般都会选一个master作为主要的 正解：正向解析，把域名解析成ip地址 反解：反向代理，把ip地址解析成域名 正代：由内向外作代理 反代：由外向内做代理 分布式内存数据库Redis（NoSql非关系型数据库） 分布式消息队列Kafka，RocketMQ，RabbitMQ（ActiveMQ不用管它） 应用方面：削减峰值，并发量高的时候需要使用 分布式RPC框架Dubbo（阿里的框架）和微服务框架Spring Cloud 微服务：把服务分散开，每一个都是独立的工程，用哪个调哪个 高内聚，低耦合，便于复用 Spring Boot 一定要好好学习！！！]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>前进方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（二）]]></title>
    <url>%2F2019%2F09%2F04%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBeanBean的配置​ Spring用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持Xml和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 ​ &lt;bean&gt;元素的常用属性及其子元素 描述 属性或子元素名称 id Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称 class Bean的具体实现类，使用类的名（例如dao.TestDIDaoImpl） scope 指定Bean实例的作用域 &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值 &lt;property&gt; &lt;bean&gt;元素的子元素用于设置一个属性，该元素的name属性指定Bean实例中相应的属性名称，value属性指定Bean的属性值，ref属性指定属性对BeanFactory中其他Bean的引用关系 &lt;list&gt; &lt;property&gt;元素的子元素，用于封装List或数组类型的依赖注入 &lt;map&gt; &lt;property&gt;元素的子元素，用于封装Map类型的依赖注入 &lt;set&gt; &lt;property&gt;元素的子元素，用于封装Set类型的依赖注入 &lt;entry&gt; &lt;map&gt;元素的子元素，用于设置一个键值对 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，也需要实例化Bean，Spring框架实例化Bean有三种方式 即，构造方法实例化、静态工厂实例化和实例工厂实例化（最常用就是构造方法实例化）。 1. 构造方法实例化 spring-config.xml配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213package com.test;import com.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); AccountService accountService = (AccountService)applicationContext.getBean("accountService"); accountService.addAccountMoney("张三",1000f); &#125;&#125; 2. 静态工厂实例化对象（开发中不使用，再次不列举使用方法）3. 实例工厂实例化对象（这个也不列举）Bean的作用域 作用域名称 描述 singleton 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例 prototype Spring容器每次获取protopyte定义的Bean，容器都将创建一个新的Bean实例 request 在一次Http请求中容器将返回一个Bean实例，不同的Http请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用 session 在一个HTTP Session 中，容器将返回同一个Bean实例。尽在Web Spring应用程序上下文中使用 application 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例，尽在Web Spring应用程序上下文中使用 websocket 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用 1. singleton作用域​ 由于singleton是bean的scope默认设置，所以写好bean之后就可以进行测试 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.test.AccountServiceImpl" scope="singleton"&gt;&lt;/bean&gt;&lt;/beans&gt; 代码如下 123456789101112131415package com.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); //第一个对象 AccountServiceImpl a1 = (AccountServiceImpl)applicationContext.getBean("accountService"); //第二个对象 AccountServiceImpl a2 = (AccountServiceImpl)applicationContext.getBean("accountService"); System.out.println(a1 == a2); &#125;&#125; 结果展示： 2. prototype作用域代码如上所述，然后只设置scope作用域即可 结果展示: Bean的生命周期​ 一个对象的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段，在Spring中，Bean对象周期也遵循这一过程，但是Spring提供了许多对外接口，允许开发者对3个过程（实例化、初始化、销毁）的前后做一些操作。在Spring Bean中，实例化是为Bean对象开辟空间，初始化则是对属性的初始化。 ​ Bean生命周期整个过程如下： ​ （1）根据Bean的配置情况实例化一个Bean。 ​ （2）根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。 ​ （3）如果Bean实现了BeanNameAware 接口，将调用它实现的，setBeanName（String beanId）方法， 此处参数传递的是Spring配置文件中Bean的id。 ​ （4）如果Bean实现BeanFactoryAware接口，将调用它实现的setBeanFactory方法，此处参数传递的是当前Spring工厂实例的引用。 ​ （5）如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext（ApplicationContext）方法，此处参数传递的是Spring上下文实例的引用。 ​ （6）如果Bean关联了BeanPostProcessor接口，将调用初始化方法postProcessBeforeInitialization（Object obj， String s）对Bean进行操作。 ​ （7）如果Bean实现了InitializingBean接口， 将调用afterPropertiesSet方法。 ​ （8）如果Bean在Spring配置文件中配置了 init-method 属性，将自动调用其配置的初始化方法。 ​ （9）如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization（Object obj，String s）方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。 ​ （10）当Bean不再需要时将进入销毁阶段，如果Bean实现了DisposableBean接口，则调用其实现的destroy方法将Spring中的Bean销毁。 ​ （11）如果在配置文件中通过destory-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。 ​ 在Spring中，通过特定的接口或通过&lt;bean&gt;元素的属性设置可以对Bean的生命周期过程产生影响。 ​ 例子： ​ 创建Bean的实现类 12345678910111213package com.test;/** * @author wys */public class BeanLife &#123; public void initMyself()&#123; System.out.println(this.getClass().getName()+"执行了自定义的初始化方法"); &#125; public void destroyMyself() &#123; System.out.println(this.getClass().getName()+"执行了自定义的销毁方法"); &#125;&#125; ​ 配置Bean 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="beanLife" class="com.test.BeanLife" init-method="initMyself" destroy-method="destroyMyself"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 测试生命周期 12345678910111213141516package com.test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("spring-config.xml"); System.out.println("获得对象前"); BeanLife beanLife = (BeanLife)ctx.getBean("beanLife"); System.out.println("获得对象后"+beanLife); ctx.close(); &#125;&#125; 结果如下:]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next界面美化]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E7%9A%84next%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[设置中文首先查看一下next/theme/language中的语言类型，一般就是zh-CN或者是zh-Hans`这个类型 然后在hexo的配置文件_config.yml把写上去就行 主题风格将next中的_config.yml配置文件修改一下 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 这个把前面的#去掉换另一种就行，我觉得第三种就挺好看的。个人喜好 设置分类还是在next中的_config.yml配置文件修改 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把对应菜单的选项注释去掉就好 然后创建目录,不同标签对应不同的代码 1$ hexo new page categories 创建完毕之后，进去修改一下 类似于categories这种的 123456---title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: "categories"--- 添加头像搜索next中的_config.yml配置文件 搜索Sidebar Avatar这个关键字，去掉avatar前面的# 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.gif 然后把头像放到指定的文件夹 设置侧边栏的的社交链接打开themes/next/_config.yml文件，搜索关键字social，然后添加社交站点名称与地址即可。 1234567891011social: GitHub: https://github.com/wyscoder|| github E-Mail: mailto:714133840@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 修改底部的声明和版权主题配置文件下，搜索关键字post_copyright，enable改为true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 去掉强力驱动 找到hexo根目录&gt;&gt;themes&gt;&gt;next&gt;&gt;layout&gt;&gt;_partials下的footer.swig文件 然后打开删除 123456789101112131415161718&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 这部分内容就好 最后修改一下hexo中的配置文件名字就行 添加搜索功能首先安装一下搜索插件 $ npm install hexo-generator-searchdb --save 打开Hexo站点的_config.yml，添加配置 : 12345search: path: search.xml field: post format: html limit: 10000 打开themes/next/_config.yml，搜索关键字local_search，设置为true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 本地站点推送到GitHub上安装插件 1$ npm install hexo-deployer-git --save 在Hexo站点的_config.yml中配置deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo g -d 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=110 src=&quot;//music.163.com/outchain/player?type=0&amp;id=408443429&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 就好了 添加背景动画效果 修改_layout.swig 打开 next/layout/_layout.swig 在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话 可以这么设置====&gt; 在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加代码复制功能首先找到这个目录themes/next/layout/_third-party/ 然后在此文件夹下创建名为copy-code.swig的文件，在此文件中输入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125;&lt;/style&gt;&lt;script&gt; $('.highlight').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap') $(e).after($wrap) $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text() &#125;).toArray().join('\n') var ta = document.createElement('textarea') document.body.appendChild(ta) ta.style.position = 'absolute' ta.style.top = '0px' ta.style.left = '0px' ta.value = code ta.select() ta.focus() var result = document.execCommand('copy') document.body.removeChild(ta) if(result)$(this).text('复制成功') else $(this).text('复制失败') $(this).blur() &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn') setTimeout(function () &#123; $b.text('复制') &#125;, 300) &#125;).append(e) &#125;)&lt;/script&gt; 然后返回上一层目录，即layout文件夹下，编辑_layout.swig， 在最底部，&lt;/body&gt;上面添加 1&#123;% include &apos;_third-party/copy-code.swig&apos; %&#125; 这句话接着就能用了]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO搭建博客（搭建在github上面）]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言学长给的几个教程链接 https://blog.csdn.net/u013332124/article/details/80680156 https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html#validate-next-theme https://blog.csdn.net/llmmll08/article/details/70246150 1.什么是hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.安装1.前提​ 必须有Node.js 和 Git, 还有Github账号，都具备之后就开始了 2.创建github pages页面 首先创建仓库（repository ），然后仓库名字必须得是 yourname.github.io 这个，比如我的github名称是wyscoder，所以仓库名称就是 wyscoder.github.io 然后记住这个仓库的git地址 https://github.com/wyscoder/wyscoder.github.io 3.安装hexo 这个是需要node.js和git作为前置的，如果没有就去下载node.js和git 接下来就只需要npm就可以完成安装了 使用这个命令进行安装hexo$ npm install -g hexo-cli 等待下载完毕就行 4. 建站 安装hexo完成之后，执行下面命令就会在指定文件夹创建需要的文件 1234node.js$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 具体参数信息请查看官方文档 https://hexo.io/zh-cn/docs/configuration package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-stylus": "^0.3.3", "hexo-renderer-marked": "^0.3.2", "hexo-server": "^0.3.3" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 5.上传站点生成后,就可以开始写文章了。dos界面下,进入所在站点目录，输入hexo new [layout] &lt;title&gt;命令。hexo会自动帮你生成一个 &lt;title&gt;.md 的文件。然后你就可以在这个文件上编写你的博客内容了。 写完博客后,我们先试着在本地部署一下服务。还是在dos命令下，进入站点目录。一次输入: 123hexo clean # 清除缓存,之后会经常用到hexo g # 生成站点静态文件hexo s # 部署服务 上面是本地部署，之后就可以通过localhost:4000来访问博客了 但是如果想让别人访问你的还需要提交到git上面 打开cmd 然后输入npm install hexo-deployer-git --save安装git工具 开站点目录下面的配置文件_config.yml(用任意编辑器),配置deploy参数。一开始配置文件是这样的: 12deploy: type: 我们把它改成我们的git仓库地址。 1234deploy: type: git repository: ssh://git@github.com/wyscoder/wyscoder.github.io branch: master 修改好之后执行 123hexo clean hexo g hexo d # 部署到远程仓库 令全部执行完后。我们就可以访问我们的博客网站了。https://wyscoder.github.io 6.问题在使用hexo d提交的时候出现了几个问题 首先是你得使用git命令来设置用户和邮箱 config --global user.name "nameVal" ```12```git config --global user.email &quot;eamil@qq.com&quot; 其中我还测试了一下那个git的基本命令，都是卡在提交那一点，原因是没有密匙 如果电脑上没有ssh密匙我建议还是要安装一下 7.美化博客：使用nexT主题博客是搭建好了, 但是我们发现hexo的默认主题风格比较丑。好在hexo的主题是可定制的。所以我们可以更换别人已经做好的主题。nexT就是其中一个比较强大的主题。下面简单的教大家怎么切换到这个主题。​ 先去nexT的github页面下载nexT项目。https://github.com/iissnan/hexo-theme-next。然后放到站点目录下面的一个themes文件夹中。解压。 解压后会得到一个hexo-theme-next-master文件夹。重命名成next。 修改站点配置文件_config.yml里面的theme参数,修改值为next。 ​ 重新清除缓存,生成新的资源文件，然后部署,主题就切换成next了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（一）]]></title>
    <url>%2F2019%2F08%2F10%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring简介1. Spring由来 目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题 2. Spring体系结构 核心容器（Core Container） 数据访问/ 集成（Data Access/Integration）层 Web层 AOP（Aspect Oriented Programming，面向切面的编程）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test） Spring体系结构 SpringIOC1. Spring IOC基本概念控制反转是一个比较抽象的概念，是Spring框架的核心，用来削减计算机程序的耦合问题。 依赖注入是IOC的另外一种说法。 解释 &nbsp;&nbsp;当某个java对象需要调用另一个对象时，在传统编程模式下，调用者通常会采用 “new 被调用者” 的方式来创建对象，这种方式会增加调用者和被调用者之间的耦合性，不利于后期代码的维护。 &nbsp;&nbsp;当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 &nbsp;&nbsp;从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入他所依赖的实例，这就是Spring依赖注入。 &nbsp;&nbsp;综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方产生或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入。 2. SpringIOC容器SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口。 BeanFactory(1). 概念&nbsp;&nbsp;BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，它提供了完整的Ioc服务支持，是一个管理BeanFactory的工厂，主要负责初始化各种Bean。BeanFactory接口有许多实现类，比较常用的就是org.springframework.beans.factory.xml.XmlBeanFactory.这个类会根据XML来装配Bean，创建时候需要提供XML文件的绝对路径。 123456public static void main(String[] args)&#123; //初始化Spring容器，加载配置文件 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("绝对路径")); TestDao testDao = (TestDao)beanFactory.getBean("testDao"); testDao.sayHello();&#125; 这种写法开发中一般不常见，了解即可。 ApplicationContext&nbsp;&nbsp;ApplicationContext是BeanFactory的子接口，也称为应用上下文，org.springwork.context.ApplicationContext接口定义，ApplicationContext接口除了包含BeanFactory的所有功能外，还添加了国际化，资源访问，事件传播等内容的支持。 &nbsp;&nbsp;创建ApplicationContext接口实例通常有以下三种方式: (1). *通过ClassPathXmlApplicationContext创建 *：&nbsp;&nbsp;ClassPathXmlApplicationContext将类路径目录（src根目录）中寻找指定的XML配置文件，代码如下： 1234567public static void main(String[] args)&#123; //初始化Spring容器ApplicationContext,加载配置文件 ApplicationContext ac = ClassPathXmlApplicationContext("spring-config.xml"); //通过容器获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; (2). 通过FileSystemXmlApplicationContext创建：&nbsp;&nbsp;FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public stsatic void main(String[] args)&#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext ac = new FileSystemXmlApplication("C:\Users\hp\IdeaProjects\my_pratices_account_day_01\src\main\resources\spring-config.xml"); //获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。 (3). 通过Web服务器实例化ApplicationContext容器&nbsp;&nbsp;在Web服务器实例化ApplicationContext容器时，一般使用org.springframework.web.context.ContextLoaderListener的实现方式（需要导入spring-web.5.0.2.RELEASE.jar包），此方法只需在web.xml中添加如下代码： 1234567891011&lt;context-param&gt; &lt;!--加载src目录下的spring-config.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3. 依赖注入的类型构造方法注入&nbsp;&nbsp;Spring框架可以采用java的反射机制，通过构造方法完成依赖注入 首先创建持久层接口 1234567891011package com.test.dao;/** * 创建持久层 */public interface TestDao &#123; /** * Hello方法 */ void sayHello();&#125; 然后创建持久层实现类 1234567891011package com.test.dao.impl;import com.test.dao.TestDao;public class TestDaoImpl implements TestDao &#123; @Override public void sayHello()&#123; System.out.println("Hello World"); &#125;&#125; 创建业务层接口 12345678package com.test.service;/** * 业务层 */public interface TestService &#123; void sayHello();&#125; 创建业务层实现类 12345678910111213141516171819package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public TestServiceImpl(TestDao testDao)&#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 配置spring-config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;constructor-arg ref="testDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后在测试类中测试一下 1234567891011121314package com.test;import com.test.service.TestService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-config.xml"); TestService testService = (TestService)ac.getBean("testService"); testService.sayHello(); &#125;&#125; 然后看一下结果 以上就是构造注入 属性的setter注入&nbsp;&nbsp;和上面创建一样，只需要更改一下TestServiceImpl中的代码和spring-config.xml就行 123456789101112131415161718192021package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public void setTestDao(TestDao testDao) &#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;property name="testDao" ref="testDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 4. 课后习题 举例说明IOC容器的实现方式有哪些？ 控制反转和依赖注入 spring中什么是控制反转？什么是依赖注入？使用控制反转与依赖注入的优点？ 控制反转：是一种通过描述并通过第三方去产生去获取特定对象的方式 依赖注入：使用spring框架创建对象时动态的将其所依赖的对象注入到Bean组件中。 控制反转优点： ​ 1.获取对象可以通过注解等方式获取对象，打破传统的获取方式 ​ 2.对象不再由程序本身进行创建，而是交给spring容器创建，降低了程序的耦合性 ​ 3.控制反转能做到更多的事情，例如事务控制 ​ 4.后期维护方便 依赖注入优点： ​ 1.项目开发讲究高内聚，低耦合 ​ 2.使用依赖注入可以避免使用new关键字创建对象，从而降低类与类之间的耦合度 spring框架采用java的反射机制进行依赖注入.]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
