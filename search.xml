<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LinkedHashMap详解]]></title>
    <url>%2F2020%2F08%2F05%2FLinkedHashMap%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Security学习]]></title>
    <url>%2F2020%2F08%2F05%2FSpring-Security%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis基础知识]]></title>
    <url>%2F2020%2F07%2F30%2FMybatis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对象头大小分配]]></title>
    <url>%2F2020%2F07%2F30%2F%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[对象头大小分配1、在32位系统下，存放Class指针的空间大小是4字节，MarkWord是4字节，对象头为8字节。 2、在64位系统下，存放Class指针的空间大小是8字节，MarkWord是8字节，对象头为16字节。 3、在64位开启指针压缩的情况下 -XX:+UseCompressedOops，存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节。 4、如果对象是数组，那么额外增加4个字节 对齐填充最后一块对齐填充空间并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。这是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVCC详解]]></title>
    <url>%2F2020%2F07%2F30%2FMVCC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MVCC详解简介MVCC,多版本的并发控制，就是当我们在修改数据的时候，可以为这条数据创建一个快照，后面就可以直接读取这个快照。 工作过程InnoDB的MVCC，是通过在每行纪录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间），当然存储的并不是实际的时间值，而是系统版本号。 MVCC优缺点MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。 MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）。 Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC. 原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。 串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。 通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS详解]]></title>
    <url>%2F2020%2F07%2F30%2FAQS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AQS详解AQS(AbstractQueuedSynchronizer类)是JUC并发包中一个很关键的存在。 AQS是一个队列同步器，这是一个用来构建锁和同步器的框架，在内部定义了一个int类型的state变量，用来表示同步状态。 lock包中的锁并没有直接继承AQS，而是定义了一个Sync类去继承AQS，原因是为了解耦合，锁是面向用户的，同步器是线程控制，通过聚合，两者相互隔离，可以有效地关注各自的事情。 AQS是通过FIFO双向的同步队列进行同步状态的管理，当有线程获取锁失败后，就被放在队列的末尾。 头节点是持有锁的节点。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU机制与实现]]></title>
    <url>%2F2020%2F07%2F30%2FLRU%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[LRU机制与实现LRU是一种缓存淘汰策略 LRU 最近最久未使用LFU 最近最少使用（最不常用） 设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。 它应该支持以下操作： 获取数据get和 写入数据put。 获取数据get(key)- 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 LeetCode 面试题 16.25. LRU缓存 123456789101112131415161718192021222324252627282930313233343536373839package org.lru;import java.util.*;/** * @Author: wys * @Description: * @Date: 2020/8/5 10:23 * @FileName: LRUCache */public class LRUCache &#123; private int capacity; private Map&lt;Integer,Integer&gt; map; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new LinkedHashMap&lt;&gt;(); &#125; public int get(int key) &#123; if(map.containsKey(key))&#123; Integer value = map.remove(key); map.put(key, value); return value; &#125; return -1; &#125; public void put(int key, int value) &#123; if(map.containsKey(key))&#123; map.remove(key); map.put(key,value); return; &#125; map.put(key,value); if(map.size()&gt;capacity)&#123; map.remove(map.entrySet().iterator().next().getKey()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池详解]]></title>
    <url>%2F2020%2F07%2F30%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[线程池详解首先我们来了解一下什么是线程池 顾名思义，我们之前了解过JDBC连接池，就应该明白，线程池也是一样的，都是预先创建 好一堆对象来进行重复使用。 池化技术能够减少资源的创建次数，提高程序性能 池化技术特点： 对象创建时间长 对象创建需要消耗大量的资源 对象创建后可以被重复使用 线程池注意 创建线程池的几种形式1234567Executors.newFixedThreadPool(5); //创建固定数量的线程Executors.newSingleThreadExecutor(); //单个线程Executors.newCachedThreadPool(); //可伸缩的线程池Executors.newScheduledThreadPool(5); //线程调度池/***在任务执行时间小于间隔时间的情况下，程序以起始时间为准则，每隔指定时间执行一次，不受任务执行时间影响*/ 以上都是提供的几种形式，如果不满足的话，那么可以自己定义一个数据池来供自己使用 参数在定义自己的数据池之前要了解线程池的每个参数作用 1234567int corePoolSize //核心线程数量int maximumPoolSize //最大线程数量long keepAliveTime //保持存活的时间TimeUnit unit //时间计算的规则BlockingQueue&lt;Runnable&gt; workQueue //阻塞队列ThreadFactory threadFactory //线程工厂模式RejectedExecutionHandler handler //四种拒绝策略 我们可以把线程池抽象出来，比作一个银行运作模式 核心线程就是默认开启的窗口数量 最大线程数量就是银行能够提供的最大窗口数量 保持存活的时间：就是如果线程数量大于核心线程数，但是线程如果空闲等待时间大于保持存活的时间，就会销毁这些线程。 时间计算的规则：就是TImeUnit类的规则 阻塞队列：就是银行等待区的最大人数 线程工厂模式：负责生产线程的工厂，一般是不用改变的，使用默认的就行 拒绝策略： ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常 ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务 ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务 拒绝策略可以理解为 如果银行窗口和等待区全部占满之后，银行对新进来的人进行的安排策略。 自定义线程池如果了解以上参数的话，我们就可以来编写自己的线程池了 12345678910111213141516171819202122232425public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; Executors.newFixedThreadPool(5); Executors.newSingleThreadExecutor(); Executors.newCachedThreadPool(); Executors.newScheduledThreadPool(5); ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 5, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); try&#123; for(int i=1;i&lt;=9;i++)&#123; executor.execute(new Thread()&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"执行了"); &#125; &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; executor.shutdown(); &#125;&#125; 如果线程池用完了。。记得关闭就行。 线程池的几个队列（1）ArrayBlockingQueue：规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。 （2）LinkedBlockingQueue：大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。 （3）PriorityBlockingQueue：类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。 （4）SynchronizedQueue：特殊的BlockingQueue，对其的操作必须是放和取交替完成。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器详解]]></title>
    <url>%2F2020%2F07%2F30%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[垃圾收集器详解垃圾收集器是垃圾回收算法的实现。 Serial收集器这是一个最基础，最久远的收集器，是一个单线程的收集器，在工作的时候会暂停其他线程，来进行垃圾回收。 新生代采用复制算法，老年代采用标记-整理算法。 ParNew收集器ParNew收集器实质上是Serial收集器的多线程并发版本。 新生代采用复制算法，老年代采用标记-整理算法。 Parallel Scavenge收集器这个收集器是一个新生代收集器。 新生代采用复制算法，老年代采用标记-整理算法。 看上去似乎和ParNew差不多，实际上这个收集器的特点是它的关注点与其他的不同，比如CMS等其他收集器都是以缩短用户线程停顿时间为主要目标，而Parallel Scavenge收集器是为了达到一个可控制的吞吐量，能够有效的提高用户体验。 Serial Old 收集器Serial Old收集器是Serial收集器的老年版本，同样也是一个单线程收集器。 采用的是标记整理算法。 一般是和Parallel Scavenge收集器搭配使用。 Parallel Old收集器Parallel Old收集器是Parallel Scavenge收集器的老年版本。 新生代采用复制算法，老年代采用标记-整理算法。 CMS收集器CMS收集器是为了获取最短回收停顿时间为目标的收集器。 运作过程： 1、初始标记 2、并发标记 3、重新标记 4、并发清除 优点：并发收集，低停顿 缺点： 对处理器资源敏感，会占用CPU资源，导致应用变慢，降低总吞吐量。处理器不足四个就会使处理器负载变大。 无法处理 “浮动垃圾”，标记结束后，没有办法一次性清除完毕的垃圾。 产生资源碎片，因为采用标记清除，所以会产生大量空间碎片 G1收集器G1收集器是一款面向服务端应用的垃圾收集器。 在新生代，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World的暂停。新生代的清理会带上old区已标记好的region。 G1运作过程： 初始标记 并发标记 最终标记 筛选回收 特点： 并行与并发：充分利用了CPU资源 分代收集：可以更好地进行管理分代区 空间整合：不会产生内存碎片 可预测停顿：能够让使用者明确指定消耗在垃圾收集器上的时间 缺点 region大小和对象很难保持一致，导致空间的浪费。 CMS只是针对老年代的，而G1是针对两者的 G1可以不需要其它收集器配合就能独立管理整个GC堆]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建线程的几种方式]]></title>
    <url>%2F2020%2F07%2F30%2F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[创建线程的几种方式 继承Thread类 实现Runnable接口 通过Callable和FutureTask创建线程 通过线程池创建线程 1、继承Thread类123456789101112public class ThreadDemo extends Thread&#123; public static void main(String[] args) &#123; ThreadDemo threadDemo = new ThreadDemo(); Thread t1 = new Thread(threadDemo,"A"); t1.start(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"线程启动了！"); &#125;&#125; 2、实现Runnable接口123456789101112public class RunnableDemo implements Runnable&#123; public static void main(String[] args) &#123; RunnableDemo demo = new RunnableDemo(); Thread t1 = new Thread(demo,"A"); t1.start(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"线程启动了！"); &#125;&#125; 3、Callable和FutureTask1234567891011121314public class CallableDemo implements Callable&lt;String&gt; &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; CallableDemo demo = new CallableDemo(); FutureTask&lt;String&gt; task = new FutureTask&lt;String&gt;(demo); new Thread(task,"A").start(); System.out.println(task.get()); &#125; @Override public String call() throws Exception &#123; System.out.println(Thread.currentThread().getName()+"线程启动了！"); return "启动了"; &#125;&#125; Callable是可以有返回值的，通过线程执行完毕调用get()方法获得 4、通过线程池启动1234567891011121314151617181920212223242526272829303132333435/** * @Author: wys * @Description: * @Date: 2020/7/30 10:17 * @FileName: ThreadPoolDemo * int corePoolSize, 核心线程数量 * int maximumPoolSize, 最大线程数量 * long keepAliveTime, 保持存活的时间 * TimeUnit unit, 时间计算的规则 * BlockingQueue&lt;Runnable&gt; workQueue, 阻塞队列 * ThreadFactory threadFactory, 线程工厂模式 * RejectedExecutionHandler handler 四种拒绝策略 */public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 5, 5, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); try&#123; for(int i=1;i&lt;=9;i++)&#123; executor.execute(new Thread()&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"执行了"); &#125; &#125;); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; executor.shutdown(); &#125;&#125; 线程池核心就是。。上面的7中参数。。一定要记住 四种拒绝策略： AbortPolicy：如果满了就报错 CallerRunsPolicy：哪来的就回拿去，意思就是让本来的线程去执行 DiscardOldestPolicy：如果满了就与第一个执行的线程竞争一下cpu资源，如果成功就执行，不成功就拒绝掉，不会报错 DiscardPolicy：如果满了就直接拒绝掉，不会报错]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试场景题]]></title>
    <url>%2F2020%2F07%2F30%2F%E9%9D%A2%E8%AF%95%E5%9C%BA%E6%99%AF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试场景题1、一个是用户信息文件, 保存了1亿的用户信息, 一个是用户浏览商品的记录的文件, 保存了500万的用户浏览记录, 怎么合并这两个文件? (内存为1G) 文件中怎么快速找出浏览记录大于5的数据? 暂空 2、现有1T的数据，内存只有1G，该怎么对他们排序 外部排序。多路归并 3、不知道大小的数据流取其中100个数，怎样的取法能最随机 暂空 4、n个物品每个物品都有一定价值，分给2个人，怎么分两个人的价值差最小 暂空 5、假设百度每个页面能放100个网页，每个页面都有一个评分，怎样快速找到第8页的所有网页 暂空 6、如果一个sql执行慢，可能是什么原因造成的，你说说如果是你碰到了，你打算怎么排查? 暂空 7、两个数字 int a=10 int b=20 如何不经过第三个变量来交换，结果为 a=20 b=10 使用位运算 a = a^b b = a^b a = a^b 8、假如有上亿条数据，你如何快速找到其中一条你想要的数据（几种简单的算法） 暂空 9、每秒几十万并发的秒杀系统为什么会频繁发生GC？ 暂空 10、日均百万级交易系统如何优化JVM？ 暂空 11、如何从含有100亿个整数的文件中找出其中最大的100个？ 暂空 12、tomcat在并发场景中，应该如何优化tomcat，比如再下次8g内存的服务器上，部署4个tomcat，怎么做可以合理调优 暂空]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql锁详解]]></title>
    <url>%2F2020%2F07%2F25%2Fmysql%E9%94%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[mysql锁详解mysql的锁可以用两种情况区分 按粒度分为 行锁,页锁,表锁 按用法有共享锁和排他锁 按粒度来分行锁行锁是锁粒度最细的一个锁了,表示只对自己当前操作的行加锁. 行锁操作可以大大的减少数据库操作带来的冲突,但是加速开销太大 行锁分为共享锁和排他锁. 特点: 开销大,可能会出现死锁,并发程度高,锁冲突概率最低. 表锁表锁是mysql锁粒度最大的一个锁, 表示对当前操作的整张表都加锁, 资源消耗大, 被大部分引擎都支持. 表锁分为 共享锁 和 排他锁 特点: 开销小, 加锁快, 不会出现死锁, 锁粒度大, 发生冲突的概率最大, 并发性最低. 页锁页级锁是mysql中锁粒度一般的锁, 一般都是在行锁和表锁之间. 表锁速度快,但是冲突多, 行锁冲突少, 但是速度慢, 于是采用 页锁的比较多. 页锁是一次锁定相邻的一组记录开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 悲观锁悲观锁是一种悲观的并发控制线程访问的一个方法. 它可以阻止一个事务以影响其他用户的方式来修改数据. 如果一个事务的操作的某行数据加了锁, 那么只有当这个事务把锁释放了, 其他事物才能够执行和该锁冲突的操作. 悲观锁主要用于数据竞争比较激烈的环境 还有 并发冲突时维护锁的成本低于回滚成本的环境中. 使用:如果要对数据修改,先给这个数据添加排他锁,如果添加失败,那么说明正在被使用, 因此要等待或者抛异常. 优点: 保证了数据的安全和完整性 缺点: 效率低,会让数据库产生额外开销,还有可能出现死锁, 在只读的事务中不会产生冲突, 这样做会增加系统开销, 降低了并行. 乐观锁乐观锁是一种乐观的并发控制线程访问的一个方法. 它假设在并发处理事务时,都不会相互影响, 各事务能够在不产生锁的情况下处理各自影响的那部分数据. 就是只在提交的时候进行判断是否冲突 提交数据时判断有没有其他事务修改数据, 如果数据被修改了,那么就回滚. 乐观锁不会使用数据库提供的锁机制, 一般的实现乐观锁的方式就是记录数据版本, 即添加一行字段 version , 如果提交时发现字段一致, 就更新数据 , 否则就回滚. 实现乐观锁两种方式: 版本号 和 时间戳 乐观锁原理就是 CAS 操作 InnoDBinnodb 支持行锁 和 表锁 默认是支持行锁 innodb行锁是个索引加锁实现的, 意思就是只有通过索引条件检索数据, InnoDB才使用行级锁, 否则 InnoDB使用表锁 , 实际中我们要注意这种情况, 不然会产生大量冲突. 当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。 即便 在 数据库设置了索引, 但是是否用索引 还是根据mysql 通过判断不同 执行计划代价来决定的, 如果 mysql 认为全表扫描效率高, 例如一些很小的表, 他就不会使用索引, 这种情况下 就会使用 表锁. 索引和锁在mysql中, 行锁不是直接锁记录, 而是锁的时索引. 索引分为主键索引和非主键索引, 如果mysql操作了主键索引, 那么就锁主键索引, 如果走的索引是 非主键索引, 那么先锁非主键索引, 再锁相关的主键索引. 死锁:一个事务锁了主键索引, 另一个事务锁了非主键索引, 在等主键索引, 就造成了死锁. 死锁后 InnoDB都可以检查到, 并使一个事务释放锁并回退, 另一个获取锁完成事务. *避免死锁: * 尽量有序访问表 尽量一次锁定所需要的所有资源 也可以升级锁粒度]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度一面面经]]></title>
    <url>%2F2020%2F07%2F24%2F%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[百度一面面经1、介绍自己。 2、说说面向对象的几个特点 3、然后出了几个 ==条件 让我进行判断（Integer缓冲池） 4、然后一个剑指Offer原题。 一开始没有暴力，后来用hashmap进行优化时间 5、int的最大值，为什么？ 6、ArrayList和LinkedArrayList区别 6、mysql索引（B+树原理） 7、innodb的原理（回表操作） 8、给了几个索引查询语句，判断可以不可以走索引进行查询 9、最后让编写一个各科平均分数的sql语句（没写出来，太菜了） 10、需要问什么问题？ 我问的是，我有些地方答得不是很好，希望你能给我讲讲我现在需要提升的地方。 基础知识都是靠记得，理解上面有些不好，sql语句也不是很好，需要多去理解理解，知识不能靠死记硬背，把sql语句也练一练]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat原理]]></title>
    <url>%2F2020%2F07%2F24%2FTomcat%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Tomcat原理简介Tomcat是一个JSP/Servlet容器，其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器、进程外的Servlet容器。 Tomcat也是一个中间件，运行在JVM上，是一个在JAVA项目和JVM之间的中间容器。 整体架构 核心容器和Connector和Container Connector：处理连接相关内容，并提供Socket的Request和Response相关的转换。 Container：核心容器，封装和管理Servlet，处理Request请求。 三种Connector运行模式 BIO：同步阻塞IO，一个线程处理一个请求，同时把其他线程阻塞，并发量高时，线程多，导致性能严重下降 NIO：异步非阻塞IO，一个线程处理多个Connection，多路复用，使用较少的线程执行较多的请求。 APR：异步非阻塞IO，和NIO在操作系统层面不同，不需要关注进度问题。 Tomcat工作模式Tomcat作为servlet容器，有三种工作模式： 1、独立的servlet容器，servlet容器是web服务器的一部分； 2、进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足； 3、进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和java容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优； 进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类： Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等； Tomcat作为独立服务器：请求来自于web浏览器； Tomcat违背双亲委派模型首先谈一下Tomcat要实现的目的： 运行多个web程序，并且各个依赖的类库相互独立，相互隔离。 部署在同一个web容器下的相同类库可以共享。 web容器自己类库不能与程序冲突。 需要更改jsp后不用重启。 Tomcat类加载器 双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。 tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器 、]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnSafe类详解]]></title>
    <url>%2F2020%2F07%2F23%2FUnSafe%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[UnSafe类详解Unsafe是位于sun.misc包下的一个类 主要是提供一些用于执行级别低，不安全操作的方法，如直接访问系统的一些资源，这些方法对提高java运行效率，增强java语言底层资源操作能力方面起到了很大的作用。 但是因为底层是直接操作内存来实现功能的，所以可能会发生内存上的一些问题，比如内存泄漏，如果不正当使用的话，可能使java变得不再那么安全。 结构 如上图可看出，Unsafe类在多个方面都有使用： 内存操作 主要是堆外内存的分配、拷贝、释放、给定地址值等操作。 因为是堆外内存，所以不归JVM管，得自己进行内存的管理 使用堆外内存的原因：对GC停顿进行改善，减少停顿带来的影响，提高IO操作性能，不需要再次进行拷贝。 CAS操作 比较并交换，轻量级无锁并发，执行CAS操作时，首先拿地址中的值和原值作比较，如果一样就把内存值更新为新值，否则就不做任何操作。 CAS在很多方面都有应用，比如Atomic原子类，还有AQS，ConcurrentHashMap等地方都有体现。 Class相关的一些操作 此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等 对象操作 此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。 常规分配内存是使用new关键字，然后交给JVM来管理 但是Unsafe有分配内存的方法，不需要通过JVM进行操作， 线程调度 线程挂起，恢复，锁机制等操作。 系统信息获取 这部分包含两个获取系统相关信息的方法。 内存屏障 在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。 数组操作 这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对对象三大特点]]></title>
    <url>%2F2020%2F07%2F23%2F%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[面向对象三大特点封装就是把自己的类给封装起来，只暴露出想让外界访问的接口和数据，保证了类的安全性。 继承OOP的一个主要功能，通过继承来实现代码的复用。 多态同一个操作，作用于不同的对象，会产生不同的结果。 多态的好处是可以解耦合，灵活，面向接口编程，]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引底层原理]]></title>
    <url>%2F2020%2F07%2F22%2Fmysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[mysql索引底层原理我们都知道索引可以提高查询效率，那么为什么会提高查询效率呢？ 我们可以从底层进行分析，因为mysql索引的底层是基于数据结构的。 假入我们没有索引，那么如果有5个数据，mysql在查询的时候就会比较5次，如果有1000w数据，那么就要比较100w次，很显然，这样的速度，我们肯定不能接受，所以就必须使用索引来进行优化查询速度。 mysql底层有以下几种数据结构： Hash表 二叉搜索树 AVL和红黑树 B树 B+树 mysql引擎也有两种常用的： InnoDB MyiSam Mysql底层数据结构Hash表 哈希表也叫散列表，是根据key和value直接进行访问的数据结构，是快速检索的好方法。 哈希算法：也叫散列算法，就是把任意的key值通过哈希函数变换成固定长度的key地址，然后通过这个地址存放数据的算法。 哈希碰撞：比如hash(7)和hash(199)值一样，如果只存放一个数据的话，会冲突，解决这种情况最常用的方法是链地址法，把碰撞的数据通过链表连接起来，但是计算完hash值之后还需要判断有没有产生hash碰撞，还得重新遍历一边链表，直到找到真正的key对应的数值。 hash算法的时间复杂度是O(1)，但是考虑到数据检索有一个范围性，hash算法对查询一个数据很高效，但是没办法做到高效查询范围，因此哈希索引不适合做Mysql底层索引。 二叉搜索树 二叉搜索树也是一支持数据快速检索的数据结构。 二叉搜索树左子树所有值小于根节点的值，右节点所有值大于根节点的值。 二叉搜索树的时间复杂度是O(logn)，二叉搜索树还能解决高效范围性查找数据。 普通的二叉搜索树有个致命缺点，在极端情况下会退化成线性链表，二分查找会变成线性查找，性能严重下降。 例如主键索引，因为一般情况下主键索引都是自增的，采用二叉搜索树作为底层索引的话会导致查询性能严重下降。 AVL树和红黑树由于二叉搜索树极端不平衡的情况，就提出了让树节点自动旋转和调整，以便于随时处于平衡的状态，也就能保证二叉搜索树的查询性能。 红黑树假入二叉搜索树处于一个严重不平衡的状态，那么红黑树就会自动调整节点，通过自动左旋右旋以及节点变色来调整树的形态，使其保持基本的平衡状态（时间复杂度O(logn)）。 红黑树保证了二叉搜索树不会处于一种极端情况（O(n)），但是又会引出一种新的问题，假入当我们顺序插入1~16个节点后，树形态会产生右倾，但是并没有像二叉搜索树那样的线性夸张，不过如果数据有几百万条的话，查询效率也会变得特别慢，对性能影响也是巨大的。 AVL树由于红黑树会产生右倾趋势，所以又引出了一种更为严格的二叉平衡树（AVL树），这个树是一个绝对平衡的二叉树，因此在调整形态上会花费更多的性能。 比如我们插入1~16个节点，最后AVL树的结构会如下： 从树的形态我们可以看出来，AVL树不会产生右倾的状态，我们查询16号节点，AVL树会比较四次，而红黑树会比较6次，这样就从根本上解决了红黑树的问题。 所以AVL树的优点有以下几点： 查找性能好（O(logn)），不会产生极端情况，严重降低性能 可以实现范围查找和数据排序 但是AVL树并不适合作为Mysql的底层索引的数据结构，主要是因为数据库查询的瓶颈在于磁盘IO，如果使用AVL树，每个节点只存放一个数据，我们一次磁盘IO只能把一个数据加载到内存中，比如查找节点7，就要进行三次IO，这样会特别耗时间，所以如果要设计数据库索引就要考虑很多情况，首先肯定是每个节点都存放多个数据，而且一次IO就可以加载多个数据到内存中，这就引出了B+树的设计原理。 磁盘IO有个特点，就是磁盘读取1K的数据和读取1B的数据所消耗的时间是一样的。 B树每个节点可以限制存放的key值数量，如果超过了这个约定的key值数量就自动分裂，比如我们继续插入1~16个节点，如果限制一个节点存放2个key的数量的话，结构如下 我们不难看出查询节点16的性能和AVL树一样了，也是经过四次磁盘IO，我们可以考虑每次IO可以读取更多的数据到内存中，可以增加限制的key的数量为6个 这样对于磁盘IO的次数就可以降低一半，只需要两次就可以读取到。 B树的优点： 优秀的检索速度，差查找性能等于O(h*logn)，h是树高，n为每个节点关键词的个数。 尽可能地减少了磁盘IO的次数，提高了性能。 可以支持范围查找。 B+树首先看一下B树和B+树的区别： B树一个节点里存放的是数据，而B+树存放的是索引（地址），所以B树里一个节点 存不了很多数据，但是B+树可以存放很多数索引，B+树叶子节点存放所有数据。 B+树叶子节点使用链表串联了起来，便于范围查找。 对比可以看出，B+树存放的是索引，在单个节点容量有限的情况下，单节点也可以存放大量索引，使得整体树的高度降低，减少了磁盘IO，其次叶子节点是存放真正数据的地方，叶子节点用链表连起来，而且还是有序的，在范围查找中更占有优势。所以mysql索引用的就是B+树，在查找效率和范围查找都有不错的性能。 例如插入1~16个节点： Mysql引擎mysql底层数据引擎以插件的形式设计，最常见的就是InnoDB和Myisam引擎，用户可以根据个人需求来选择不同的引擎作为mysql底层引擎。 首先来分析一下两者的区别： MyISAM查找性能好，但是不支持事务处理，InnoDB最大特色就是支持ACID兼容的事务功能，而且还支持行级锁 InnoDB创建表后生成的文件有： frm:创建表的语句 idb:表里面的数据+索引文件 MyISAM创表后生成的文件有： frm:创建表的语句 MYD:表里面的数据文件（myisam data） MYI:表里面的索引文件（myisam index） InnoDB把数据和索引放在一起，称为聚集索引，而MyISAM把数据和索引分开，称为非聚集索引。 MyISAM底层实现MyISAM采用非聚集索引，建表时以主键作为key来建立B+树，树的叶子节点存放的是对应数据的物理地址，我们拿到这个物理地址后，就可以到MyISAM数据文件中直接定位到具体的数据记录。 当我们为某个字段添加索引时，也会生出该字段的索引树，该字段的索引树的叶子节点同样记录了数据文件中的物理地址，根据这个地址同样可以定位到具体的数据记录。 InnoDB底层实现InnoDB是聚集索引，数据和索引都在一个文件中，建表时，InnoDB会根据主键ID作为key建立索引B+树，B+树叶子节点存放的是主键ID对应的数据。 我们为某个字段添加索引时，会根据这个字段去建立索引树，索引树节点中存放的是字段的值，根节点存放的是主键的值，拿到主键的key值之后会到主键索引创建的B+树查找对应的数据。 InnoDB只在主键索引的叶节点存放具体的数据原因是需要节省空间，一个表可能有多个索引，如果每个都创建一个索引树存放具体数据，就会导致数据文件变得十分巨大，数据冗杂，因此采用上面那种方式就可以牺牲较少的查询性能节省巨大的磁盘空间，还是蛮好的。 对比由上面可以得知，MyISAM查询性能更好，因为MyISAM查询一次就能获取到数据，查询到物理地址就直接去数据文件中寻找。 而InnoDB两次才行，第一次查询到叶子节点的主键索引，第二次根据主键索引去主键索引创建的B+树中去寻找。 什么时候需要创建索引呢？ 查询频繁的字段 唯一性太差的字段不适合创建索引，即使这个字段频繁作为查询条件。 更新频繁的字段不适合创建索引，因为每次都需要维护B+树，导致性能差。 最终选择B+树的原因？ hash特别快，但是只能针对一个值 AVL和红黑树，在大数据的情况下，磁盘IO操作过多 B树每个节点存放的是数据，节点存放的分支太少了。 B+树节点存储的索引是索引和指针（引用指向下一个地址），可以存储大量索引，同时最终数据在叶子节点上，并且有引用横向链接，可以在2~3次的IO操作中完成千万级别表的操作。 建议索引为主键索引，有自增操作，适合范围查找。 文章参考自：https://zhuanlan.zhihu.com/p/113917726]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[native关键字]]></title>
    <url>%2F2020%2F07%2F22%2Fnative%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Native关键字介绍java调用本地API方法的关键字，不需要让java实现，让C++去实现。 JNI是Java Native Interface的 缩写，JNI允许java和其他语言进行交互，但是这样会丧失平台可移植性。 JNI标准至少保证本地代码能工作在任何java虚拟机下。 public static native void a(int a); native关键字修饰的方法不需要实现，交给C或C++语言实现即可 如果想要调用native方法，自己可以实现一个，然后编译到动态库中，在java中加载动态库即可。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final关键字详解]]></title>
    <url>%2F2020%2F07%2F22%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Final关键字final关键字可以修饰的地方： 类：类不能被继承 方法：不能被重写 变量：不能被改变 修饰引用类型：引用类型的内存地址不可变，指向的值可以变。 final 修饰的变量 会直接放在变量池中，如果一个类调用final修饰的变量是不会加载类的 如： 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; System.out.println(demo.s); &#125; public static class demo&#123; public static final String s = "1"; static &#123; System.out.println("静态代码块"); &#125; &#125;&#125; 11 直接输出1，不会加载静态代码块]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object类的方法]]></title>
    <url>%2F2020%2F07%2F22%2FObject%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Object类方法Object是所有类的父类，任何类都默认继承Object。Object类到底实现了哪些方法？ （1）clone方法 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 （2）getClass方法 final方法，获得运行时类型。 （3）toString方法 该方法用得比较多，一般子类都有覆盖。 （4）finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 （5）equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 （6）hashCode方法 该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 （7）wait方法 wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 （8）notify方法 该方法唤醒在该对象上等待的某个线程。 （9）notifyAll方法 该方法唤醒在该对象上等待的所有线程。 引用来自：https://www.php.cn/faq/416709.html]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String和StringBuffer,StringBuilder区别]]></title>
    <url>%2F2020%2F07%2F22%2FString%E5%92%8CStringBuffer-StringBuilder%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[String和StringBuffer,StringBuilder区别 String类是不可变的，而StringBuffer和StringBuilder是可变的 String一旦修改，就会重新开辟一块内存来存储修改的对象。 如果频繁修改字符串，肯定不能用String，会导致内存空间浪费。 频繁修改字符串就应该使用StringBuffer，底层也是和String一样都是数组，但是StringBuffer会建立一个缓冲区，所以速度会大于String StringBuffer方法都加了锁，所以效率可能比StringBuilder更低，但是安全性来说，StringBuffer更好。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2020%2F07%2F22%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java反射机制简介java反射机制是指在程序运行状态中，可以动态获取一个类的所有信息，这种功能被称为反射，反射是动态语言的关键。 java动态代理是基于反射实现的。 反射是面向抽象编程的一种实现方式，使代码更加灵活，极大提高了代码的运行时装配能力。 意义 反射提高了程序灵活性和扩展性，降低了模块的耦合性，提高了自身适应能力。 反射可以在运行时构造一个类对象，动态的调用类中的方法。 反射是构建框架的基础，可以避免把代码写死在框架中。 特点 性能，因为JVM不能对反射代码进行优化，所以效率比较低，所以应该避免在性能要求搞得项目中去使用反射。 安全性，如果程序安全性要求较高，就不能使用反射，不然会破坏封装的特性，使得程序可能会被改动。 健壮性，反射允许代码进行一些不被允许的操作，所以反射可能导致破坏java程序的抽象性，导致平台变化抽象逻辑结构不能被识别，代码允许效果产生差异。 破坏我们都知道一个final修饰的成员变量不能被修改，但是反射可以破坏这个规矩，比如 123456789101112131415161718public class Main &#123; public final Integer a = 1; public static void main(String[] args) &#123; Main t = new Main(); try &#123; Field field = t.getClass().getDeclaredField("a"); field.setAccessible(true); Field modifiers = Field.class.getDeclaredField("modifiers"); modifiers.setAccessible(true); modifiers.setInt(field,modifiers.getModifiers()&amp;~Modifier.FINAL); field.set(t,5); System.out.println(field.get(t)); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(t.a); &#125;&#125; 如果final 修饰的是基本数据类型，那么在编译器就会被优化，导致修改之后输出的还是编译器优化好的常量值 所以如果换成引用数据类型，我们就可以看出来值已经被修改成了5，这个就是破坏了类的内部数据，所以如果安全性要求较高，就不建议使用。]]></content>
      <categories>
        <category>反射</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal原理]]></title>
    <url>%2F2020%2F07%2F22%2FThreadLocal%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ThreadLocal原理简介ThreadLocal是一个本地线程副本变量工具类，各个线程都有自己的一份线程私有数据，线程之间的变量互不干扰，高并发情况下保证线程安全。 传统的线程安全是使用CAS或者synchronized锁实现的。 结构 每个Thread里面都有一个Map对象 Map里面存放的是线程本地对象和线程的变量副本 ThreadMap内部的Map是由ThreadLocal维护的，由ThreadLocal获取和设置变量值。 各个线程之间是相互隔离的，一个线程不会获取到另一个线程的值 应用场景 Session管理 数据库连接 内存泄漏ThreadLocal的原理是内部的一个ThreadLocalMap类 Map的Entry继承了weakReference java的弱引用在内存不足时会被回收，变成(null,value)形式，如果线程执行完的话，value也会被回收，如果是在线程池中，那么线程中有个强引用会指向ThreadLocalMap，导致value不会被回收，一直在内存中，如果线程数量太多的话，导致内存可能会发生泄漏 避免方法：如果不用的话要使用remove()方法移除value值，]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rest和RPC]]></title>
    <url>%2F2020%2F07%2F22%2FRest%E5%92%8CRPC%2F</url>
    <content type="text"><![CDATA[Rest和RPC 两种风格的API区别： RPC面向过程：RPC只发送GET或者POST请求，RPC不单单指的是API的开发风格，RPC称为远程过程调用，发送一个RPC请求，实际上就是调用了服务端的一个方法。 Restful面向资源：使用 POST、DELETE、PUT、GET 请求，分别对应增、删、改、查操作。请求参数是名词，这个名词就是“增删改查”想要操作的对象。 RPC和DubboDubbo是一个实现了RPC理念的框架，使得调用远程服务就跟调用本地方法一样，使得Dubbo更加的安全。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重写equals为什么要重写hashcode]]></title>
    <url>%2F2020%2F07%2F22%2F%E9%87%8D%E5%86%99equals%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode%2F</url>
    <content type="text"><![CDATA[重写equals为什么要重写hashcodehashcode规范 当在一个应用程序执行过程中， 如果在 equals 方法比较中没有修改任何信息， 在一个对象上重复调用 hashCode 方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值 可以是不一致的。 如果两个对象根据 equals(Object) 方法比较是相等的，那么在两个对象上调用 hashCode 就必须产生的 结果是相同的整数。 如果两个对象根据 equals(Object) 方法比较并不相等，则不要求在每个对象上调用 hashCode 都必须产生不同的结果。但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables） 的性能。 为什么重写hashcode因为要遵守equals的规范（第二条），如果重写了equals的话，如果equals比较相同，那么hashcode也要相同， 如果在hashmap中没有重写hashcode的话，会出现问题，因为在hashmap中，hashcode是用来作为对象访问定位的，如果重写了String的equals方法的话，put添加值的话，会将完全相同的两个key值存到不同位置。导致出现问题。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口和抽象类]]></title>
    <url>%2F2020%2F07%2F22%2F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[接口和抽象类 接口只能被实现，抽象类只能被继承 接口中的成员变量都是用public static final修饰的，默认都是可省略的 接口的方法都是public abstract修饰的，默认也都是可省略的 接口支持多实现，一个子类可以实现多个接口，但是抽象类只能被单继承，一个子类只能继承一个父类 在1.8之前，接口中不能有方法体，但是在1.8新添加了default method，可以实现方法体 在抽象类中，抽象方法不能有方法体，可以有普通方法，实现方法体 接口和抽象类都不能被实例化 final不能修饰接口和抽象类，因为不能被继承，所以就没有意义]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重载和重写]]></title>
    <url>%2F2020%2F07%2F22%2F%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[重载和重写重载 重载是在同一个类中或者子类中实现。 被重载的方法必须改变参数列表或者参数类型 被重载的方法可以改变返回类型 被重载的方法可以改变访问修饰符，但是修饰符权限只能比被重载的方法大 无法以返回值类型作为重载的依据 重写 父类的方法只能被子类重写 参数列表和参数类型都必须和被重写的方法一样 访问权限不能比被重写的方法低 声明final的方法不能被重写 声明static的方法不能被重写，但能够被再次声明 构造方法不能被重写 如果没有继承这个方法也不能被重写]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals 和 ==]]></title>
    <url>%2F2020%2F07%2F22%2Fequals-%E5%92%8C%2F</url>
    <content type="text"><![CDATA[equals 和 ==equals这个是Object类中的方法，如果没有重写的话，默认就是比较的是内存地址是否相同 String类重写了equals方法，比较的是两个字符串是否相同。 ==这个一般比较的是基本数据类型，判断值是否相同。 但是在引用类型中，比较的是内存地址是否相同。 具体可以通过敲代码来理解记忆。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session和Cookie区别]]></title>
    <url>%2F2020%2F07%2F22%2FSession%E5%92%8CCookie%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Session和Cookie区别什么是sessionSession代表服务器和客户端一次会话的过程。 Session对象存储特定用户会话所需的属性及配置信息。 用户在应用程序的WEB页跳转时，存储在Session对象的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者Session超时失效时会话结束。 什么是cookiecookie是服务器发送到用户浏览器并保存在本地的一小块数据，他会在浏览器下向同一服务器再发起请求时带上并再次发送到服务器。 它会告知服务端两个请求是否来自同一浏览器，如保持用户的登陆状态。 Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。 Cookie主要用于以下三个方面 会话管理（如用户登陆状态，购物车等） 个性化设置（如用户自定义设置，主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 区别 作用范围不同：Cookie在客户端，Session在服务端。 存取方式不同：Cookie只能保存ASCII，Session能保存各种类型，一般情况下我们可以保存一些变量信息。 有效期不同：Cookie可设置为长时间保持，比如我们经常使用的登录功能，Session失效时间比较短，客户端关闭或者Session超时都会失效。 隐私策略不同：Cookie在客户端，不安全，Session存储在服务端，安全性相对较高。 存储大小不同：单个Cookie保存的数据不能超过4K，Session则远远高于Cookie。 为什么要用这些因为HTTP请求是无协议，无状态的，当与服务端交互时，需要Cookie来告诉服务器谁在登录，还有Session配合执行操作。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令（持续更新）]]></title>
    <url>%2F2020%2F07%2F22%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[linux常用命令（持续更新）top查看系统资源占用]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务和隔离级别]]></title>
    <url>%2F2020%2F07%2F22%2Fmysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[mysql事务和隔离级别mysql事务简介mysql的多条语句看成一个整体 事务就是保证这个整体能够同时成功，或者同时失败。 在mysql中不同的引擎对事务的支持也是不一样的 比如InnoDB支持事务， 而 MyISAM不支持事务。 所以以下说的都是mysql的事务都是以InnoDB作为引擎的 事务ACID特性 原子性：要么全都成功，要么全都失败。不会在中间某一步停留，mysql执行事务时如果出错，那么就会回滚到没执行事务之前。 一致性：事务完成前后，数据的完整性不能出错，比如转账，两个人钱的总和再转账前后不能改变，保证数据的一致性。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止并发交替导致数据的不一致。 持久性：事务完成后，对数据的修改是永久的，即使系统故障也不会丢失。 事务的隔离级别简介事物的隔离级别是于事务的隔离性密不可分的，可以通过改变 事务的隔离级别认为以下几种： 读未提交： 任何事务修改数据之后都会暴露给其他事务 读提交：只能读取其他事务已经提交过的数据 可重复读：事务不会读到其他事务对已有数据的修改 串行化：将事务的执行变成顺序型，相当于一个单线程，安全性最高，但是效率最低 从上往下，隔离强度依次增加，性能逐渐变差，可重复读是mysql默认的隔离级别。 事务隔离要解决的问题 脏读：读取到了其他事务未提交的数据，未提交意味着读到的是数据发生了回滚，也就是读到了不存在的数据，这就是脏读。 幻读：这个是针对插入操作来说的，比如事务A更改记录时，事务B插入了一条新的记录与事务A要更改的记录一样，导致在事务A中查询发现更改的数据好像没有改变，这就是幻读。 可重复读：在一个事务中，事务开始前后读取到的数据是一致的。 不可重复读：不同时刻读取的数据是不一样的，比如其他事务提交并更改了数据。 事务隔离级别解决问题情况 总结读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。 读提交解决了脏读问题，行锁解决了并发更新的问题。并且 MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁实现的。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树和AVL树]]></title>
    <url>%2F2020%2F07%2F22%2F%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[红黑树和AVL树红黑树和AVL树都是在二叉搜索树的基础上演变的 由于二叉搜索树在极端情况下会变成一条链，为了避免这种情况，就出现了红黑树和AVL树。 红黑树红黑树有5种性质，而树的构建也是与这些性质密不可分。 性质1、节点是红色或黑色 性质2、根节点是黑色 性质3、所有叶子节点都是黑色的（叶子节点都是NULL） 性质4、每个红色节点的两个子节点都是黑色。 性质5、从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。 当我们对红黑树进行操作的时候，红黑树依旧可以保持这5条性质。 AVL树（平衡二叉树）AVL树也还是一个二叉搜索树，它的特点： 1、本是首先是一颗二叉搜索树 2、自带有平衡条件：每个节点的左右子树高度差值不能超过1. 3、左右两颗子树也都是平衡二叉树 两者区别 AVL树是严格的平衡树，在对节点进行添加和删除时，AVL树旋转次数一般比红黑树多 红黑树时非严格的平衡来换取增删节点时旋转的次数，从而减少开销。 如果搜索次数远远大于添加或者删除就采用AVL树。 如果搜索，删除，添加操作都差不多，就采用红黑树。 红黑树和AVL调整平衡的机制不同 红黑树靠叶子节点的颜色和约定规范进行调整 AVL树靠的是平衡因子和旋转。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2020%2F07%2F22%2FB%E6%A0%91%E5%92%8CB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树和B+树B树B树和平衡二叉树不同，B树又称为多路平衡查找树，数据库索引中B树和B+树也大都被用来做索引。 规则： 排序方式：所有节点关键字按递增排列，遵循左小右大原则 子节点数：非叶节点的子节点数大于1，且小于M，M&gt;=2，M是查找路径。 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2); 叶子节点：所有的叶子节点都在同一层，叶子节点包含有关键字和指向关键字的指针还有指向子结点的指针，但是子结点一般都是null。 特点： B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度; B+树概念：B+树可以说是B树的升级版本，相对于B树而言，B+树充分利用了空间，让查询速度更加稳定，速度完全接近于二分法查询速度。 规则： B+树非叶子节点储存的都是索引，使得每个非叶子节点存储的数据大大增多。 B+树所有数据都保存在叶子节点上，所有数据地址只有在叶子节点上才能获得，每次数据查询速度稳定。 B+树所有叶子节点从小到大有序排列。 非叶子节点的子节点数等于关键字数（Mysql是这样实现的）。 特点： B+数查询速度快，层级更小，非叶子节点存储内容更多，磁盘IO数也比较少，性能高，查询速度快。 B+数查询速度稳定，所有数据都在叶子节点上存储，所有更加稳定。 B+数天然具备排序功能，B+数所有叶子节点构成了一个有序链表，查询区间数据更方便，紧密型更高，缓存的命中率也更高。 B+数全节点遍历更快，B+数遍历整棵树只需要遍历所有叶子节点即可，而不需要对每一层遍历，这样有利于数据库做全表扫描。 如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手和四次挥手]]></title>
    <url>%2F2020%2F07%2F22%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP三次握手和四次挥手 三次握手第一次握手：建立连接时，客户端发送syn包到服务器，客户端进入SYN_SENT状态，等待服务器确认；（SYN就是同步序列编号） 第二次握手：服务器收到syn包，必须确认客户的SYN，同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，这个包发送完毕后，客户端和服务器进入ESTABLISHED状态，完成三次握手。 四次挥手 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。 收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java各类锁的介绍和原理]]></title>
    <url>%2F2020%2F07%2F22%2FJava%E5%90%84%E7%B1%BB%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java各类锁的介绍和原理 乐观锁和悲观锁乐观锁和悲观锁是一种广义上的感念，体现了看待线程同步的不同脚步。 在java和数据库中都对此概念有实际的应用。 概念：对于同一个数据的并发操作来说 悲观锁是认为在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。 java中，synchronized和Lock的实现类都是悲观锁。 乐观锁则是认为自己在使用数据的时候不会有别的线程来修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，就会把自己的数据写入，如果已经被修改了，那么久根据不同的实现方式执行不同的操作，（如报错或者自动重试） 乐观锁在java中是通过使用无锁编程来实现的，最常用的就是CAS算法，原子类中有些操作就是通过CAS自旋实现的。 CAS就是（Compare and swap） 即比较并交换，是一种无锁算法，在不使用锁的情况下实现线程同步。CAS算法涉及到三个操作数： 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。 并且仅当V等于A时，才用B值更新V值，否则不进行任何操作。 自旋锁和适应性自旋锁首先了解一下自旋锁的概念： 阻塞或者唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。但是如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行时间还长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复状态的花费可能会严重影响性能，如果可以让多个线程同时执行，我们可以让后面请求锁的线程不放弃cpu执行时间，看看持有锁的线程是不是很快就释放锁，在这段时间内可以让当前线程自选，如果自选完成后前面的锁已经释放了，就可以直接获取同步资源，避免了线程开销，这就是自旋锁。 自旋锁本身有很大的缺点，它不能代替阻塞，自选等待虽然避免了线程切换带来的损耗，但是这个要占用处理器时间，如果锁被占用的时间很短，那么自旋锁效果就很好，如果锁被占用时间过长，那么自旋锁只会白浪费处理器资源，反之就会白白浪费资源，所以规定了一个次数，当自旋次数超过这个次数，线程就会被挂起。使用（-XX:PreBlockSpin）进行设置次数。 自旋锁在1.4版本引用，使用-XX:+UseSpinning进行开启 自适应意味着自旋时间不再是固定的了，而是根据同一锁的自旋时间以及锁拥有者的状态来决定，如果成功获取锁的次数越多，那么意味着它可以有更多的时间去等待。如果自旋很少获得过锁，那么尝试获得锁时就会忽略这个状态，直接阻塞线程。 自旋锁三个锁形式：TicketLock、CLHlock和MCSlock 无锁和偏向锁和轻量级锁和重量级锁上面几个锁都是针对synchronized锁进行说的 无锁：对资源没有进行锁定，所有线程都能访问，但是只有一个线程能够获取成功。 实现方式是基于CAS实现的，但是无锁无法全面代替有锁，但是无锁在某些场合下的性能是非常高的 偏向锁：如果一个线程一直获取到这个资源，那么线程就会自动获取锁，降低了锁的代价，在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争关系，所以就出现了偏向锁，其目标就是只有在一个线程执行代码块时提高性能。 当一个线程访问同步代码块并且获得锁时，会在mark word里面存放偏向的线程ID，在线程进出同步代码块时不再通过CAS来加锁和解锁，而是检测mark word中有没有存储着指向线程的偏向锁。 偏向锁可以在没有多个线程竞争的情况下，提高效率，偏向锁只需要在置换ThreadID时进行依次CAS操作就行。 偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁：当锁时偏向锁时，被另外的线程访问，偏向锁就会升级成轻量级锁，其他线程会通过自旋的形式获取锁，不会阻塞，从而提高性能。 线程进入同步代码块时，如果同步对象锁状态为无锁状态时，虚拟机首先将在当前线程的栈帧中创建一个名为 锁记录的空间，然后把对象的mark work 拷贝到锁记录中，同时用CAS操作将对象的mark work更新为锁记录的指针，同时用指针指向对象的mark work。 如果这个操作完成了，那么这个线程就拥有了该对象得锁，并将这个锁升级成轻量级锁。 如果这个操作失败了，就看一看对象头指针是否指向当前线程的栈帧，如果指向，说明已经拥有了，那么直接进入同步代码块，否则说明多个线程竞争锁。 重量级锁：如果只有一个等待线程，则该线程通过自旋等待，但是当自旋超过一定次数，或者有一个线程持有锁，另一个线程在自旋等待，又有第三个线程在执行，那么就把锁升级成重量级锁，此时所有等待的线程都被阻塞。 综上：偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 公平锁和非公平锁公平锁：所有线程都会按照申请顺序获得锁，所有线程都在队列中，队列里第一个线程才能获取锁，等待锁的线程不会饿死，缺点是吞吐量低，而且出第一个线程外，所有线程都被阻塞，唤醒线程的开销大。 非公平锁：所有线程都有权去争夺锁，没拿到的都去队列尾等待，吞吐量高，而且线程是非阻塞的，CPU不用唤醒所有线程，但是缺点是队尾等待的线程可能被饿死，或者等了很久才能拿到锁。 可以拿ReentrantLock来举例： ReentrantLock内部有一个sync的类，这个类继承自AQS，添加和释放锁一般都是在Sync中实现的，他有公平锁（FairSync）和非公平锁（NonFairSync）两个子类，ReentrantLock默认是非公平锁，也可以通过构造器来指定锁类型。 可以查看ReentrantLock的源码来分析，公平锁相对于非公平锁，就是多了一条hasQueuedPredecessors()语句，来判断是否处于同步队列第一个元素，如果处于就返回true，否则就返回false。 公平和非公平本质就是判断是不是有序获得锁。 可重入锁和不可重入锁可重入锁：当一个线程获取锁之后，又进入了另一个锁代码块，如果锁住的是同一个对象，那么会默认获取这个锁，不会因为已经获取过没有被释放而被阻塞。ReentrantLock和synchronized都是可重入锁，可重入锁的优点就是可以避免死锁。 不可重入锁：如果是不可重入锁，那么一个线程获取一个锁后，再次进入同样是这个锁给锁住的代码块时，会把原来的锁给释放掉，但是实际上在代码块中没办法释放，所以会产生死锁现象。 可重入锁 ReentrantLock 和 不可重入锁 NonReentrantLock 都继承父类AbstractQueuedSynchronizer（AQS），AQS中维护了一个status变量，可重入锁是每次获取一个锁就把这个状态加一，每次释放锁就减一，而不可重入锁只是判断等不等于0，如果不为0，就阻塞线程，获取锁会失败，如果为0就加一，并且阻塞线程，如果释放锁就把status值更新为0。 独享锁和共享锁独享锁（排他锁）：这个锁只能被一个线程所拿到，如果一个线程给数据添加了独享锁，那么其他线程就不能再加任何类型的锁，保证获得独享锁的线程既能读又能写。而synchronized和Lock的实现类就是互斥锁。 共享锁：这个锁可以被多个线程共享，假入一个线程给一个数据添加了共享锁，那么其他线程只能也添加共享锁，获得共享锁的线程只能读取数据不能修改。 独享锁和共享锁本质也还是由AQS实现的，通过实现不同的方法来实现独享或共享。 读锁和写锁读锁和写锁合称为读写锁，ReentrantReadWriteLock就是一个读写锁，这个类有两把锁： ReadLock（读锁） WriteLock（写锁） 读锁和写锁都是靠内部类Sync实现的锁，Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 读锁是共享锁，写锁是排他锁，因为读写是分离的，所以相比较互斥锁来说，ReentrantReadWriteLock的并发性高了很多。 读写锁中 读写，写读，写写 操作都是互斥的。 重入锁中，AQS中state变量就是重入的次数 独享锁中，通常是0或者1 共享锁中，通常是持有共享锁的数量 但是在ReentrantReadWriteLock有读和写两把锁，所以需要在state一个变量记录两个数量，于是把state变量“按位切割”成两部分，高16位是读锁数量，低16位是写锁数量。 写锁的最大数量是2的16次方-1]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华宇金信面经]]></title>
    <url>%2F2020%2F07%2F20%2F%E5%8D%8E%E5%AE%87%E9%87%91%E4%BF%A1%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[华宇金信面经（第一次面试）毕竟是第一次面试，凉了也没关系，可以多学一些知识 重载和重写的区别 重载 被重载的方法必须改变参数列表 被重载的方法可以改变返回类型 被重载的方法可以改变访问修饰符 被重载的方法可以声明新的或更广的检查异常 方法能够在同一个类中或者在一个子类中被重载 无法以返回值类型作为重载函数的区分标准 重写 参数列表必须完全与重写方法的相同 返回值类型与重写的返回值类型可以不相同 访问权限不能比父类中被重写的方法访问权限更低 父类的成员方法只能被子类重写 声明final的方法不能被重写 声明static的方法不能被重写，但是能够被再次声明 子类和父类在同一个包中，可以重写除了声明private和final的方法 子类和父类不在同一个包中，只能够重写父类的声明public和protected的非final方法 重写的方法可以抛出非强制性异常，无论被重写的方法是否抛出异常，但是不能抛出新的强制性异常，或者比重写方法声明更广泛的强制性异常。 构造方法不能被重写 如果不能继承一个方法，就不能重写这个方法。 接口和抽象类的区别 抽象类和接口都不能直接被实例化 抽象类要被子类继承，接口要被子类实现 接口里面只能对方法进行声明，抽象类既可以声明也可以对方法进行实现 抽象类中的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类，接口里面的方法必须全部被子类实现，如果子类不能实现那么子类必须是抽象类 接口里面的方法只能声明，但是jdk1.8有了default method方式可以进行实现。 抽象类里面可以没有抽象方法 如果一个类里面有抽象方法，那么这个类一定是抽象类 抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。 接口可以继承接口，甚至可以继承多个接口，但是类只能继承一个类 抽象级别：接口 &gt; 抽象类 &gt; 实现类 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能，当你关注事物的本质的时候，请用抽象类，当你关注一种操作的时候，用接口。 接口的设计具有更大的可扩展性，而抽象类的设计必须十分谨慎（要考虑到子类所具有的共同属性和方法）。 类的访问修饰符12345//public 、 default 、 abstract 、 finalpublic class Test();class Test2();abstract class Test3();final class Test4(); public 表示任何位置都可以访问该类 defalut 默认是不写的，只能在同一个包下被访问 abstract表示是个抽象类，不能实例化该类，如果要使用，必须用子类继承 final修饰的类不能给子类继承，改类为最终类，不能在被继承。 为什么 private 和 protected 不能修饰外部类 1、private：表示不能被其它类访问，这个类就失去了意义，所以private只能修饰内部类，被private修饰的类只能被该类的外部类内部使用 2、protected：同理，外部类不能访问，所以这个也没有意义。 3、内部类四种修饰符都可以被使用。 equals 和 ==1、基本数据类型用 == 比较的是值 2、引用数据类型之间用 == 比较的内存引用地址 3、引用数据类型之间使用equals比较的是地址所映射的值 SpringBoot 启动原理123456//核心注解@SpringBootApplication //这个注解包含了一下几种注解@SpringBootConfiguration //主要配置信息@EnableAutoConfiguraiton //开启自动配置，会扫描符合的bean加载到ioc容器中@ComponentScan //扫描所有的包 启动流程 1、首先执行main入口方法运行SpringAppliction.run，后面new了一个SpringApplication对象，然后执行run方法。 2、初始化SpringApplication类，创建SpringApplication对象时，会自动调用初始化方法（initialize()方法） 3、之后执行核心run()方法，然后启动SpringBoot项目。 SpringBoot内置容器undertow tomcat 默认容器 jetty SpringBoot注解 RestController 和 Controller区别1、RestController 相当于 ResponseBody + Controller注解 2、Controller 返回的是视图 3、 RestController返回的是json或者xml格式的数据 MyBits相关的函数没理解这个到底是什么玩意儿。 可能是标签之类的 12345678910select ---查询update ---更新delete ---删除insert ---插入if test ---可以使用String 类的一些方法where ---条件判断choose ---选择 --- resultType ---返回值的类型collection ---集合标签association ---关联标签 Nginx负载均衡 轮询机制Nginx 是个反代服务器 负载均衡： 将单一的重负载分担到多个网络节点上做并行处理，每个节点处理结束后汇总给用户。 将大量前端并发访问或数据流量分担到多个后端网络节点上分别处理（分流） 负载均衡策略： 内置策略 轮询 将每个前端按顺序逐一分配到后端节点上，出现问题的自动排除。 加权轮询 将每个前端按权值依次分配到后端节点上，根据权重的大小来判断每个节点被访问到的概率 IP hash 对访问ip进行hash操作，根据hash结果将请求分配到后端节点上。 扩展策略 将前端的请转发到最近负载最小的节点 算法名称排序 快速排序 堆排序 桶排序 冒泡排序 希尔排序 选择排序 插入排序 DP算法 KMP算法 快速幂 字典树 线段树 后缀数组 DFS和BFS 弗洛伊德算法，迪杰斯特拉算法 最大流，最小流 滑动窗口 数据结构 B树 和 B+树区别B树：这个是一个多路平衡查找树 特点： 每个节点最多有m-1个关键字 根节点最少可以只有1个关键字 非根节点至少有m/2个关键字 每个节点中的关键字都按照从小到大排序，每个左节点小于右节点 所有叶子节点都位于同一层，叶子节点到根节点距离都相同 每个节点都存有索引和数据，也就是对应的key和value值 根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。 B+树：和B树非常相似 与B树相同点： 根节点至少有一个元素 非根节点元素范围 m/2 &lt;= k &lt;= m-1 不同点： B+树有两种类型的节点：内部节点（也称索引节点）和叶子节点 每个叶子节点都存有相邻叶子节点的指针，叶子节点本身依关键字的大小自小而大顺序链接 父节点存有右孩子的第一个元素的索引 总结： 单一节点存储的元素更多，使得查询的IO次数更少，比B树更适合做mysq的底层 所有的查询都要查找到叶子节点，查询性能稳定，B树每个节点都可以查找到数据，不够稳定。 所有的叶子节点形成了有序链表，更加便于查找。 git命令行 总结基础知识差的太多了，一定要多看，多记，多理解。]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2020%2F07%2F20%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式简介单例模式是保证只能有一个类的实例对象，并提供一个全局访问点来访问。 单例模式就比如月亮，在任何时刻都只能保证有唯一一个，而不能有多个月亮。 结构在内部创建一个唯一实例，并提供一个静态的getInstance()方法来访问这个实例，为了防止外部对类的实例化，还需要把构造方法进行私有化。 饿汉式单例模式不考虑其他因素来实现的话就是下面这样: 12345678910public class SingletonDemo &#123; private static SingletonDemo singletonDemo = new SingletonDemo(); private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; return singletonDemo; &#125;&#125; 这样写是没有问题的，也是最常见的，俗称饿汉式单例（不管三七二十一，先创建再说，就是立即加载） 这个创建的话，线程安全是由JVM的&lt;Clinit&gt;方法保证的，保证类初始化阶段的安全性。 缺点：不能有其他实例变量，否则会出现非线程安全问题。 懒汉式单例模式因为真正的单例模式肯定会存放其他变量，所以只是使用饿汉式创建肯定是不好的，这时候就需要采用懒汉式单例模式（延迟加载，只在第一次调用的时候创建） 12345678910111213public class SingletonDemo &#123; private static SingletonDemo singletonDemo = null; private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; if(singletonDemo == null)&#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo; &#125;&#125; 但是这个代码肯定不好，原因是在多线程情况下，如果有线程同时调用了方法，然而对象都还是null状态，就会返回不同的对象，就成了多例模式了。 所以我们可以加个锁： 12345678910111213public class SingletonDemo &#123; private static SingletonDemo singletonDemo = null; private SingletonDemo()&#123;&#125; public static synchronized SingletonDemo getInstance()&#123; if(singletonDemo == null)&#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo; &#125;&#125; 这样就可以保证线程的同步性，但是每次都会阻塞其他线程，导致效率极低，我们同样是不考虑的。 枚举类123456public enum SingletonEnumDemo &#123; INSTANCE; public static SingletonEnumDemo getInstance() &#123; return INSTANCE; &#125;&#125; 枚举单例模式可以防止反射对类造成破坏，安全性极高，推崇性也挺好的。 静态内部类12345678910111213public class SingletonStaticDemo &#123; private SingletonStaticDemo()&#123;&#125; public static class SingletonStatic&#123; private static final SingletonStatic INSTANCE= new SingletonStatic(); &#125; public static SingletonStatic getInstance() &#123; return SingletonStatic.INSTANCE; &#125;&#125; 静态内部类也是依靠JVM的&lt;clinit&gt; 方法来保证线程安全的。 双重校验锁12345678910111213public class Singleton&#123; private volatile static Singleton instance=null;//一定要加volatile private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance==null)&#123; synchronized (Singleton.class) &#123; if(instance==null) instance=new Singleton(); &#125; &#125; return instance; &#125;&#125; 如果不考虑volatile情况的话， 我们可以看出来，多线程并发状态下，如果有线程拿到锁后创建对象， 创建对象三个过程： 先检查类有没有加载 给对象进行初始化 给对象分配内存空间 如果不加volatile的话，第二步和第三步进行指令重排，然后导致一个线程还没初始化，另一个线程访问发现不为空，直接返回了初始化未完成的对象，不能保证线程的安全性。 加了volatile关键字后，所有的写操作都在读操作之前执行。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双亲委派模型]]></title>
    <url>%2F2020%2F07%2F20%2F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[双亲委派模型简介类加载阶段分为加载，连接，初始化，使用，卸载阶段。 由于在加载阶段需要使用全限定类名来获取此类的二进制字节流 Java把这一步抽出来用类加载器去实现，使得可以按自己的需要使用自定义的类加载器 在java中 任意一个类和其加载器来确定类在JVM中的唯一性 类加载器除了能加载类，还能用来作为类层次的划分 java中提供了三个类加载器： 启动类加载器（Bootstrap ClassLoader）：主要负责加载lib目录下的包，或者是被-Xbootclasspath指定路径中，并且文件名是被虚拟机识别的文件，它也是最顶层的加载器。 扩展类加载器（Extension ClassLoader）：主要负责加载lib目录下的ext目录下的包，或者被java.ext.dirs系统变量所指定的路径的类库。 应用程序类加载器（Application ClassLoader）：主要负责加载用户类路径（ClassPath）下的类库，如果没有实现自定义类加载器，那么这就是我们默认的加载器。 模型 解释如果一个类加载器需要加载类，会把这个类交给父类去加载，每一层类加载器都是如此，直到最顶层的父类加载器不能加载这个类，那么就会把这个类交给子类加载器来解决。 双亲委派模型不是一种强制性约束，就是如果你不这样去做也不会报错，他是java设计者推荐使用的类加载方式。 优点 避免java核心api被修改，保证了类加载的安全性 可以避免类的重复加载]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql索引基础]]></title>
    <url>%2F2020%2F07%2F19%2FMysql%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[Mysql索引建立在一个或多个列上的辅助对象，可以加快查询的速度和效率。 索引的实质就是数据结构 优点 自带排序 快速查找 主键索引保证唯一性 表与表连接处添加索引，加速表与表的直接连接 分组和排序语句进行数据检索，减少查询时间中的分组和排序的时间 提高性能 缺点 占用空间 降低更新表的速度 需要动态维护，降低数据的维护速度 创建索引和维护索引会消耗时间，随着数据量的增加而增加 索引分类 普通索引 唯一索引 主键索引 组合索引 全文索引 单例索引一个索引只包含一个列，一个表可以有多个单例索引 1、普通索引最最最基本的索引，没有任何限制， sql格式： 123CREATE INDEX IndexName ON `table_name` (`字段名`(length))#或者ALTER TABLE table_name ADD INDEX IndexName(`字段名`(length)); 2、唯一索引与普通索引相似，只是唯一索引值是唯一的，和主键索引相似，但是唯一索引允许空值。 123CREATE UNIQUE INDEX IndexName ON `table_name`(`字段名`(lenght));#或者ALTER TABLE `table_name` ADD UNIQUE (`字段名`(length)); 3、主键索引不允许有空值，在B+树的InnoDB引擎中，主键索引起到了很重要的作用。 主键索引建表规则是int大于varchar，一般在建表的时候创建。 一般来说都会在首列，不会与其他列冲突，默认会设置成int类型，而且是AUTO_INCREMENT类型。 组合索引一个组合索引包含两个或者两个以上的列。 但是如果一个表中含有多个单例索引不代表是组合索引。 通缩来说：包含多个字段但是只有索引名称。 sql格式 1CREATE INDEX ·索引名称· ON `表名`(`字段1`, `字段2`, `字段3`); 如果创建组合索引，实际包含的是 123(`字段1`)(`字段1`，`字段2`)(`字段1`,`字段2`,`字段3`) 在查询的时候要遵循最左前缀原则，即索引where时，要对照创建时候的字段名顺序进行查询。 使用组合索引时，不能出现单例索引，否则可能会使用单例索引进行查询 全文索引如果文本字段建立的是普通索引，那么只会对字段前面的字符进行索引。 如果出现多个一样的字符，需要查找的话只能进行where column like %xxxx%，但是这样操作只会让索引失效。 所以全文索引就出来了。 1ALTER TABLE `table_name` ADD FULLTEXT(`column1`,`column2`); 有了全文索引，就能检索多个单词记录了。 1SELECT * FROM `table_name` WHERE MATCH(column1, column2) AGAINST(&apos;xxx&apos;, &apos;sss&apos;, &apos;ddd&apos;); 索引操作查询索引1SHOW INDEX FROM `table_name`; 删除索引1DROP INDEX IndexName ON `table_name`; 什么时候不需要创建索引 列很少使用，建立索引会影响整体的性能和增大空间需求。 数据很少的列也不需要创建，比如性别，只有男女。 定义位text和image和bit数据类型的列不应该增加索引。 当update，insert，delete操作远大于检索select操作时不需要，因为需要一直维护索引，会降低性能。 注意 负向条件不能使用索引 前导模糊查询不能用索引，非前导模糊查询可以 数据区分度不大不用使用索引 属性上计算不能命中索引 如果业务大部分是单条查询，使用Hash索引性能更好 单列索引不存null值，组合索引不应该全存null值，不然可能会得到不符合预期的结果集。 组合索引并不是需要一定要和字段顺序一样，mysql查询时会优化查询，比如 (a,b,c)，查询时使用(b,a)，也会优化成击中索引(a，b)。 如果明确知道会返回一条结果，那么使用 limit 1 能够提高效率，原因是告诉mysql不需要再往下查询了。 把计算放到业务层而不是数据库层，除了节省CPU，还会有查询缓存优化的作用。 强制类型转换会进行全表扫描。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUC知识总结]]></title>
    <url>%2F2020%2F07%2F18%2FJUC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JUC知识总结JUC是一个包，全称是java.uitls.current包 整体上包含了这几部分： 原子类 JUC锁 线程池 集合（容器） 原子类 基本类型：AtomicInteger，AtomicLong，AtomicBoolean； 数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray； 引用类型：AtomicReference，AtomicStampedRerference，AtomicMarkableReference； 对象的属性修改类型：AtomicIntegerFieldUpdater，AtomicLongFieldUpdater，AtomicReferenceFieldUpdater； 对指定类的volatile 基本数据类型 进行更新操作 基本原子类介绍 主要是利用CAS（比较并交换） + volatile 和 native方法来保证原子操作，避免了synchronized的高开销，执行效率提高。 CAS是无锁算法，原理是拿内存值和旧的期望值比较，如果相同，那么就把旧的期望值更新成新的期望值，是基于UnSafe类实现的，使用Unsafe类提供的obejctFIeldOffset()方法来获取”原来的值“的内存地址，返回值是valueOffset，而旧的期望值用volatile修饰，可以保证JVM在任何时刻都能保证线程获取到最新的值。 基本原子类： AtomicInteger：整形原子类 AtomicLong：长整型原子类 AtomicBoolean ：布尔型原子类 以AtomicInteger举例： 常用的几个方法： 1234567public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 多线程环境下不需要使用锁来保证线程安全，使用的Unsafe类的方法，但是Unsafe类的方法可以操作内存，而直接操作内存不会被GC掉，所以会造成内存泄漏等情况。 数组类型原子类介绍使用原子类型的方法来更新数组内容 数组类型原子类： AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray ：引用类型数组原子类 以AtomicIntegerArray举例： 1234567public final int get(int i) //获取 index=i 位置元素的值public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValuepublic final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减public final int getAndAdd(int delta) //获取 index=i 位置元素的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值 引用类型原子类介绍基本类型原子类每次都只能操作一个值，如果同时想要操作多个值的话就需要使用引用类型原子类。 引用类型原子类： AtomicReference：引用类型原子类 AtomicStampedRerence：原子更新引用类型里的字段原子类 AtomicMarkableReference ：原子更新带有标记位的引用类型 方法都和前面的差不多，只是参数少许有些变化。 对象的属性修改类型原子类如果要原子更新一个类中某个字段的话需要使用这个类。 对象的属性修改类型原子类： AtomicIntegerFieldUpdater:原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 想要原子更新对象属性的话，需要两个步骤： 1、对象的属性修改类型原子类都是抽象类，所以需要使用静态方法new Updater()创建一个更新器，并且需要设置更新的类和属性。 2、需要更新的对象属性必须使用public volatile关键字修饰。 JUC锁相比较synchronized同步锁来说，JUC包中的锁更加强大，使锁的操作使用起来更加灵活。 锁的框架图 如果想要详细了解每个锁的作用，请跳转至 ———– 线程池概念线程池是管理线程的池子。 作用： 帮我们管理线程，避免增加或者销毁线程带来的损耗。因为线程也是一个对象，创建也是需要进行类加载机制，销毁也是要被GC的，所以可以避免这些过程，从而避免损耗。 提高响应速度。从一个池子里获取线程相对重新创建一个线程效率要好一点。 重复利用。不需要销毁和创建，每次用完就放回池子里。 创建1234public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 各参数作用： corePoolSize： 线程池核心线程数最大值 maximumPoolSize： 线程池最大线程数大小 keepAliveTime： 线程池中非核心线程空闲的存活时间大小 unit： 线程空闲存活时间单位 workQueue： 存放任务的阻塞队列 threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。 handler： 线城池的饱和策略事件，主要有四种类型。 任务执行的过程 提交一个任务，如果核心线程池没有满，就创建一个核心线程去执行任务 如果核心线程池满了，先把任务放进任务队列workQueue排队等待执行。 如果任务队列也满了，判断线程池线程有没有到线程池最大值，如果没有，就创建非核心线程执行任务。 如果线程池也到了最大值，还有新任务的话，就采用拒绝策略拒绝掉。 四种拒绝策略 AbortPolicy(抛出一个异常，默认的) DiscardPolicy(直接丢弃任务) DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池） CallerRunsPolicy（交给线程池调用所在的线程进行处理) 遇到异常怎么做1、直接try...catch捕获。 2、通过Future对象的get方法接收抛出的异常，再处理 3、为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常 4、重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用 线程池工作队列 ArrayBlockingQueue（有界队列） ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，按FIFO排序量 LinkedBlockingQueue（可设置容量队列） 基于链表结构的阻塞队列，按FIFO排序任务，容量可以自己设置，如果不设置，就会是无界阻塞队列，最大值是Integer.MAX_VALUE，吞吐量比ArrayBlockingQUeue要高，newFixedThreadPool线程池使用这个队列。 DelayQueue（延迟队列） 是一个任务定时周期的延迟执行队列，根据指定的执行时间从小到大排序，否则根据插入到队列的先后顺序排序。 newScheduledThreadPool线程池使用了这个队列。 PriorityBlockingQueue（优先级队列） 具有优先级的无界阻塞队列 SynchronousQueue（同步队列） 一个不存储元素的阻塞队列，每个插入动作必须等到另一个线程调用移除操作之后，否则插入操作一直处于阻塞状态，吞吐量高于LinkedBlockingQueue，newCachedThreadPool线程池使用这个队列。 几种常用的线程池 newFixedThreadPool (固定数目线程的线程池) FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务 newCachedThreadPool(可缓存线程的线程池) 用于并发执行大量短期的小任务。 newSingleThreadExecutor(单线程的线程池) 适用于串行执行任务的场景，一个任务一个任务地执行。 newScheduledThreadPool(定时及周期执行的线程池) 周期性执行任务的场景，需要限制线程数量的场景 使用无界的阻塞队列会导致OOMnewFixedThreadPool使用无界的LinkedBlockingQueue，如果线程获取一个任务后，任务执行时间特别长，就会越积越多，最后导致OOM。 线程池状态线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。 RUNNING 该状态的线程池会接收新任务，并处理阻塞队列中的任务; 调用线程池的shutdown()方法，可以切换到SHUTDOWN状态; 调用线程池的shutdownNow()方法，可以切换到STOP状态; SHUTDOWN 该状态的线程池不会接收新任务，但会处理阻塞队列中的任务； 队列为空，并且线程池中执行的任务也为空,进入TIDYING状态; STOP 该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务； 线程池中执行的任务为空,进入TIDYING状态; TIDYING 该状态表明所有的任务已经运行终止，记录的任务数量为0。 terminated()执行完毕，进入TERMINATED状态 TERMINATED 该状态表示线程池彻底终止 参考来自：https://zhuanlan.zhihu.com/p/73990200 集合（容器）集合包含以下几种： List和Set Map 延伸内容 List和Set常用的有CopyOnWriteArrayList, CopyOnWriteArraySet和ConcurrentSkipListSet CopyOnWriteArrayList1、相当于线程安全的ArrayList 2、这个容器一般很小，而且只读操作远远多于可变操作，需要遍历期间防止线程间的冲突 3、如果对数组进行修改的话，通常会复制整个基本数组，所以可变操作(add()，set()，remove())通常开销很大。 4、迭代器支持hasNext(),next()等不可变操作，但是不支持remove()操作。 5、迭代器遍历很快，而且基于数组快照，不会与其他线程产生冲突。 5、本质上使用的是互斥锁，即读写不能同时存在。 6、是一个动态数组，底层使用的是volatile修饰的数组，每次进行增删改操作时，都会新建一个数组，然后赋值给volatile修饰的数组，因此效率贼低，但是遍历操作效率很高。 7、线程安全，因为每次修改时，都会拿到一个互斥锁，修改完毕后，释放锁，保证了线程安全。 CopyOnWriteArraySet1、相当于线程安全的HashSet。 2、HashSet底层是一个散列表(HashMap)，而CopyOnWriteArraySet底层是CopyOnWriteArrayList。 3、所有特性都和CopyOnWriteArrayList差不多，也是由volatile和互斥锁实现的。 4、不允许重复，通过addIfAbsent()和addAllAbsent()方法实现添加功能，并且仅当数据不存在时才添加。 ConcurrentSkipListSet1、相当于线程安全的TreeSet 2、其他和上面类似。 MapConcurrentHashMap ConcurrentHashMap是一个线程安全的哈希表，在jdk1.8之前都是通过锁分段来实现的，底层有Segment数组和Entry数组实现，Segment是一种可重入锁ReentrantLock，用于锁住每一段的数据，而Entry存放的是键值对数据，两者都是由数组加链表的结构组成。 锁分段技术是将数据分成一段一段的存储，然后每一段数据分配一把锁，当一个线程占用锁访问其中一个段数据时，其他数据也能同时被访问，这就大大提高了性能，但是有的方法需要跨段，比如size()和containsValue()，这时候就需要按顺序锁住所有段，操作完成后，再依次按顺序释放所有段，如果顺序混乱就可能出现死锁现象。 但是在1.8之后就抛弃了Segment锁分段机制，采用了CAS+synchronized来保证并发的安全性。 数组结构则是：数组+链表+红黑树。 HashMap在1.8之前用的时头插法，put操作会导致CPU达到100%，而1.8之后采用了尾插法，避免了这个问题。 Hashtable和ConcurrentHashMap区别 Hashtable时阻塞的，使用的是一个全局锁来保证线程安全，同一时刻只能有一个线程获取锁，其他线程都得等待，虽然能保证并发安全，但是也导致容器使用起来效率极低，但是好处是总是能获取到最新的更新信息。 ConcurrentHashMap（1.8之前）是非阻塞的，在更新时候会局部锁住一部分数据，不会把整个表锁住，效率很高，但是读取操作不能保证反应最近的更新。如果A线程putAll操作写入大量数据，B线程要调用get读取，那么只能get到目前为止已经顺利插入的部分数据。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程之间的通信]]></title>
    <url>%2F2020%2F07%2F18%2F%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[线程之间的通信解决开发中遇到线程A执行完成后通知线程B的问题 有以下几种方法： 等待通知机制 join()方法 volatile共享内存 CountDownLatch 并发工具 CyclicBarrier 并发工具 线程响应中断 线程池 awaitTermination() 方法 管道通信 1、等待通知机制java中比较经典的线程通信方式 两个线程对同一对象调用wait()和notify()方法来进行通信 例如两个线程交替打印奇偶数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/18 10:02 * @FileName: ThreadCommunicationDemo */public class ThreadCommunicationDemo &#123; public static int i = 1; //是否时奇数 public static boolean flag = true; public static void main(String[] args) &#123; ThreadCommunicationDemo threadCommunicationDemo = new ThreadCommunicationDemo(); Thread t1 = new Thread(new OddNumber(),"A"); Thread t2 = new Thread(new EvenNumber(),"B"); t1.start(); t2.start(); &#125; /** * 奇数线程 */ public static class OddNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(flag)&#123; System.out.println(Thread.currentThread().getName()+": "+i); i++; flag = false; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //阻塞线程 释放锁 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; /** * 偶数线程 */ public static class EvenNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(!flag)&#123; System.out.println(Thread.currentThread().getName()+": "+i); i++; flag = true; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //释放锁同时进行阻塞 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/18 10:02 * @FileName: ThreadCommunicationDemo */public class ThreadCommunicationDemo &#123; public static int i = 1; //是否时奇数 public static boolean flag = true; public static void main(String[] args) &#123; ThreadCommunicationDemo threadCommunicationDemo = new ThreadCommunicationDemo(); Thread t1 = new Thread(new OddNumber(),"A"); Thread t2 = new Thread(new EvenNumber(),"B"); t1.start(); t2.start(); &#125; /** * 奇数线程 */ public static class OddNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(flag)&#123; System.out.println(Thread.currentThread().getName()+": "+i); i++; flag = false; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //阻塞线程 释放锁 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; /** * 偶数线程 */ public static class EvenNumber implements Runnable&#123; @Override public void run() &#123; while(i&lt;=100)&#123; synchronized (ThreadCommunicationDemo.class)&#123; if(!flag)&#123; System.out.println(Thread.currentThread().getName()+": "+i); i++; flag = true; //唤醒当前线程 ThreadCommunicationDemo.class.notify(); &#125;else&#123; try &#123; //释放锁同时进行阻塞 ThreadCommunicationDemo.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 解释： A，B线程都使用ThreadCommunicationDemo.class作为锁，A线程调用wait()方法释放锁，进入waiting状态，B线程调用notify()方法，A线程收到通知后就可以从wait()方法进行返回了。 注意： wait()、notify()、notifyAll()、调用的前提是获得对象的锁 调用wait()方法后线程会释放锁，进入waiting状态，线程也会被移入等待队列中。 调用notify()方法会将等待队列移动到同步队列，线程状态也会被更新成blocked状态 从wait()方法返回的前提是调用notify()方法的线程获得锁，wait()方法的线程释放锁。 经典范式 线程 A 作为消费者： 获取对象的锁。 进入 while(判断条件)，并调用 wait() 方法。 当条件满足跳出循环执行具体处理逻辑。 线程 B 作为生产者: 获取对象锁。 更改与线程 A 共用的判断条件。 调用 notify() 方法。 1234567891011121314151617/*** 伪代码*///Thread Asynchronized(Object)&#123; while(条件)&#123; Object.wait(); &#125; //do something&#125;//Thread Bsynchronized(Object)&#123; 条件=false;//改变条件 Object.notify();&#125; 2、join()方法123456789101112131415161718192021222324252627282930313233package org.example.thread;/** * @Author: wys * @Description: * @Date: 2020/7/18 16:19 * @FileName: JoinDemo */public class JoinDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"执行完毕"); &#125; &#125;,"A"); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"执行完毕"); &#125; &#125;,"B"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println("线程完毕"); &#125;&#125; 结果 123B执行完毕A执行完毕线程完毕 t1 会阻塞 至 t1 结束，最终主线程会等待 t1 和 t2 执行完毕。 join的核心逻辑 123while (isAlive()) &#123; wait(0);&#125; join线程完成后会调用 notifyAll方法，在JVM中实现 3、volatile共享内存1234567891011121314151617181920212223242526272829303132333435package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/18 17:25 * @FileName: VolatileDemo */public class VolatileDemo &#123; public static volatile boolean flag = true; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; while(flag)&#123; System.out.println(Thread.currentThread().getName()+"执行ing"); &#125; System.out.println("执行结束"); &#125;,"A").start(); new Thread(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(1); stopThread(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;,"B").start(); &#125; public static void stopThread()&#123; flag = false; &#125;&#125; 利用volatile的可见性对所有线程进行通知 3、CountDownLatch 并发工具​ Await()等待，countDown()计数，当count清零时，唤醒线程 123456789101112131415161718192021222324252627282930313233343536373839/** * @Author: wys * @Description: 5s后线程B通知结束线程A * @Date: 2020/7/18 17:50 * @FileName: CountDownLatch */public class CountDownLatchDemo &#123; private static int count = 0; private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) &#123; new Thread(()-&gt;&#123; System.out.println("线程"+Thread.currentThread().getName()+"开始执行"); if(count!=5)&#123; try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+"执行结束"); &#125;,"A").start(); new Thread(()-&gt;&#123; for(int i=0;i&lt;5;i++)&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count++; &#125; if(count == 5)&#123; countDownLatch.countDown(); &#125; &#125;,"B").start(); &#125;&#125; 4、CyclicBarrier并发工具等待线程全部准备完毕，然后统一开始启动 12345678910111213141516171819202122232425262728293031323334353637383940package org.example.thread;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * @Author: wys * @Description: * @Date: 2020/7/21 9:42 * @FileName: CyclicBarrierDemo */public class CyclicBarrierDemo &#123; private CyclicBarrier cyclicBarrier = new CyclicBarrier(3); public static void main(String[] args) &#123; CyclicBarrierDemo demo = new CyclicBarrierDemo(); new Thread(()-&gt;&#123;demo.threadStarted();&#125;,"A").start(); new Thread(()-&gt;&#123;demo.threadStarted();&#125;,"B").start(); new Thread(()-&gt;&#123;demo.threadStarted();&#125;,"C").start(); &#125; public void threadStarted() &#123; System.out.println(Thread.currentThread().getName()+"正在准备启动！"); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"启动完毕"); &#125;&#125; 5、线程中断响应12345678910111213141516171819202122232425262728293031package org.example.thread;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/21 10:30 * @FileName: StopThreadDemo */public class StopThreadDemo &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println(Thread.currentThread().getName()+"运行中"); &#125; System.out.println(Thread.currentThread().getName()+"已结束"); &#125;,"A"); t1.start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t1.interrupt(); &#125;&#125; 使用isInterrupted()方法来判断线程有没有被中断 其他线程中使用interrupt()方法来通知其他线程进行中断响应 原理是interrupt()方法将线程中某个标志位改了，默认是true， 如果遇到但是如果抛出了InterruptedException 异常，该标志就会被 JVM 重置为 false。 6、线程池 awaitTermination() 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package org.example.thread;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/21 10:45 * @FileName: ThreadPoolExecutorDemo */public class ThreadPoolExecutorDemo &#123; public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(); ThreadPoolExecutor pool = new ThreadPoolExecutor(5,5,1, TimeUnit.MILLISECONDS,queue); pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"running"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); pool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+"running"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); pool.shutdown(); while(!pool.awaitTermination(1,TimeUnit.SECONDS))&#123; System.out.println("线程在执行ing"); &#125; System.out.println("主线程结束"); &#125;&#125; 如果使用线程池，可以让主线程等待所有线程执行完毕。 使用awaitTermination()这个方法的前提是关闭线程池，如调用shutdown()方法等。 调用结束方法后，线程池不会接受新的任务，而是会平滑的关闭各个线程池中的已有的任务。 7、管道通信1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package org.example.thread;import java.io.IOException;import java.io.PipedReader;import java.io.PipedWriter;import java.util.concurrent.TimeUnit;/** * @Author: wys * @Description: * @Date: 2020/7/21 10:56 * @FileName: PipeDemo */public class PipeDemo &#123; public static void main(String[] args) throws IOException &#123; PipedWriter writer = new PipedWriter(); PipedReader reader = new PipedReader(); //建立连接 writer.connect(reader); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+"running"); try &#123; for(int i=0;i&lt;10;i++)&#123; writer.write(i+""); TimeUnit.SECONDS.sleep(1); writer.flush(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,"A").start(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+"running"); int msg = 0; try&#123; while((msg = reader.read())!=-1)&#123; System.out.println("msg = "+(char)msg); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,"B").start(); &#125;&#125; 管道通信，首先先建立连接，然后在通信，相当于生产者和消费者。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机知识点]]></title>
    <url>%2F2020%2F07%2F11%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[JVM虚拟机知识点运行时数据区运行时数据区就是jvm运行java文件时，会把管理的内存分为好几个部分，每一个部分就是一个运行时数据区。 结构图 线程共享的区域方法区：存放类信息，静态变量，常量，运行时常量池 的区域 堆：几乎所有的对象存放的地方，同时也是GC的主要区域 ​ 数组也存放在堆中 分代处理：目的是为了更好的回收内存和分配内存 新生代：Eden空间，From Survivor空间，To Survivor空间 老年代：存活周期特别长的对象 空间结构：逻辑连续，物理不连续 TLAB（线程本地分配缓存）：线程私有，空间小，避免同步带来的效率问题，从而提高分配效率 OOM：内存没有办法分配，堆也无法扩展，就会报出OOM异常 ​ 扩展：一般用逃逸分析法来判断对象是否分配在堆中或者是栈中，如果一个对象是随着方法的运行而出现，方法结束，对象也结束的话，就可以认为这个对象没有逃逸出方法，因此会分配在栈中 线程私有的区域栈： 生命周期与线程相同 描述的java方法执行的内存模型 栈帧：每执行一个方法就装入一个栈帧，每运行一个方法弹出 局部变量表：基本单位是变量槽，一个变量槽是四字节，如果遇到大于四字节的变量，就需要分成多部份来装。 基本数据类型 对象句柄 方法参数 方法的局部变量 操作数栈 动态链接 方法返回地址 …… 可能产生的异常：OutofMemoryError，StackOverflowError 本地方法栈：为navice方法服务 程序计数器：就是字节码执行的指令行号，如果是native方法就为空 对象创建从JVM角度来说： 检查类是否被加载 为对象分配内存空间 初始化对象字段 设置对象头 对象头 MarkWork：记录了对象和锁有关的信息 指向类的指针： 数组长度： 执行构造方法 对象访问定位句柄如果使用句柄访问的话，那么Java堆中将会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象的实例数据与类型数据各自的具体地址信息。 指针如果使用指针访问访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。 类加载机制类的生命周期 加载1、通过全限定类名获取此类的二进制字节流 2、将字节流所代表的静态存储结构转换为方法去的运行时数据结构 3、在内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口 加载阶段是可控性最强的，可以重写loadClass()方法，数组类型不通过类加载器加载，而是由虚拟机直接创建的。 加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就开始了 验证 准备这个阶段是为了给类变量分配内存并且设置初始值的阶段，内存都在 方法区中分配 1、这个阶段进行内存分配的仅包括类变量，而不包括实例变量，实例变量会在对象实例化的时候跟着对象一起分配到java堆中。 2、初始值默认都是0或者是null，如果用final修饰的话，初始值可以指定成想要的样子。 解析这个阶段是把符号引用解析成直接引用的过程，解析动作主要针对 接口、字段、类方法、接口方法、方法类型、方法句柄、调用限定符等7类符号引用进行： 符号引用：就是用一组符号描述目标，可以是任意字面量。 直接引用：只有符号引用是不够的，还需要明确知道方法所在的位置，java虚拟机存在一个方法表，调用类方法是，只需要根据符号引用找到方法表中偏移量就能直接调用该方法。 总的来说，解析过程就是把符号引用替换成直接引用的过程，也就是获得方法、字段指针或者偏移量的过程。 初始化初始化是类加载的最后一步，也就是执行字节码，初始化过程是执行类构造器&lt;clinit&gt;() 方法的过程。 &lt;clinit&gt;()自带锁，线程安全，并且可能会造成死锁，而且这种死锁很难被发现 初始化阶段，有五种情况，必须对类进行初始化： 第一种情况： 当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。 当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。 当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。 当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。 使用java.lang.reflect包的方法对类进行反射调用，例如Class.forname()，newInstance()等等情况下，如果没有初始化，就会触发初始化。 初始化一个类的时候，父类没初始化，先初始化父类 虚拟机启动时，先初始化用户必须定义的主类 MethodHandle和VarHandle可以看作轻量级反射调用机制，而想要使用这两个调用就必须先使用findStaticVarHandle来初始化调用的类 JDK8新加入默认方法，被default关键字修饰接口方法时，如果这个实现类发生了初始化，接口要在其之前被初始化。 卸载卸载表示这个类的Class对象被GC 卸载类需要满足三个条件： 1、该类的所有实例对象都被GC。也就是堆里面没有这个对象， 2、该类没有在其他任何地方被引用 3、该类的类加载器的实例已被GC 自定义类的加载器可能被卸载，但是jdk自带的类加载器不会被卸载，比如 BootstrapClassLoader，PlatformClassstrapClassLoader，AppClassLoader，肯定不会被回收，因此使用我们自定义加载器加载的类是可以被卸载的。 垃圾回收JVM内存分配与回收java自动内存管理主要是针对对象内存的回收和对象内存的分配。 堆是垃圾收集器主要管理的地方。因此也被称为GC堆。 JAVA堆的结构 分为 新生代：Eden，From Survivor0，To Survivo1，老年代：Old Memeory 进一步划分的目的 是为了更好的回收和分配内存 常见的分配策略GC之后，Eden区和幸存区都被清空， from 和 to 交换角色，不管怎么样都要保证to的幸存区为空， to 被填满后，会将所有对象移动到老年代中。 分代回收算法新生代和老年代有着不同的回收算法，根据每个区域的特点不同选择合适的垃圾收集算法， 一般情况下，对象在eden区分配，当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 新生代GC（Minor GC）：指发生新生代的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快 老年代GC（Major GC/Full GC）：只发生在老年代GC，出现Major GC经常会伴随至少一次的 Minor GC（不一定），Major GC的速度一半回避Minor GC慢10倍以上。 12345678public class Test08 &#123; public static void main(String[] args) &#123; byte[] a,b; a = new byte[30900*1024]; b = new byte[30900*1024]; &#125; 老年代大对象是需要大量连续内存空间的对象（比如：字符串，数组等） 原因是为了避免分配内存时，分配担保机制带来的复制而降低效率。 长期存活的对象进入老年代，在eden出生并经过1次存活后，会进入到幸存区，在幸存区经过多次存活（默认是15次），就会进入老年代。 可以通过-XX:MaxTenuringThreshold进行设置 对象存活堆中几乎存放着所有的对象实例，对堆垃圾回收之前必须要先判断是否存活 引用计数法给每个对象实例添加一个引用计数器，引用时加1，引用失效时减一，当计数器为0时，就判断这个对象已经不再使用，就回收掉。 这种方法实现简单，效率高，但是目前主流的虚拟机并没有用这种方法，主要是没办法解决循环引用问题。 123456789101112public class Test09 &#123; Object instance = null; public static void main(String[] args) &#123; Test09 t1 = new Test09(); Test09 t2 = new Test09(); t1.instance = t2; t2.instance = t1; t1 = null; t2 = null; &#125;&#125; 可达性分析思想就是通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象不可用。 可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 本地方法栈（Native方法）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 四种引用类型 强引用 最普遍的引用，垃圾回收器绝不会回收它，当内存空间不足，jvm宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会考随意回收。 软引用 可有可无，内存足够就不回收，内存不够就会回收 弱引用 可有可无，这个生命周期特别短，如果垃圾回收器发现了它，不管内存够不够，都会回收。但是垃圾回收器优先级很低，不一定很快就发现。 虚引用 与其他几种不同，这个不会决定对象的生命周期，如果一个对象持有虚引用，那么在任何时候都有可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 与其他几种引用的区别：回收一个对象前，发现它还有虚引用，就会在回收对象内存之前，把它加入到引用队列，可以在内存回收之前来对这个对象进行操作 使用软引用情况多，软引用可以加速JVM对垃圾的回收速度，客户以维护系统的运行安全，防止内存溢出等问题的发生。 不可达对象不一定会被GC掉要宣告一个对象死亡必须经过两次标记，第一次标记的时候只是判断是否有必要执行finalize方法，当对象没有覆盖finalize方法，或者finalize方法已经被调用过时，就没必要GC掉，除非第二次GC时候还是没有和引用链有关联。 怎么判断一个常量是废弃常量当常量池中存在的字符串“abc”没有任何对象引用的时候，就说明它是废弃常量，下次GC，就会回收掉。 垃圾收集算法 标记-清除算法 复制算法 标记-整理算法 分代收集算法 标记-清除算法就是标记和清除阶段，首先比较出所有需要回收的对象，都打上标记，再进行清除 会造成两种问题： 效率问题 空间问题（标记清除后会产生大量不连续的碎片） 复制算法为了解决这个效率问题，就出现了复制算法，将内存分为大小相同的两部分，每次就只用一半，用完就清理掉，然后把剩下的放到另一块中。 空间问题（花销太大） 标记-整理算法过程和标记清除算法一样，后面会增加一个整理过程。 效率问题很大 分代收集算法就是把堆分为新生代和老年代，然后根据不同的特点进行不同的算法。 为什么要分为新生代和老年代？因为每个对象的存活时间不一样，有的特别长，有的特别短，因此需要用不同的分区来进行分别管理。 为什么要用两个Survivor？因为要管理内存碎片，而其中对象存活时间一般很短，用复制算法比较有效率 垃圾收集器 Serial收集器 ParNew收集器 Parallel Scavenge收集器 CMS收集器 G1收集器 如果说收集算法是理论，那么这个垃圾收集器就是内存回收的具体实现。 我们需要根据具体应用场景选择合适自己的垃圾收集器 Serial收集器很古老的收集齐了，历史悠久，他是个单线程垃圾收集器，收集垃圾的时候还必须暂停其他所有的工作进程，直到他收集完成。 新生代采用复制算法，老年代采用标记整理算法。 ParNew收集器就是Serial收集器的多线程版本，除了使用多线程收集垃圾外，其余行为和Serial收集器完全一样。 但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。 新生代采用复制算法，老年代采用标记-整理算法 只有这个收集器能与CMS收集器配合工作 Parallel Scavenge收集器Parallel Scavenge收集器也是使用复制算法的多线程收集器，他看上去几乎和ParNew一样。 123-XX:+UseParallelGC //使用Parallel 收集器 + 老年代串行-XX:+UseParallelOldGC //使用Parallel收集器 + 老年代并行 Parallel Scavenge收集器 关注点是吞吐量（高效率的利用CPU）。 CMS等垃圾收集器的关注点更多的是用户现成的停顿时间（提高用户体验）。 所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 新生代采用复制算法，老年代采用标记-整理算法 Serial Old收集器Serial收集器的老年代版本 jdk1.5版本之前和Parallel Old 搭配使用 作为CMS收集器的后备方案 Parallel Old收集Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”，注重吞吐量以及CPU资源，可以优先考虑。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对 CPU 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 G1收集器G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 空间整合：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。 G1 收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis缓存穿透，缓存击穿，缓存雪崩]]></title>
    <url>%2F2020%2F07%2F10%2Fredis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%2F</url>
    <content type="text"><![CDATA[Redis缓存穿透，缓存击穿，缓存雪崩介绍 缓存穿透：key对应的数据源不存在，每次针对这个key的请求从缓存中获取不到，请求都会到数据源，从而可能压垮数据源。比如使用一个数据库和redis都不存在的用户id获取该用户信息，若有人利用此漏洞进行攻击，可能会压垮数据库。 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并缓存在redis中，这时候大并发请求可能瞬间会把后端DB压垮。 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，也会给后端DB带来很大压力。 解决方案缓存穿透解决方案最常用的就是布隆过滤器，将所有可能的数据hash到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免s对底层存储系统的查询压力。 其次，还有一个更简单的方法，如果一个查询返回的数据为空，仍然把这个空结果缓存下在，但是时间很短，最长不超过5分钟。 123456789101112131415161718192021222324//伪代码public object GetProductListNew() &#123; int cacheTime = 30; String cacheKey = "product_list"; String cacheValue = CacheHelper.Get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; cacheValue = CacheHelper.Get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; else &#123; //数据库查询不到，为空 cacheValue = GetProductListFromDB(); if (cacheValue == null) &#123; //如果发现为空，设置个默认值，也缓存起来 cacheValue = string.Empty; &#125; CacheHelper.Add(cacheKey, cacheValue, cacheTime); return cacheValue; &#125;&#125; 缓存击穿解决方案key可能会在某些时间段被超高并发的去访问，是一种非常“热点”的数据。这时候，需要考虑的到缓存击穿。 使用互斥锁(mutex key) 常用的做法，简单来说，就是在缓存时效的时候，不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，在进行load db的操作并回设缓存；否则就重试整个get缓存的方法。00 setnx当键key不存在的情况下，将键的key值设置为value，若已经存在就不做任何操作 12345678910111213141516public String get(key) &#123; String value = redis.get(key); if (value == null) &#123; //代表缓存值过期 //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db if (redis.setnx(key_mutex, 1, 3 * 60) == 1) &#123; //代表设置成功 value = db.get(key); redis.set(key, value, expire_secs); redis.del(key_mutex); &#125; else &#123; //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可 sleep(50); get(key); //重试 &#125; &#125; else &#123; return value; &#125; &#125; 缓存雪崩解决方案这个对底层系统的冲击特别可怕，大多数设计者都是通过加锁或者队列的方式来保证不会有大量线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开，在原有的失效时间上增加一个随机值。 1234567891011121314151617181920212223//伪代码public object GetProductListNew() &#123; int cacheTime = 30; String cacheKey = "product_list"; String lockKey = cacheKey; String cacheValue = CacheHelper.get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; else &#123; synchronized(lockKey) &#123; cacheValue = CacheHelper.get(cacheKey); if (cacheValue != null) &#123; return cacheValue; &#125; else &#123; //这里一般是sql查询数据 cacheValue = GetProductListFromDB(); CacheHelper.Add(cacheKey, cacheValue, cacheTime); &#125; &#125; return cacheValue; &#125;&#125; 加锁只是减轻数据库压力，并没有提高系统吞吐量，假设在高并发下，缓存重建期间key是锁着的，来10000个请求，9999个都在阻塞，会导致用户请求超时，治标不治本。 随机值代码： 1234567891011121314151617181920212223//伪代码public object GetProductListNew() &#123; int cacheTime = 30; String cacheKey = "product_list"; //缓存标记 String cacheSign = cacheKey + "_sign"; String sign = CacheHelper.Get(cacheSign); //获取缓存值 String cacheValue = CacheHelper.Get(cacheKey); if (sign != null) &#123; return cacheValue; //未过期，直接返回 &#125; else &#123; CacheHelper.Add(cacheSign, "1", cacheTime); ThreadPool.QueueUserWorkItem((arg) -&gt; &#123; //这里一般是 sql查询数据 cacheValue = GetProductListFromDB(); //日期设缓存时间的2倍，用于脏读 CacheHelper.Add(cacheKey, cacheValue, cacheTime * 2); &#125;); return cacheValue; &#125;&#125; 关于缓存雪崩的解决办法，有三种： 使用锁或队列，不过不建议，会降低用户体验 设置过期标志更新缓存 为key设置不同的缓存失效时间]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者模式]]></title>
    <url>%2F2020%2F07%2F10%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[生产者消费者模式实现方式生产者消费者问题是线程模型中的经典问题；生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。 保证同一时刻只有一个线程读或者写： 用synchronized对存储加锁，然后用object原生的wait()和notify()做同步 用concurrent.locks.Lock，然后用condition的await()和signal()做同步 使用信号量semaphore 保证存储内部的读写唯一 直接使用concurrent.BlockingQueue 使用PipedInputStream/PipedOutputStream synchronized、wait()、nofity() wait()：当缓冲区已满或者为空时，生产者/消费者线程停止自己的执行，放弃锁，让自己处于等待状态，让其他线程执行。 notify()：当生产者/消费者向缓冲区放入/取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 package org.example.test_wys;import java.util.LinkedList;import java.util.Queue;import java.util.Random;/** * @Author: wys * @Description: * @Date: 2020/7/10 16:03 * @FileName: Test_05 */public class Test_05 &#123; static int i = 0; static int size = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); public static void main(String[] args) &#123; Test_05 tt = new Test_05(); tt.new Producter("producter[1]").start(); tt.new Producter("producter[2]").start(); tt.new Consumer("consumer[1]").start(); tt.new Consumer("consumer[2]").start(); tt.new Consumer("consumer[3]").start(); &#125; class Producter extends Thread &#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while (true) &#123; synchronized (queue)&#123; while(queue.size()==size)&#123; System.out.println("满了！"+name+"等待"); try&#123; queue.wait(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(name+" product===&gt;production_"+i); queue.offer("production_"+i); i++; queue.notifyAll(); &#125; try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; synchronized (queue)&#123; while(queue.isEmpty())&#123; System.out.println("空的！"+name+"等待"); try&#123; queue.wait(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; String s = queue.poll(); System.out.println(name+": consume=====&gt;"+s); queue.notifyAll(); &#125; try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Lock、Condition、await()、signal()实现起来和上面一样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package org.example.test_wys;import java.util.LinkedList;import java.util.Queue;import java.util.Random;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author: wys * @Description: * @Date: 2020/7/10 16:31 * @FileName: Test_06 */public class Test_06 &#123; static int i = 0; static int size = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); Lock lock = new ReentrantLock(); //可重入锁 Condition condition = lock.newCondition(); public static void main(String[] args) &#123; Test_06 tt = new Test_06(); tt.new Producter("producter[1]").start(); tt.new Producter("producter[2]").start(); tt.new Consumer("consumer[1]").start(); tt.new Consumer("consumer[2]").start(); tt.new Consumer("consumer[3]").start(); &#125; class Producter extends Thread &#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while (true) &#123; lock.lock(); while(queue.size()==size )&#123; System.out.println("满了！"+name+"等待"); try&#123; condition.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(name+" product===&gt;production_"+i); queue.offer("production_"+i); i++; condition.signalAll();; lock.unlock(); try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; lock.lock(); while(queue.isEmpty())&#123; System.out.println("空的！"+name+"等待"); try&#123; condition.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; String s = queue.poll(); System.out.println(name+": consume=====&gt;"+s); condition.signalAll(); lock.unlock(); try&#123; sleep(new Random().nextInt(1000)); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; BlockingQueue在并发编程中，JUC中有一个接口BlockingQueue，有以下几个实现的阻塞队列： java.util.concurrent.ArrayBlockingQueue java.util.concurrent.LinkedBlockingQueue java.util.concurrent.SynchronousQueue java.util.concurrent.PriorityBlockingQueue 我们可以使用FIFO队列，来实现生产消费者模型 在队列的基础上，使用Lock实现了同步队列，主要是两种方法， put()方法，容量达到最大时，自动阻塞。 take()方法，容量为0时，自动阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * @Author: wys * @Description: 生产者消费者模式 * @Date: 2020/7/10 12:51 * @FileName: Test_04 */public class Test_04 &#123; static int i = 0; static int size = 10; BlockingQueue&lt;String&gt; blockingQueue = new ArrayBlockingQueue&lt;String&gt;(10); public static void main(String[] args) &#123; Test_04 m = new Test_04(); m.new Producter("producter[1]").start(); m.new Producter("producter[2]").start(); m.new Consumer("consumer[1]").start(); m.new Consumer("consumer[2]").start(); m.new Consumer("consumer[3]").start(); &#125; /** * 生产者 */ class Producter extends Thread&#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; try&#123; synchronized(blockingQueue) &#123; blockingQueue.put("producter_"+i); System.out.println(name+" product =====&gt; production_"+i); i++; &#125; sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 消费者 */ class Consumer extends Thread&#123; private String name; public Consumer(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while(true) &#123; try&#123; System.out.println(name+" consumer ====&gt;"+blockingQueue.take()); sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; SemaphoreSemaphore信号量，可以控制对互斥资源的访问的线程数。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Main &#123; int i = 0; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); Semaphore notFull = new Semaphore(10);//可以生产的数量，生产一个少一个 permit Semaphore notEmpty = new Semaphore(0);//可以消费的数量，消费一个多一个 permit Semaphore mutex = new Semaphore(1);//控制 queue 的互斥访问 //生产者 class Producter extends Thread&#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; notFull.acquire(); mutex.acquire(); queue.offer("production_"+i); System.out.println(name+"：product====&gt;production_"+i); i++; mutex.release(); notEmpty.release(); sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; notEmpty.acquire(); mutex.acquire(); String s = queue.poll(); System.out.println(name+"：consume====&gt;"+s); mutex.release(); notFull.release(); sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Main main = new Main(); main.new Producter("producter[1]").start(); main.new Producter("producter[2]").start(); main.new Consumer("consumer[1]").start(); main.new Consumer("consumer[2]").start(); main.new Consumer("consumer[3]").start(); &#125; &#125; PipedInputStream、PipedOutputStream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Main &#123; static int i = 0; static int size = 10; PipedInputStream pis = new PipedInputStream(size); PipedOutputStream pos = new PipedOutputStream(); &#123; try &#123; pis.connect(pos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Main main = new Main(); main.new Producter("producter[1]").start(); main.new Producter("producter[2]").start(); main.new Consumer("consumer[1]").start(); main.new Consumer("consumer[2]").start(); main.new Consumer("consumer[3]").start(); &#125; //生产者 class Producter extends Thread&#123; private String name; public Producter(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; synchronized (pos) &#123;//避免产生相同名称的产品，如果不在意可以去掉 pos.write(i); pos.flush(); System.out.println(name+"：product====&gt;production_"+i); i++; &#125; sleep(new Random().nextInt(1000)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //消费者 class Consumer extends Thread&#123; private String name; public Consumer(String name) &#123; this.name = name; &#125; @Override public void run() &#123; while(true)&#123; try &#123; System.out.println(name+"：consume====&gt;production_"+pis.read()); sleep(new Random().nextInt(3500)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo基础]]></title>
    <url>%2F2020%2F07%2F09%2Fdubbo%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Dubbo基础介绍Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。 dubbo是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。 使用 Dubbo 可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。 Dubbo通信协议Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。 反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低 与spring cloud区别 协议支持类型 dubbo://（推荐） rmi:// hessian:// http:// webservice:// thrift:// memcached:// redis:// rest:// 需要web容器吗不需要，如果硬要用 Web 容器，只会增加复杂性，也浪费资源。 内置了几种服务容器 Spring Container Jetty Container Log4j Container Dubbo 的服务容器只是一个简单的 Main 方法，并加载一个简单的 Spring 容器，用于暴露服务。 节点角色 流程图 注册中心推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。 配置方式1）Spring 配置方式2）Java API 配置方式 Dubbo启动时如果依赖的服务不可用会怎样？Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=”true”，可以通过 check=”false” 关闭检查。 Dubbo支持服务多协议吗？Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。 当一个服务接口有多种实现时怎么做？当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。 Dubbo优点 透明的远程化调用，就像调用本地方法一样调用远程方法，只需要简单的配置，没有任何api侵入 软负载均衡及容错机制 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 Dubbo服务暴露过程 1) 暴露服务到本地 2) 暴露服务到远程 3) 启动netty服务 4) 连接zookeeper 5) 注册服务到zookeeper 6) 监听zookeeper中消费服务]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何开始阅读框架源码？]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E9%98%85%E8%AF%BB%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如何开始阅读框架源码？ 1、首先学习阅读中所需要的基础的知识 2、要带着目的去阅读 3、看一看官方文档 4、要学会使用这个框架 5、了解整体模块架构设计 6、从高到底梳理每一个模块 7、一直到可以运行起来 1、基础知识在学习某种框架之前，一定要确保自己掌握了部分基础知识，例如这个java基础，设计模式等等，确保自己能够理解这个框架最深层所隐藏的知识或者技术。 2、确定目的一定要清楚自己阅读源码是为了干什么，是为了解决工作中出现的问题，还是为了学习框架的中所蕴含的知识，亦或是想了解这个框架所需要应用的业务场景。 3、官方文档官方文档很重要，它能让你对这个框架有个大概的了解，以及每个模块的各个作用与联系，之后再把整体框架架构。 4、学会使用了解一下这个框架的基本用法，官网都应该有 Quick Start，先运行运行demo，再测试一些其他高级功能，知道这个框架究竟是怎么使用的。 5、框架架构了解框架的设计模式，和设计思路，然后思考思考去猜一猜这样写有什么用，之后顺着思路往下走。 6、从顶至下学框架一定要从上往下分析各个模块的作用和功能，分清各个主次关系，理清逻辑。 7、运行起来最后一点一点的运行出来，至此，大概就可以很大程度上的去理解这个框架的思想。 8、不懂就问如果遇到不明白的地方，可以去各个论坛，各个帖子去百度，去询问，也可以去查看官方文档，把搞懂，才能受益匪浅。]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发基础知识点]]></title>
    <url>%2F2020%2F07%2F01%2F%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[并发基础知识点并发和并行 并发是多个事件在同一时刻，并行是多个事件在同一时间段 并行是多个实体的多个事件，并发是一个实体的多个事件 并行不会抢占资源，并发会抢占资源 线程和进程进程进程就是程序的一次执行过程，是系统运行的基本单位。 比如运行一次java程序，实际上就是启动了一次jvm进程 而main函数其实就是这个进程中的一个线程，也成为主线程。 进程进程和线程相似，但是线程是比进程更小的执行单位。 一个进程可以产生多个线程。 同类的多个线程共享进程的堆和方法区资源。 每个线程有自己的程序计数器、虚拟机栈、本地方法栈。 各个线程之间切换工作时负担比进程小，因此线程也被称为轻量级进程。 查看线程信息： 123456789101112131415161718192021package org.example.thread;import java.lang.management.ManagementFactory;import java.lang.management.ThreadInfo;import java.lang.management.ThreadMXBean;/** * @Author: wys * @Description: * @Date: 2020/7/17 10:26 * @FileName: ThreadInfoDemo */public class ThreadInfoDemo &#123; public static void main(String[] args) &#123; ThreadMXBean thread = ManagementFactory.getThreadMXBean(); ThreadInfo[] threadInfos = thread.dumpAllThreads(false,false); for(ThreadInfo i : threadInfos)&#123; System.out.println("ID:"+i.getThreadId()+",Name:"+i.getThreadName()); &#125; &#125;&#125; 123456ID:6,Name:Monitor Ctrl-BreakID:5,Name:Attach ListenerID:4,Name:Signal DispatcherID:3,Name:FinalizerID:2,Name:Reference HandlerID:1,Name:main 线程与进程的关系线程在JVM中的模型 线程的分类用户线程：程序中创建的线程 守护线程：为用户线程提供服务的线程，一般用户线程结束时才被终止，如JVM的垃圾回收 通过Thread.setDaemon(true)方法将用户进程变成守护进程。 线程周期和状态线程的生命周期 线程的状态 图中 wait到 runnable状态的转换中，join实际上是Thread类的方法，但这里写成了Object 线程常用的方法12345678//线程休眠：让当前线程暂时停止运行，一段时间后继续执行，保证线程安全Thread.sleep();//线程让步：主动放弃占用的cpu资源，转变为就绪状态，让其他线程先执行Thread.yield();//线程阻塞：让指定线程先执行，执行完之后才能执行，可以实现多个线程的顺序执行join();//获取当前线程状态Thread.currentThread(); 什么是上下文切换通俗来说，因为CPU在任意时刻只能被一个线程使用，为了保证每个线程都能充分的得到利用，因此采用分配时间片并轮转的方式来保证线程执行。 切换时间片时会保存当前执行状态，下次获取时间片的时候继续执行，这个过程称为上下文切换，就是任务保存并重新加载的过程就是一次上下文切换。 这个也是操作系统中最消耗时间的操作了。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serializable知识点]]></title>
    <url>%2F2020%2F07%2F01%2FSerializable%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Serializable知识点Serializable接口简介一个对象序列化接口，一个类只有实现了Serializable接口，它的对象才能被序列化。 什么是序列化序列化是对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以很容易的去存储和传输数据。 序列化：把对象转换为字节序列的过程称为对象的序列化 反序列化：把字节序列恢复为对象的过程称为对象的返序列化 什么情况下需要序列化1、网络进行传输 2、需要对象的状态信息持久化 为什么要定义serialversionUID变量1、如果我们没有自己声明一个serialVersionUID变量,接口会默认生成一个serialVersionUID 2、建议用户自定义一个UID，默认的UID对class细节很敏感，反序列化时可能会导致InvalidClassException 3、序列化后的数据中UID与当前类中的UID一直才能被反序列化成功，否则可能是成员变量的数量或者类型发生了变化，反序列化时就会发生crash，可能就会发生异常]]></content>
      <categories>
        <category>Serializable</category>
      </categories>
      <tags>
        <tag>Serializable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础面试知识]]></title>
    <url>%2F2020%2F05%2F11%2Fjava%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java基础面试知识（持续更新）HashMap，ConcurrentHashMap，Hashtable的数据结构HashMap介绍 HashMap基于Map接口实现，元素以键值对的方式存储，并且允许使用null 建和null 值， 因为key不允许重复，因此只能有一个键为null,另外HashMap不能保证放入元素的顺序，它是无序的，和放入的顺序并不能相同。HashMap是线程不安全的。 HashMap扩容特别耗时，如果能估算大小，最好给它一个默认的初始值，避免进行多次扩容，HashMap线程不安全，多线程状态下应使用ConcurrentHashMap。 如果在多线程状态下想要使用HashMap需要使用Conllections.synchronizedMap()方法获取一个线程安全的Map集合，就是在操作HashMap的时候会自动给方法添加synchronized 关键字来保证线程安全性。 数据结构 HashMap在1.8之前使用的是 数组+链表，1.8之后使用的是 数组+链表+红黑树，当链表长度超过阈值8的时候，将链表转换为红黑树，性能得到提升。 Hashtable介绍 和HashMap基本一样。 对比HashMap Hashtable线程安全，HashMap线程不安全 Hashtable不能使用null作为key，HashMap可以用null作为key HashMap是对Map接口的实现，HashTable实现了Map接口和Dictionary抽象类。 HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。 HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1。 Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模 HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸。 ConcurrentHashMap介绍 在1.8之前采用锁分段技术来保证性能，锁分段技术就是把存储空间分为许多段，然后给每个段都上锁，这样确保在访问某一段的代码时，不会阻塞其他段的访问，提高了性能。 1.8之后，抛弃了锁分段技术，采用了CAS + synchronized 来保证并发更新的安全性。 CAS：Compare and Swap，即比较再交换。 CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。 CAS的缺点：CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。 循环时间长开销很大。只能保证一个变量的原子操作。ABA问题。 循环时间长开销很大：CAS 通常是配合无限循环一起使用的，我们可以看到 getAndAddInt 方法执行时，如果 CAS 失败，会一直进行尝试。如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销。 只能保证一个变量的原子操作：当对一个变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个变量操作时，CAS 目前无法直接保证操作的原子性。但是我们可以通过以下两种办法来解决：1）使用互斥锁来保证原子性；2）将多个变量封装成对象，通过 AtomicReference 来保证原子性。 什么是ABA问题？ABA问题怎么解决？如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？ 如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本（version）来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。 总结 Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据，期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调用都要排队，效率较低。 ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。好处是在保证合理的同步前提下，效率很高。坏处是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。 应该根据具体的应用场景选择合适的HashMap。 Hash函数 加法Hash 位运算Hash 乘法Hash 除法Hash 查表Hash 混合Hash 数组Hash equals和hashcode1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。 2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 equals 它的性质有： 自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。 对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。 传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。 一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。 对于任意不为null的引用值x，x.equals(null)返回false。 对于Object类来说，equals()方法在对象上实现的是差别可能性最大的等价关系，即，对于任意非null的引用值x和y，当且仅当x和y引用的是同一个对象，该方法才会返回true。 需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。 hashcode 1.如果两个对象相同，那么它们的hashCode值一定要相同；2.如果两个对象的hashCode相同，它们并不一定相同（这里说的对象相同指的是用eqauls方法比较）。 如不按要求去做了，会发现相同的对象可以出现在Set集合中，同时，增加新元素的效率会大大下降。3.equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。换句话说，equals()方法不相等的两个对象，hashcode()有可能相等（我的理解是由于哈希码在生成的时候产生冲突造成的）。 反过来，hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 String为什么是final修饰1、为了实现字符串常量池 因为只有当字符串不可变时，才有可能实现字符串池，这样会节省很多堆空间，因为多个地址都可以指向一个值，如果是可变的话 2、保证安全 因为字符串可变的话，数据库等其他形式都是以字符串形式传入的，因为字符串不可变，所以才有了保障，随意改变的话，可能造成安全方面的漏洞 3、线程安全 在多线程情况下，同一字符串可以被多个线程共享，不用因为线程安全所以使用同步，字符串本身就是线程安全的。 4、hashcode 因为字符串不可变，所以创建的时候就被Hashcode缓存了，不需要重新计算，所以一般在map中，字符串做key的话比其他效率要高。 ArrayList扩容ArrayList list=new ArrayList(20);有几次扩容 没有扩容，原因是在初始化的时候已经指定参数了 ArrayList初始容量是10，扩容大小是1.5倍，负载因子是1 因此如果指定大小小于10，那么如果添加元素等于11，就会一次扩容，把容量扩充成15。 扩容方式是位运算的右移，把原来的数组复制到另一个内存空间更大的数组中]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis面试知识]]></title>
    <url>%2F2020%2F05%2F11%2Fredis%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Redis面试知识（持续更新） 参考如下： https://blog.csdn.net/chenyao1994/article/details/79491337 https://blog.csdn.net/u012240455/article/details/81843714 https://www.jianshu.com/p/3677afe376ee redis是什么Redis 是一个c语言编写，开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 redis为什么那么快 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速，数据存在内存中，类似于HashMap，查找和操作时间复杂度都是O(1) 数据结构简单，对数据操作也比较简单 采用单线程，避免了上下文切换和竞争条件，不存在多线程切换导致消耗cpu，不用去考虑各种锁的问题，避免了因锁产生的性能消耗 使用多路I/O复用模型，非阻塞IO 使用底层模型不同，它们之间底层实现方式以及客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用函数的话，会浪费一定的时间去移动和请求 多路I/O复用模型 多路I/O复用模型是利用select，poll，epoll可以同时监察多个流的I/O事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。 redis为什么是单线程因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了 redis哨兵机制什么是哨兵机制redis哨兵机制(sentinel)系统用于管理多个redis服务器，主要执行三个任务： 监控(Monitoring)：哨兵会不断的检查你的Master和Slave是否运作正常 提醒(Notification)：当被监控的某个redis出现问题，哨兵可以通过api向管理员或者其他应用程序发送通知 自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵会开始一次自动故障迁移操作，他会将失效Master的其中一个Slave升级成为新的Master，并让失效的Master的其他Slave改为复制新的Master，当客户端试图连接失效的Master时，集群也会向客户端返回新的Master的地址，使得集群可以使用Master代替失效的Master。 哨兵是一个分布式系统，你可以在一个架构中运行多个哨兵进程，这些进程使用流言协议(gossipprotocols)来接收关于Master是否下线的信息,并使用投票协议(agreement protocols)来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。 每个哨兵(sentinel) 会向其它哨兵(sentinel)、master、slave定时发送消息,以确认对方是否”活”着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机” Subjective Down,简称sdown).若“哨兵群”中的多数sentinel,都报告某一master没响应,系统才认为该master”彻底死亡”(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。 虽然哨兵(sentinel) 释出为一个单独的可执行文件 redis-sentinel ,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动哨兵(sentinel)。 哨兵(sentinel) 的一些设计思路和zookeeper非常类似 总结哨兵是redis集群架构中非常重要的一个组件，作用如下： 集群监控：负责监控redis master和slave进程是否正常工作 消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员 故障转移：如果master node，会自动转移到slave node上 配置中心：如果故障转移发生了，通知client客户端新的master地址 哨兵本身也是分布式的，作为一个哨兵集群去运行的，相互协同工作 (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。(2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。 redis内存淘汰机制volatile-lru从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。redis并不是保证取得所有数据集中最近最少使用的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。 volatile-ttl从已设置过期时间的数据集中挑选将要过期的数据淘汰。redis 并不是保证取得所有数据集中最近将要过期的键值对，而只是随机挑选的几个键值对中的， 当内存达到限制的时候无法写入非过期时间的数据集。 volatile-random从已设置过期时间的数据集中任意选择数据淘汰。当内存达到限制的时候无法写入非过期时间的数据集。 allkeys-lru从数据集中挑选最近最少使用的数据淘汰。当内存达到限制的时候，对所有数据集挑选最近最少使用的数据淘汰，可写入新的数据集。 allkeys-random从数据集中任意选择数据淘汰，当内存达到限制的时候，对所有数据集挑选随机淘汰，可写入新的数据集。 no-enviction当内存达到限制的时候，不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错。 redis集群的CAPCAP理论 C:consistency(一致性) A:avalibility(可用性) P:Partition(分区)-tolerence to partition(分区容忍度) CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 redis发布订阅 命令 描述 PUBLISH channel message 将信息发送到指定的频道。 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息 PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 应用场景1、构建实时消息系统，比如普通的即时聊天，群聊等功能。 2、微信的公共号订阅消息推送等 redis和Mysql同步一、对强一致要求比较高的，应采用实时同步方案，即查询缓存查询不到再从DB查询，保存到缓存；更新缓存时，先更新数据库，再将缓存的设置过期(建议不要去更新缓存内容，直接设置缓存过期)。 二、对于并发程度较高的，可采用异步队列的方式同步，可采用kafka等消息中间件处理消息生产和消费。 三、使用阿里的同步工具canal，canal实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发缓存的更新，此种方法可以解放程序员双手，减少工作量，但在使用时有些局限性。 四、采用UDF自定义函数的方式，面对mysql的API进行编程，利用触发器进行缓存同步，但UDF主要是c/c++语言实现，学习成本高。 redis分布式session结构 原理由于Http连接是无状态的，所以使用Tomcat做服务器的时候Tomcat内部会维护一个Session用来保存客户端的状态，一般情况下每个客户端都有一个cookie里面保存着叫jsessionid的cookie，每次访问tomcat的时候都会携带上，Tomcat可以根据这个jsessionid找到对应的session。 使用Redis作为session存储容器，登录时将session信息存储至cookie客户端，同时服务端将session信息存至redis缓存，双重保障，接下来的接口调用直接可以获取到cookie中的token信息作为参数传递进来即可，如果发现token为空，则再从redis中获取，如果两者都为空，则说明session已过期。 redis集群如何部署 gossip协议Gossip是一种去中心化、容错并保证最终一致性的协议。 redis集群使用的服务 Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播 引用 https://blog.csdn.net/renooon/article/details/73834598 redis和memcache的区别1、数据操作不同 与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能。Redis支持服务器端的数据操作相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，支持list、set、sorted set、hash等众多数据结构，还同时提供了持久化和复制等功能。 而通常在Memcached里，使用者需要将数据拿到客户端来进行类似的修改再set回去，这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作， Redis会是更好的选择。 2、内存管理机制不同 在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。 而Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。 从内存利用率来讲，使用简单的key-value存储的话，Memcached的内存利用率更高。而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 3、性能不同 由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。 4、集群管理不同 Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。 Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。 https://www.php.cn/redis/423024.html Redis持久化操作redis是基于内存的数据库，提供了两种形式进行持久化 RDBRDB是redis默认的持久化形式，本质就是把redis的数据以快照的形式保存到磁盘中。 RDB持久化是指在指定的时间间隔内，将内存中的数据快照写入磁盘，本质是将内存中的数据写入到二进制文件中，默认的文件名是dump.rdb RDB机制的三种触发方式1、save触发方式该命令会阻塞当前的redis服务器，执行save命令期间，redis不能处理其他命令，知道rdb过程完成之后，执行过程中，如果遇到老的rdb文件，就用新的替代掉旧的，但是这种方法一般不可取。 2、bgsave触发方式执行该命令后，redis会在后台异步进行快照操作，进行快照操作的同时还能响应客户端请求 具体操作就是redis进行fork时候创建一个子进程，rdb持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一半时间很短，redis大多数采用的都是这样的触发方式。 3、自动触发一般在配置文件中配置，主要还是使用上面两种触发方式 AOF1、持久化原理由于全量备份总是特别耗时，这时候就需要用到AOF了，AOF工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中，通俗来说就是日志记录。 2、文件重写原理redis提供了bgrewriteof命令，将内存中的数据以命令的形式保存到临时文件中，同时fork出一条新的子线程来将文件重写。 而且，重写操作没有读取旧的aof文件，而是重写了一个新的aof文件 3、三种触发方式 每次修改都同步写入(always)，同步持久化，性能差，数据完整性好。 每秒同步(everysec)，异步操作，每秒记录，如果发生宕机，会丢失数据。 不同步(no)，从不同步。 两者对比 一般来说，通常都是两者一起使用会比较好 根据需求来判断是最合适的。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring面试知识]]></title>
    <url>%2F2020%2F05%2F08%2FSpring%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Spring面试知识（持续更新）Spring1、Spring是什么Spring是一个轻量级的框架，集成了许多模块，让开发人员更多的去实现核心代码，不需要把精力过多的放到其他地方，方便了开发人员的使用。 Spring的核心是IOC和AOP，即控制反转和依赖注入，以及面向切面编程，使得软件可以更好的解耦合。 2、IOC和DIIOC是控制反转，就是本来需要我们自己一个一个的去new对象，如果对象特别多的情况下，这样既不方便管理，而且也不方便使用，因此IOC就是帮我们把需要的对象创建好，全部都由Spring容器进行管理，提高了开发效率。 DI是依赖注入，依赖注入是实现控制反转的主要形式，通过类型和名称来将对象注入到不同的属性中，常用的就是构造方法注入，setter注入，接口注入。 3、AOP面向切面编程，在运行时，动态的将代码切入到类的指定方法，指定位置上的操作就是面向切面编程。 比如想要记录日志，就可以使用AOP的方式来针对每个方法执行或调用情况进行添加日志。 4、JDK代理和cglib代理 jdk代理必须是实现接口的类，cglib可以直接作用在接口上面 jdk代理是面向接口的，而cglib是通过字节码底层要继承代理类来实现的。 jdk代理在1.8之前比较慢，在1.8之后速度就和cglib差不多了 5、如何解决循环依赖问题循环依赖出现的原因是A类引用了B类，B类引用了A类，而Spring在注入的时候，先创建当前对象，在递归的调用方法去获取所依赖的对象，最后将获取的对象注入到当前对象中。但是因为两者相互引用就会陷入一种死循环状态。 用构造器注入会报错，一般采用setter注入。 Spring是通过递归的方式获取目标bean及其所依赖的bean的； Spring实例化一个bean的时候，是分两步进行的，首先实例化目标bean，然后为其注入属性。 6、Spring的事务事务 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性： 执行事务前后，数据保持一致； 隔离性： 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的； 持久性: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 事务管理编程式的事务管理和声明性的事务管理。 编程式事务管理是 把事务具体的写到业务代码中。 声明性事务管理是基于AOP的，既能起到事务管理，还不会影响业务代码。 SpringMVC7、对SpringMVC的理解SpringMVC是一个三层架构，Model，View，Controller，将web层解耦合，把复杂的web应用分成了三部分，简化了开发过程。 8、SpringMVC优点 支持各种各样的视图技术，不仅仅局限于JSP 与Spring框架集成，继承了Spring框架的优点 每个模块功能明确 支持各种资源请求映射 9、SpringMVC重定向和转发重定向：redirect 转发：forward 10、SpringMVC工作原理1）客户端发送请求到 DispatcherServlet 2）DispatcherServlet 查询 handlerMapping 找到处理请求的 Controller 3）Controller 调用业务逻辑后，返回 ModelAndView 4）DispatcherServlet 查询 ModelAndView，找到指定视图 5）视图将结果返回到客户端 SpringBoot11、SpringBoot介绍SpringBoot是一个基于敏捷开发的框架，简化了Spring的使用，简略了各种各样繁琐的设置，提供了各种各样的启动器，开发者可以快速上手。 12、SpringBoot启动原理springboot启动时，在启动类上面有个注解@SpringApplication 这个注解有三个核心注解：@EnableAutoConfiguration和@SpringBootConfiguration还有@ComponentScan 启动的时候会把符合自动配置条件的bean加载到Spring容器还有SpringBoot本身的一些配置，然后通过ComponentScan把注解都扫描一遍，添加进Spring容器， 13、SpringBoot执行流程1、首先调用SpringApplication的静态run方法，run方法先是要创建一个SpringApplication对象实例，实例初始化的时候在classpath里面通过加载器加载初始化类和监听器类，之后设置main方法的定义类。 2、实例化初始完成之后，就可以执行run方法了，首先调用加载的监听类的start()方法，告诉Springboot要开始执行了。 3、创建SpringBoot应用，加载环境变量的准备方法， 4、之后根据用户定义的属性来判断应该创建什么类型的ApplicationContext对象，之后对容器再次进行初始化，调用容器的准备方法。 5、然后把之前通过自动配置注解把所有配置都加载到ApplicationContext中，然后调用refresh()方法，进行刷新，最后finished()方法完成项目的启动。 14、SpringBoot内置容器SpringBoot内置了 Tomcat容器，Jetty容器，undertow容器 默认运行的是Tomcat容器]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty面试知识]]></title>
    <url>%2F2020%2F05%2F05%2FNetty%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Netty面试知识Netty是什么Netty是一个基于NIO的网络通信框架 NIO是从java1.4版本开始引入的一个新的IO API SelectableChannelSelectableChannel 是 jdk1.4引入的nio包中一个有用的抽象类，SelectableChannel可以让程序员避免编写大量阻塞式的代码，特别是在高并发的交互式网络编程中，作用尤其明显。 BIO、NIO、AIO的区别？ BIO：一个连接一个线程，客户端有连接请求时服务器就需要启动一个线程，线程开销大。 NIO：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 通道（Channel）：负责传输Buffer 缓冲区（Buffer）：负责数据的存取 多路复用器（selector）： 多路复用器，用于监控SelectableChannel的IO状况 与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel类和ServerSocketChannel两种不同的套接字实现，都支持阻塞和非阻塞模式，阻塞模式简单，但是性能和可靠性不行，非阻塞模式与此相反，一般低负载，低并发使用同步阻塞IO降低复杂度，对于高负载，高并发还是要用NIO的非阻塞模式。 简单来说，Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生了读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取到就绪Channel的集合，进行后续操作； SocketChannel是一个连接到TCP网络套接字的通道 ServerSocketChannel是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。 DatagramChannel主要针对UDP 管道（Pipe）： JAVA NIO 管道是两个线程之间的单向数据连接 Pipe有一个source通道和一个sink通道，数据会被写到sink通道，从source通道读取。 NIO编程的优点: 1、客户端发起的连接操作是异步的，可以通过在多路复用器注册OP_CONNECTION等待后续结果，不需要像之前的客户端那样被同步阻塞。 2、SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样IO通信线程就可以处理其他的链路，不需要同步等待这个链路可用了。 3、线程模型的优化，由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有连接句柄数的限制（只受限于操作系统的最大句柄数或者对单个进程的句柄限制），意味着Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降，因此，它非常适合做高性能，高负载的网络服务器。 epoll： epoll是为处理大批量句柄而作了改进的poll，是性能最好的多路I/O就绪通知方法 只有三个系统调用： 1、epoll_create：创建一个poll实例，文件描述符 2、epoll_ctl：将监听的文件描述符添加到epoll实例中，实例代码为将标准输入文件描述符添加到epoll中 3、epoll_wait：等待epoll事件从epoll实例中发生，并返回事件以及对应文件描述符 两种事件模型： 1、水平触发： socket接受缓冲区不为空，有数据可读，读事件一直触发 socket发送缓冲区不满，可以继续写入数据，写事件一直触发 2、边沿触发 socket的接受缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发事件 socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出时间时触发读事件 边沿触发仅触发一次，水平触发会一直触发 高效原理： 当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以epoll_wait非常高效 高效本质： 减少了用户态和内核态的文件句柄拷贝 减少了可读可写文件句柄的遍历 mmap加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝 I/O性能不会随着监听的文件描述的数量增长而下降 使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多空间。 AIO：一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。 JDK1.7升级了NIO类库，升级后的NIO类库被称为NIO2.0，这个版本中Java正式提供了异步文件IO操作，同时提供了与UNIX网络编程事件驱动IO对应的AIO； BIO和NIO区别 1、BIO是面向流的，NIO是面向缓冲区的 2、BIO的各种流是阻塞的，而NIO是非阻塞的； 3、BIO的Stream是单向的，而NIO的Channel是双向的 NIO的特点： 1、事件驱动模型 2、单线程处理多任务 3、非阻塞I/O，I/O读写不在阻塞，而是返回0 4、基于block的传输比基于流的传输更高效 5、更高级的IO函数zero_copy 6、IO多路复用大大提高了java网络应用的可伸缩性和实用性 7、基于Reactor线程模型 Reactor模式 1、Reactor模式是什么？ Reactor模式也叫反应器模式，是一种典型的事件驱动的编程模型 Reactor模式逆置了程序处理流程 Reactor组件： 负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包括连接建立就绪，都就绪，写就绪 Handler组件 将自身与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel 2、Reactor事件处理机制： 1、主程序将事件以及对应事件处理的方法在Reactor上进行注册，如果相应的事件发生，Reactor将会主动调用事件注册的接口，即回调函数 2、Redis中基于I/O多路复用开发Reactor事件处理机制，读事件绑定读操作和具体执行命令的操作函数，写事件绑定命令自动回复的操作函数 3、Reactor编程优点 1、响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的 2、编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销 3、可扩展性，可以方便的通过增加Reactor实例个数来充分利用cpu资源 4、可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性 4、Reactor编程缺点 1、相比传统的简单模型，Reactor增加了一定的复杂性，因而具有一定门槛，并且不易于调试 2、Reactor模式需要底层的多路复用支持，比如java中的selector，操作系统的select系统调用支持 3、Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，共享Reactor的Channel如果有一个出现长时间的数据读写，还会影响其这个Reactor中其他的Channel，这时候就需要使用改进版的Reactor模式，Proactor模式。 5、Reactor三种角色 Reactor，将I/O事件分派给对应的Handler Acceptor，处理客户端新连接，并分派请求到处理链中 Handlers，执行非阻塞 读/写 任务 阻塞和非阻塞 传统IO流都是阻塞的 当一个线程调用read()或者write()时，该线程被阻塞，直到一些数据被读取，或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行IO操作时，由于线程会被阻塞，所以服务器端必须为每个客户端提供一个独立的线程进行处理，当服务端要处理大量客户端时，性能就会下降的严重。 NIO 是非阻塞模式的 当线程从某通道进行读写数据时，若没有数据可用时，该线程可以处理其他事，线程通常将非阻塞IO的空闲时间用于其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道，因此NIO可以使用一个或几个线程来同时处理连接到服务器端的所有客户端 NIO的组成 Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的 flip方法 ： 反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式 clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。 rewind方法 ： 重绕此缓冲区，将position置为0 DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。 Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！ Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。 Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl. implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。 fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。 Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取 NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件 Netty的特点 一个高性能，异步事件驱动的NIO框架，它提供了对TCP，UDP和文件传输的支持 使用更高效的socket底层，对epoll空轮询引起的cpu占用飙升在内部进行了处理，避免了直接使用NIO的陷阱，简化了NIO的处理方式 采用多种decoder/encoder支持，对TCP粘包/分包进行了自动化处理 可使用接受/处理线程池，提高连接效率，对重连，心跳检测的简单支持 可配置IO线程数，TCP参数，TCP接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用ByteBuff 通过引用计数器及时申请释放不在引用的对象，降低了GC频率 使用单线程串行化的方式，搞笑的Reactor线程模型 大量使用了volitale、使用了CAS和源自类、线程安全类的使用、读写锁的使用]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法模板]]></title>
    <url>%2F2020%2F05%2F02%2F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[常用算法模板整理八大排序算法 冒泡排序12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/* 思路： 将大数交换到右边 */void bubble_sort(int arr[], int len) &#123; for(int i=0;i&lt;len-1;i++) &#123; for(int j=0;j&lt;len-1-i;j++) &#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr[j],arr[j+1]); &#125; &#125; &#125; &#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; bubble_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; printf("%d ",arr[i]); &#125; return 0;&#125; 快排1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;void quick_sort(int arr[], int left, int right) &#123; //如果左边大于右边说明已经找不到可以互换的了，排序结束 if(left&gt;right)&#123; return; &#125; //基准 int temp = arr[left]; //i,j分别等于边界值，t用来交换值 int i=left,j=right,t; while(i!=j)&#123; //判断左右是否大于或者小于基准 while(arr[j]&gt;=temp&amp;&amp;i&lt;j)&#123; j--; &#125; while(arr[i]&lt;=temp&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; //排序结束进行基准归位 //基准和最左边的数交换位置 arr[left] = arr[i]; arr[i] = temp; //归位后进行排除头和尾进行下次交换 quick_sort(arr,left,j-1); quick_sort(arr,i+1,right); &#125;int main()&#123; int arr[5] = &#123;5,7,3,1,4&#125;; quick_sort(arr,0,4); for(int i=0;i&lt;5;i++)&#123; printf("%d ",arr[i]); &#125; return 0; &#125; 插入排序12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void insert_sort(int arr[],int length)&#123; /* 思路：在第i个元素开始向右查找，遇到左边大于右边的就交换位置 每次循环都需要把一个最小元素移动到数组左边 */ for(int i=0;i&lt;length;i++)&#123; for(int j=i;j&gt;0&amp;&amp;arr[j-1]&gt;arr[j];j--)&#123; swap(arr[j-1],arr[j]); &#125; &#125; &#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; insert_sort(arr,5); for(int i=0;i&lt;5;i++)&#123; printf("%d ",arr[i]); &#125;&#125; 希尔排序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/* 希尔排序思路： 根据增量把数组分成几个小数组 插入排序完成后慢慢减小增量 使得数组在有一定顺序的基础上继续排序 提高排序效率 */void shell_sort(int arr[], int length)&#123; int N = length; //最外层的控制增量 for(int gap=N/2;gap&gt;0;gap/=2)&#123; //对每个组进行插入排序 for(int i=gap;i&lt;N;i++)&#123; //将arr[i]插入到正确的位置 int v = arr[i]; int j; //插入的时候按组进行插入（组内元素两两相隔gap） for(j=i-gap;j&gt;=0&amp;&amp;v&lt;arr[j];j-=gap)&#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = v; &#125; &#125;&#125;int main()&#123; int arr[8] = &#123;5,7,1,4,3,9,6,2&#125;; int len = 8; shell_sort(arr,len); for(int i=0;i&lt;len;i++)&#123; printf("%d ",arr[i]); &#125; return 0;&#125; 插入排序1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/* 选择排序思路： 每次把最小的选出来放到前边 */void select_sort(int arr[],int len)&#123; for(int i=0;i&lt;len;i++)&#123; int minn = i; for(int j=i+1;j&lt;len;j++)&#123; if(arr[j]&lt;arr[minn])&#123; minn = j; &#125; &#125; swap(arr[minn],arr[i]); &#125;&#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; select_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; printf("%d ",arr[i]); &#125; return 0;&#125; 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;//建立父节点和子节点 void max_heapify(int arr[], int start, int end) &#123; //建立父节点指标和子节点指标 int f = start; int s = f*2+1; //若子节点指标在范围内才做比较 while(s&lt;=end)&#123; //先比较两个子节点大小，选择最大的 if(s+1&lt;=end&amp;&amp;arr[s]&lt;arr[s+1])&#123; s++; &#125; //如果父节点大于子节点则表示调整完毕，直接跳出循环 if(arr[f]&gt;arr[s])&#123; return; //佛瑞泽交换父子内容再继续子节点和孙节点比较 &#125;else&#123; swap(arr[f],arr[s]); f = s; s = f*2+1; &#125; &#125; &#125; //堆排序 void heap_sort(int arr[],int len) &#123; //初始化，i从最后一个父节点开始调整 for(int i=len/2-1;i&gt;=0;i--)&#123; max_heapify(arr,i,len-1); &#125; //先将第一个元素和已经排好的元素前一位做交换，再重新调整，直到排序完成 for(int i=len-1;i&gt;0;i--)&#123; swap(arr[0],arr[i]); max_heapify(arr,0,i-1); &#125;&#125;int main()&#123; int arr[10] = &#123;3,5,3,0,8,6,1,5,4,9&#125;; heap_sort(arr,10); for(int i=0;i&lt;10;i++)&#123; printf("%d ",arr[i]); &#125; return 0;&#125; 归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; /* 归并排序思路： 一直分隔，直到剩最后一个然后归并进行排序 */void merge(int arr[], int l, int r, int mid)&#123; int aux[r-l+1],i,j,k; for(k=l;k&lt;=r;k++) &#123; aux[k-l] = arr[k]; &#125; i = l; j = mid + 1; for(k=l;k&lt;=r;k++) &#123; if(i&gt;mid)&#123; arr[k] = aux[j-l]; j++; &#125;else if(j&gt;r) &#123; arr[k] = aux[i-l]; i++; &#125;else if(aux[i-l]&gt;aux[j-l])&#123; arr[k] = aux[j-l]; j++; &#125;else&#123; arr[k] = aux[i-l]; i++; &#125; &#125;&#125;void merge_sort(int arr[], int l, int r)&#123; if(l&gt;=r) &#123; return; &#125; int mid = (l+r)/2; merge_sort(arr,l,mid); merge_sort(arr,mid+1,r); merge(arr,l,r,mid); &#125;int main()&#123; int arr[5] = &#123;5,7,1,3,4&#125;; merge_sort(arr,0,4); for(int i=0;i&lt;5;i++) &#123; printf("%d ",arr[i]); &#125; return 0;&#125; 快速幂1234567891011121314151617181920212223242526#include&lt;iostream&gt;#define ll long longusing namespace std;//迭代运算，把值转化成二进制进行迭代 ll pow_mod(ll a, ll b, ll mod) &#123; //求(a^b)%mod次方 ll ans = 1; while(b&gt;0)&#123; //如果b为奇数 //类似于 b % 2 == 1 if(b&amp;1)&#123; ans = ans * a % mod; &#125; //a的平方 a = a * a % mod; //b右移相当于b/2 b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; printf("%d",pow_mod(2,3,1000)); return 0;&#125; 最长递增子序列和123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int main()&#123; int n; int ans = 0; int dp[1005]; int num[1005]; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; dp[0] = 1; int x = 0; for(int i=0;i&lt;n;i++) &#123; ans = 0; for(int j=0;j&lt;i;j++) &#123; ans = 0; for(int j=0;j&lt;i;j++) &#123; if(num[i]&gt;num[j]) &#123; ans = max(dp[j],ans); &#125; &#125; dp[i] = ans + 1; if(dp[i]&gt;x) x = dp[i]; &#125; &#125; printf("%d",x); return 0;&#125; 最长公共子序列123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;char x[1005],y[1005];int dp[1005][1005];int main()&#123; scanf("%s %s",x+1,y+1); x[0] = y[0] = '.'; int len = strlen(x)&gt;strlen(y)?strlen(x):strlen(y); for(int i=0;i&lt;=len;i++) &#123; dp[i][0] = dp[0][i] = 0; &#125; for(int j,i=1;i&lt;strlen(x);i++) &#123; for(int j=1;j&lt;strlen(y);j++) &#123; if(x[i] == y[j]) &#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = dp[i-1][j]&gt;dp[i][j-1]?dp[i-1][j]:dp[i][j-1]; &#125; &#125; &#125; printf("%d",dp[strlen(x)-1][strlen(y)-1]); return 0;&#125; 最长公共上升子序列1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll n,m;ll p[1005],q[1005],ans,dp[1005][1005];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)scanf("%lld",&amp;p[i]); cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)scanf("%lld",&amp;q[i]); for(int i=1;i&lt;=n;i++) &#123; ll cur = 0; for(int j=1;j&lt;=m;j++) &#123; dp[i][j] = dp[i-1][j]; if(p[i]&gt;q[j]&amp;&amp;dp[i-1][j]&gt;cur) cur = dp[i-1][j]; if(p[i]==q[j]) dp[i][j] = cur+1; &#125; &#125; for(int i=1;i&lt;=m;i++)ans=max(ans,dp[n][i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 并查集1234567891011121314int pre[maxn];int find(int x) &#123; if(pre[x]!=x)&#123; pre[x] = find(pre[x]); &#125; return pre[x];&#125;void join(int x, int y) &#123; int fx = find(x); int fy = find(y); if(fx!=fy)&#123; pre[fx] = fy; &#125;&#125; DFS遍历图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;const int INF = 65535;int map[1005][1005];int Ne,Nv;int visited[1005];void DFS(int n)&#123; visited[n] = 1; printf("%d ",n); for(int i=0;i&lt;Nv;i++) &#123; if((visited[i]!=1&amp;&amp;map[n][i]!=INF))&#123; DFS(i); &#125; &#125;&#125;int main()&#123; int a,b; //先输入点，在输入边 scanf("%d %d",&amp;Nv,&amp;Ne); for(int i=0;i&lt;Nv;i++) &#123; for(int j=0;j&lt;Nv;j++) &#123; map[i][j] = INF; &#125; visited[i] = 0; &#125; for(int i=0;i&lt;Ne;i++) &#123; scanf("%d %d",&amp;a,&amp;b); map[a][b] = map[b][a] = 1; &#125; for(int i=0;i&lt;Nv;i++) &#123; if(!visited[i]) DFS(i); &#125; return 0;&#125;/* 测试数据8 60 70 12 04 12 43 5 结果0 1 4 2 7 3 5 6 */ DFS全排列123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int visit[11],num[11];int n;void dfs(int depth) &#123; if(depth&gt;n)&#123; for(int j=1;j&lt;=n;j++) &#123; cout&lt;&lt;num[j]&lt;&lt;""; &#125; cout&lt;&lt;endl; &#125;else&#123; for(int i=1;i&lt;=n;i++) &#123; if(!visit[i])&#123; visit[i] = 1; num[depth] = i; dfs(depth+1); visit[i] = 0; &#125; &#125; &#125;&#125; int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; visit[i] = 0; &#125; dfs(1); return 0;&#125; BFS遍历图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#define INF 65535using namespace std;int map[1005][1005];int Nv,Ne;int visited[1005];void BFS(int n)&#123; int que[Nv]; int head = 0; int tail = 0; que[tail++] = n; visited[n] = 1; while(head!=tail) &#123; int m = que[head++]; printf("%d ",m); for(int i=0;i&lt;Nv;i++)&#123; if(visited[i]!=1&amp;&amp;map[m][i]!=INF)&#123; que[tail++] = i; visited[i] = 1; &#125; &#125; &#125;&#125;int main()&#123; int a,b; cin&gt;&gt;Nv&gt;&gt;Ne; for(int i=0;i&lt;Nv;i++)&#123; for(int j=0;j&lt;Nv;j++)&#123; map[i][j] = INF; &#125; visited[i] = 0; &#125; for(int i=0;i&lt;Ne;i++)&#123; cin&gt;&gt;a&gt;&gt;b; map[a][b] = map[b][a] = 1; &#125; for(int i=0;i&lt;Nv;i++)&#123; if(!visited[i])&#123; BFS(i); &#125; &#125; return 0;&#125;/* 测试用例8 60 70 12 04 12 43 5结果0 1 2 7 4 3 5 6 */ BFS最短迷宫路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;queue&gt;#define INF 65535using namespace std;int vis[100][100];//路径长度 int map[100][100];//迷宫地图 typedef pair&lt;int,int&gt; P; //节点坐标 P p; int dx[4] = &#123;1,0,-1,0&#125;;int dy[4] = &#123;0,1,0,-1&#125;;int sx = 0,sy = 0; //起始坐标 int ex = 4,ey = 4; //出口坐标int N,M; //迷宫大小queue&lt;P&gt; que;void BFS()&#123; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) &#123; vis[i][j] = INF; &#125; &#125; vis[sx][sy] = 1;//表示起始路径长度 que.push(P(sx,sy)); while(que.size())&#123; p = que.front(); que.pop(); for(int i=0;i&lt;4;i++)&#123; int x = p.first + dx[i]; int y = p.second + dy[i]; //在范围内，并且没有被访问过，而且是通路 if(x&gt;=0&amp;&amp;x&lt;N&amp;&amp;y&gt;=0&amp;&amp;y&lt;M&amp;&amp;map[x][y]!=1&amp;&amp;vis[x][y]==INF)&#123; que.push(P(x,y)); vis[x][y] = vis[p.first][p.second] + 1; if(p.first==ex&amp;&amp;p.second==ey)&#123; break; &#125; &#125; &#125; &#125; &#125; int main()&#123; N = 5; M = 5;//初始化迷宫大小 for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++) &#123; scanf("%d",&amp;map[i][j]); &#125; &#125; BFS(); printf("%d",vis[N-1][M-1]); /*printf("%d",vis[N-1][M-1]); for(int i=0;i&lt;5;i++) &#123; for(int j=0;j&lt;5;j++)&#123; printf("%d ",vis[i][j]); &#125; printf("\n"); &#125;*/ return 0;&#125; /*测试用例 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 输出9*/ 最小生成树（克鲁斯卡尔算法）1234567891011121314151617181920/* |Kruskal算法| |适用于 稀疏图 求最小生成树| |16/11/05ztx thanks to wangqiqi|*//* 第一步：点、边、加入vector，把所有边按从小到大排序 第二步：并查集部分 + 下面的code*/void Kruskal() &#123; ans = 0; for (int i = 0; i&lt;len; i++) &#123; if (Find(edge[i].a) != Find(edge[i].b)) &#123; Union(edge[i].a, edge[i].b); ans += edge[i].len; &#125; &#125; &#125; 迪杰斯特拉算法（单源最短路径）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstring&gt;#define INF 65535using namespace std;int map[1005][1005];int dist[1005];int vis[1005];void Dijkstra(int n) &#123; int i,j,k,min; for(int i=1;i&lt;=n;i++) &#123; dist[i] = map[1][i]; &#125; for(i=1;i&lt;=n;i++)&#123; k = 0; min = INF; //先找最短的路，要求该点没有被访问过，而且是距离的最小值 for(j=1;j&lt;=n;j++) &#123; if(vis[j]==0&amp;&amp;dist[j]&lt;min)&#123; min = dist[j]; k = j; &#125; &#125; vis[k] = 1; for(j=1;j&lt;=n;j++) &#123; if(vis[j] == 0&amp;&amp;dist[j]&gt;dist[k]+map[k][j])&#123; dist[j] = dist[k] + map[k][j]; &#125; &#125; &#125; &#125;int main()&#123; int i,j,a,b,c; int t,n; while(cin&gt;&gt;t&gt;&gt;n) &#123; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(i==j)map[i][j] = 0; else map[i][j] = INF; &#125; &#125; memset(dist,0,sizeof(dist)); memset(vis,0,sizeof(vis)); for(i=1;i&lt;=t;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(c&lt;map[a][b])&#123; map[b][a] = map[a][b] = c; &#125; &#125; Dijkstra(n); printf("%d\n",dist[n]); &#125; return 0;&#125; /*poj 2387样例： 5 51 2 202 3 303 4 204 5 201 5 100结果 90*/ 弗洛伊德算法12345678910111213141516171819void Floyd()&#123; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j] = min(dis[i][j],dis[i][k)+dis[k][j]) &#125; &#125; &#125;&#125;//传递闭包 判断两点是否联通 void Floyd() &#123; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++)&#123; dis[i][j] |= dis[i][k] &amp; dis[k][j]; &#125; &#125; &#125;&#125; 01背包123456789101112131415161718192021222324252627282930//求解将哪些物品装入背包可使价值总和最大 #include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int nmax=1000; int v[nmax];//v[i]表示第i个物品的价值value int w[nmax];//w[i]表示第i个物品的重量weight int dp[nmax];//总价值 int n,m;//n表示物品数量，m表示背包容量 int main() &#123;//一维数组实现的01背包模板 while(cin&gt;&gt;n&gt;&gt;m)&#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;n;i++)&#123;//遍历n个物品 for(int j=m;j&gt;=0;j--)&#123;//01背包容量 逆序遍历 if(j&gt;=w[i])&#123; dp[j]=max(dp[j],(dp[j-w[i]]+v[i])); &#125;//第i个物体不选，dp[j]=dp[j]; //第i个物体若选 dp[j]=dp[j-w[i]]+v[i] &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;endl; &#125; return 0;&#125; 完全背包1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int nmax=1000; int v[nmax];//v[i]表示第i个物品的价值value int w[nmax];//w[i]表示第i个物品的重量weight int dp[nmax];//总价值 int n,m;//n表示物品数量，m表示背包容量 int main() &#123;//一维数组实现的完全背包模板 while(cin&gt;&gt;n&gt;&gt;m)&#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(int i=0;i&lt;n;i++)&#123;//遍历n个物品 for(int j=0;j&lt;=m;j++)&#123;//完全背包容量 顺序遍历 if(j&gt;=w[i])&#123; dp[j]=max(dp[j],(dp[j-w[i]]+v[i])); &#125;//第i个物体不选，dp[j]=dp[j]; //第i个物体若选 dp[j]=dp[j-w[i]]+v[i] &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里Redis规范]]></title>
    <url>%2F2020%2F04%2F22%2F%E9%98%BF%E9%87%8CRedis%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[阿里云Redis规范一、键值设计1、key名设计(1)【建议】: 可读性和可管理性 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id ugc:video:1 (2)【建议】：简洁性 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如： user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。 (3)【强制】：不要包含特殊字符 反例：包含空格、换行、单双引号以及其他转义字符 2、value设计 (1)【强制】：拒绝bigkey(防止网卡流量、慢查询) string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。 反例：一个包含200万个元素的list。 非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法 (2)【推荐】：选择适合的数据类型。 例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡) 反例： setuser:1:nametom setuser:1:age19 setuser:1:favor football 正例: hmsetuser:1nametomage19favorfootball 3、【推荐】：控制key的生命周期，redis不是垃圾桶。 建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。 二、命令使用1.【推荐】 O(N)命令关注N的数量 例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。 2.【推荐】：禁用命令 禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。 3.【推荐】合理使用select redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。 4.【推荐】使用批量操作提高效率 原生命令：例如mget、mset。 非原生命令：可以使用pipeline提高效率。 但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。 注意两者不同： 1、原生是原子操作，pipeline是非原子操作。 2、pipeline可以打包不同的命令，原生做不到 3、pipeline需要客户端和服务端同时支持。 5.【建议】Redis事务功能较弱，不建议过多使用 Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决) 6.【建议】Redis集群版本在使用Lua上有特殊要求： 1.所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn” 2.所有key，必须在1个slot上，否则直接返回error, “-ERR eval/evalsha command keys must in same slotrn” 7.【建议】必要情况下使用monitor命令时，要注意不要长时间使用。 三、客户端使用1.【推荐】 避免多个应用使用一个Redis实例 正例：不相干的业务拆分，公共数据做服务化。 2.【推荐】 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式： 3.【建议】 高并发下建议客户端添加熔断功能(例如netflix hystrix) 4.【推荐】 设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持） 5.【建议】 根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。 默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。 其他策略如下： allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。 allkeys-random：随机删除所有键，直到腾出足够空间为止。 volatile-random:随机删除过期键，直到腾出足够空间为止。 volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。 noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。 四、相关工具1.【推荐】：数据同步 redis间数据同步可以使用：redis-port 2.【推荐】：big key搜索 redis大key搜索工具 3.【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用) facebook的redis-faina 阿里云Redis已经在内核层面解决热点key问题，欢迎使用。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis初探]]></title>
    <url>%2F2020%2F04%2F21%2FRedis%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Redis初探简介REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 安装下载压缩包 1wget http://download.redis.io/releases/redis-5.0.9.tar.gz 解压压缩包 123tar -zxvf redis-5.0.9.tar.gz#解压好感觉最好改个名字mv redis-5.0.9 redis 进入文件夹进行安装 12cd redismake MALLOC=libc 完成后进入src目录进行安装 12cd srcmake install 启动服务 刚开始运行是不支持后台的，得在配置文件中进行修改，然后读取配置文件运行 12345vim /usr/local/bin/redis/redis.conf#修改下面这个配置为yesdaemonize no#然后指定配置文件运行./redis-server /usr/local/bin/redis/redis.conf 关闭进程 如果想关闭的话得先找到pid 12#找PID有很多方法，我是习惯了这种从端口寻找的方法lsof -i:6379 整合整合是整合到springboot中 首先导入依赖 12345&lt;!--redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 然后在application.yml中进行配置 123456789101112spring: redis: host: 127.0.0.1 #主机地址 port: 6379 #端口号 password: 123456 #自己设置的密码 timeout: 1000 #连接超时时间 jedis: pool: max-active: 10 #最大连接数 max-wait: -1 #最大阻塞等待时间 max-idle: 500 #最大空闲数量 min-idle: 0 #最小空闲数量 之后就可以写配置类进行测试了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Componentpublic class RedisUtils &#123; @Autowired private RedisTemplate&lt;String,String&gt; redisTemplate; /** * 读取缓存 * @param key 缓存key值 * @return 返回查找到的值 */ public String get(final String key) &#123; return redisTemplate.opsForValue().get(key); &#125; /** * 写入缓存 * @param key key值 * @param value value值 * @return 返回布尔类型表示是否写入成功 */ public boolean set(final String key, final String value) &#123; boolean result = false; try&#123; redisTemplate.opsForValue().set(key,value); result = true; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 更新缓存 * @param key 更新的key值 * @param value 更新的value值 * @return 返回是否更新成功的布尔类型 */ public boolean getAndSet(final String key, final String value) &#123; boolean result = false; try&#123; redisTemplate.opsForValue().getAndSet(key,value); result = true; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 删除缓存 * @param key 要删除的缓存的key值 * @return 返回是否删除成功的布尔类型 */ public boolean delete(final String key)&#123; boolean result = false; try&#123; redisTemplate.delete(key); result = true; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; 可以在测试类中进行测试，我是测试之后没问题的。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础]]></title>
    <url>%2F2020%2F03%2F26%2FRedis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Redis简介Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 安装在官网下载，然后用ftp工具把下载的压缩包放到服务器上，解压缩 配置文件redis.conf 配置项说明如下： 序号 配置项 说明 1 daemonize no Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ） 2 pidfile /var/run/redis.pid 当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定 3 port 6379 指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字 4 bind 127.0.0.1 绑定的主机地址 5 timeout 300 当客户端闲置多长时间后关闭连接，如果指定为 0，表示关闭该功能 6 loglevel notice 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice 7 logfile stdout 日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null 8 databases 16 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id 9 save &lt;seconds&gt; &lt;changes&gt;Redis 默认配置文件中提供了三个条件：save 900 1 save 300 10 save 60 10000分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 10 rdbcompression yes 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大 11 dbfilename dump.rdb 指定本地数据库文件名，默认值为 dump.rdb 12 dir ./ 指定本地数据库存放目录 13 slaveof &lt;masterip&gt; &lt;masterport&gt; 设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 14 masterauth &lt;master-password&gt; 当 master 服务设置了密码保护时，slav 服务连接 master 的密码 15 requirepass foobared 设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH 命令提供密码，默认关闭 16 maxclients 128 设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息 17 maxmemory &lt;bytes&gt; 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区 18 appendonly no 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no 19 appendfilename appendonly.aof 指定更新日志文件名，默认为 appendonly.aof 20 appendfsync everysec 指定更新日志条件，共有 3 个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快）always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）everysec：表示每秒同步一次（折中，默认值） 21 vm-enabled no 指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制） 22 vm-swap-file /tmp/redis.swap 虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享 23 vm-max-memory 0 将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0 24 vm-page-size 32 Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值 25 vm-pages 134217728 设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。 26 vm-max-threads 4 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 27 glueoutputbuf yes 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 28 hash-max-zipmap-entries 64 hash-max-zipmap-value 512 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 29 activerehashing yes 指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍） 30 include /path/to/local.conf 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 常用的数据类型及应用场景 类型 简介 特性 场景 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set(集合) 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 待更新。。。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多模块开发踩坑]]></title>
    <url>%2F2020%2F03%2F17%2F%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[多模块开发踩坑项目结构介绍 我遇到的问题1、 父pom文件内容，该写什么，什么部分不需要 2、 子pom文件内容，怎么去继承父模块 3、 怎么规范版本号，以及怎么统一包的版本 4、 怎么启动项目，怎么打包，怎么发布 5、 每个模块之前的packaging怎么填，谁需要打包，谁需要war，谁需要jar 6、 模块的子模块中还有子模块，这样的情况怎么调用和使用。 7、 application的配置到底属于哪一个模块 8、 relativePath到底需不需要（大坑） 9、 如果出现模块不一致怎么办 10、dependencyManagement和dependencies区别 11、多模块中怎么给需要的bean注入值 问题解决1、 写自己的版本号，把需要用的包使用 &lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; 导入，如果子类继承父类后，如果需要包的话就直接导入不用指明版本号 2、 如果直接在父pom中使用 &lt;dependencies&gt;&lt;/dependencies&gt; 的话那么子类不管用不用都需要导入 3、 子pom文件直接导入父pom文件的版本号就行 4、 版本号写在父pom文件中，以及包的版本号统一在父pom文件中使用，而且不需要指定jar的version了 5、 启动项目，我感觉应该是web层进行启动项目 6、 打包问题，如果项目没有问题直接对父项目 clean + package 即可，最后生成的包在web模块中 7、 一般来说父模块一般都是用pom聚合，子模块都要打成jar包，war包则一般都是web模块 8、 父模块需要指定所有子模块，子模块相互调用是通过相互依赖来实现的 9、 application的配置一般在web模块中 10、relativePath看情况来判断，首先relativePath默认值为../pom.xml ，查找顺序：relativePath元素中的地址–本地仓库–远程仓库，设定一个空值将始终从仓库中获取，不从本地路径获取，如&lt;relativePath /&gt; 11、如果模块不一致，那么就需要打开project Structure，在模块中把右边不一致的模块删除 12、如果用dependencyManagement来指定依赖，那么子模块中默认不会有，需要使用的时候只需要导入坐标就行，不需要指定版本号，默认使用的是父模块中的版本号，如果使用dependencies的话，不管子模块中用不用得到，都会在子模块中显示依赖。 13、如果想要注入值，那么需要在springbootApplication的注解中进行添加扫包，把其他模块中的类扫描进来 例如这种格式 @SpringBootApplication(scanBasePackages = {&quot;com.guidinglight&quot;}) POM文件parent模块packaging 需要改成 pom，因为默认为jar类型，改成pom表示夫类型都是pom类型 modules 把子模块全部添加进去 dependencyManagement 把需要用到的依赖都给添加进去，如果需要使用直接导入依赖就行了 child模块就是正常使用即可，需要什么依赖直接添加 待更新。。。引用https://blog.csdn.net/gdsgdh308227363/article/details/79722491 https://blog.csdn.net/zwt0909/article/details/52218222]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多模块项目理解]]></title>
    <url>%2F2020%2F03%2F17%2F%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[多模块项目理解介绍为什么要用多模块？ 1、 做项目首先讲究 “高内聚，低耦合”，因此传统的项目是将一个项目分为多个包，随着项目复杂，如果想复用一个模块的话，因为是包的形式，复用起来会很麻烦，耦合性很强，常用的方法就是复制代码修改，但是这样会做出很多无用功和增加出错几率。 2、 springboot多模块简单说，就是把包按分模块的模式，借助maven升级到jar方式，抽象性就更强了，假如jar再升级到war或者多个集合的jar，就成微服务了，在多模块jar模式下，可以将某个jar拿出来对外共用，能大大提高代码复用率和开发效率。 3、 开发者对自己或者别人负责的代码边界很模糊，这是复杂项目中最容易遇到的，导致结果就是开发者很容易修改别人代码，而且代码负责人还不知道，责任追踪很麻烦。 4、简单来说就是 高内聚，低耦合，容易维护，便于开发者确定自己负责的内容。 5、以上都是百度的。 开发思路1、首先确定项目开发结构 2、创建最基本的项目模块 3、理清楚各模块之间的依赖关系 4、修改pom文件，统一版本号和使用的jar包版本，如果在此期间觉得哪几个模块能够合并，就优化一下 可能会存在的问题（1） 划分模块的方式 划分模块主要根据是职责单一性和耦合性，如果是项目创建初期就使用多模块来规划项目，那么职责单一性就应该是首先考虑的，也就是通常意义上的按照层次划分，如果是从一个十分复杂的项目开始拆分，那么在划分模块的石航就不仅仅是考虑职责单一性了，职责单一会造成大量的子模块产生导致pom文件臃肿且不容易识别，如果将耦合性考虑进去就应该将关系较为紧密的模块合并降低模块的数量提高实用性。 （2） 公有依赖的抽象 parent中的以来配置主要是有一些公有的依赖，例如log，apache，commons，spring等，怎么界定一个依赖是否属于公有呢？一般情况下如果这个依赖被超过2/3的子模块所依赖就可以将其认定为公有依赖，另外也可以将依赖的某些配置（例如版本号）以parent中pom的属性的形式加以声明，这样在升级某些依赖的时候只要改动一处就行了（很类似C语言中的#define） （3） 模块的存在与消亡 模块的划分并不是一成不变的，模块的存在就是为了方便维护和提高生产效率，如果某些模块不合理并且影响了开发效率，那么这些模块就需要再好好斟酌一下，一般情况下这种情况出现不是为了模块过于庞大就是因为模块的碎片化，对于前者需要拆分更多模块以提高复用和去除冗余，后者则需要酌情合并一些耦合性较高的模块。 （4） 子模块的子模块 这种情况的出现往往就意味着这个项目本身就应该被分成多个项目，多个项目之间也可以继承同一个parent的pom.xml这主要是为了方便统一构建多个项目。所以子模块的子模块应该避免出现。 待更新。。。引用如下: https://blog.csdn.net/wuzhenwei0419/article/details/84029454 https://www.cnblogs.com/ruanjianlaowang/p/11214271.html]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos基本信息和ssh]]></title>
    <url>%2F2019%2F12%2F12%2FCentos%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%92%8Cssh%2F</url>
    <content type="text"><![CDATA[Centos 基本信息和SSHCentos介绍CentOS Linux是一个社区支持的发行版，该发行版来自在Red Hat或CentOS git上免费提供给公众的资源适用于Red Hat Enterprise Linux（RHEL）。因此，CentOS Linux旨在与RHEL在功能上兼容。CentOS专案主要更改软件包以删除上游供应商的品牌和艺术品。CentOS Linux是免费的，可以免费重新分发。每个CentOS版本都会得到维护，直到等效的RHEL版本不再受到一般支持为止。一旦重建了新的RHEL版本，便会提供一个新的CentOS版本-大约每6-12个月发行一次次要点发布，几年则更新一次主要版本。重建所需的时间从点发布的几周到主要版本变更的几个月不等。这样就形成了一个安全，低维护，可靠，可预测和可再现的Linux环境。 下载下载地址 常用命令文件与目录操作 命令 解析 cd /home 进入 ‘/home’ 目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd - 返回上次所在目录 cp file1 file2 将file1复制为file2 cp -a dir1 dir2 复制一个目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录（.代表当前目录） ls 查看目录中的文件 ls -a 显示隐藏文件 ls -l 显示详细信息 ls -lrt 按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序） pwd 显示工作路径 mkdir dir1 创建 ‘dir1’ 目录 mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 mv dir1 dir2 移动/重命名一个目录 rm -f file1 删除 ‘file1’ rm -rf dir1 删除 ‘dir1’ 目录及其子目录内容 查看文件内容 命令 解析 cat file1 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 more file1 查看一个长文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 tail -3 file1 查看一个文件的最后三行 vi file 打开并浏览文件 文本内容处理 命令 解析 grep str /tmp/test 在文件 ‘/tmp/test’ 中查找 “str” grep ^str /tmp/test 在文件 ‘/tmp/test’ 中查找以 “str” 开始的行 grep [0-9] /tmp/test 查找 ‘/tmp/test’ 文件中所有包含数字的行 grep str -r /tmp/* 在目录 ‘/tmp’ 及其子目录中查找 “str” diff file1 file2 找出两个文件的不同处 sdiff file1 file2 以对比的方式显示两个文件的不同 vi file 操作解析i进入编辑文本模式Esc退出编辑文本模式:w保存当前修改:q不保存退出vi:wq保存当前修改并退出vi 查询操作 命令 解析 find / -name file1 从 ‘/’ 开始进入根文件系统查找文件和目录 find / -user user1 查找属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件 find /usr/bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 find -name ‘*.[ch]’ | xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ find -type f -print0 | xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ find -maxdepth 1 -type f | xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 压缩、解压 命令 解析 bzip2 file1 压缩 file1 bunzip2 file1.bz2 解压 file1.bz2 gzip file1 压缩 file1 gzip -9 file1 最大程度压缩 file1 gunzip file1.gz 解压 file1.gz tar -cvf archive.tar file1 把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数） tar -cvf archive.tar file1 dir1 把 file1，dir1 打包成 archive.tar tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 把压缩包释放到 /tmp目录下 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 dir1 把文件和目录压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式的压缩包到当前目录 unzip test.zip -d /tmp/ 解压一个zip格式的压缩包到 /tmp 目录 yum安装器 命令 解析 yum -y install [package] 下载并安装一个rpm包 yum localinstall [package.rpm] 安装一个rpm包，使用你自己的软件仓库解决所有依赖关系 yum -y update 更新当前系统中安装的所有rpm包 yum update [package] 更新一个rpm包 yum remove [package] 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search [package] 在rpm仓库中搜寻软件包 yum clean [package] 清除缓存目录（/var/cache/yum）下的软件包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 网络相关 命令 解析 ifconfig eth0 显示一个以太网卡的配置 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置网卡的IP地址 ifdown eth0 禁用 ‘eth0’ 网络设备 ifup eth0 启用 ‘eth0’ 网络设备 iwconfig eth1 显示一个无线网卡的配置 iwlist scan 显示无线网络 ip addr show 显示网卡的IP地址 系统相关 命令 解析 su - 切换到root权限（与su有区别） shutdown -h now 关机 shutdown -r now 重启 top 罗列使用CPU资源最多的linux任务 （输入q退出） pstree 以树状图显示程序 man ping 查看参考手册（例如ping 命令） passwd 修改密码 df -h 显示磁盘的使用情况 cal -3 显示前一个月，当前月以及下一个月的月历 cal 10 1988 显示指定月，年的月历 date –date ‘1970-01-01 UTC 1427888888 seconds’ 把一相对于1970-01-01 00:00的秒数转换成时间 XSheel 5相关操作窗体快捷键 命令 解析 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + a 光标移动到行首（ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（end of line） Ctrl + f 光标向前（forward）移动一个字符位置 Ctrl + b 光标往回（backward）移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + r 显示:号提示，根据用户输入查找相关历史命令（reverse-i-search） Ctrl + w 删除从光标位置前到当前所处单词（word）的开头 Ctrl + t 交换光标位置前的两个字符 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + Alt + d 显示桌面 Alt + b 光标往回（backward）移动到前一个单词 Alt + d 删除从光标位置到当前所处单词的末尾 Alt + F2 运行 Alt + F4 关闭当前窗口 Alt + F9 最小化当前窗口 Alt + F10 最大化当前窗口 Alt + Tab 切换窗口 Alt + 左键 移动窗口（或在最下面的任务栏滚动鼠标滑轮） SSH介绍SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 SSH用法检查是否开启ssh1$rpm -qa | grep ssh 安装ssh1$yum install openssh-server 开启ssh1$ /bin/systemctl start sshd.service 继续检查是否开启1$ps -e | grep sshd 将ssh添加自启动1$systemctl enable sshd.service]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos mysql配置]]></title>
    <url>%2F2019%2F12%2F11%2FCentos7-mysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Centos 7 Mysql配置Yum安装123456#安装$yum install mysql-server#启动$systemctl start mysqld #登录$mysql -u root -p 配置修改root密码 1234567891011121314进入mysql系统表use mysql;对用户进行排序desc user;修改root密码update user set password = password(“root”) where user = ‘root’;刷新权限flush privileges;赋予其他机器可以访问的权限grant all privileges on . to root@’%’ identified by ‘root’ with grant option; 修改字符集 1$vim /etc/my.cnf 修改成这个样子 1234567891011121314151617181920[client]port=3306socket=/var/lib/mysql/mysql.sockdefault-character-set=utf8[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0character-set-server=utf8[mysql]no-auto-rehashdefault-character-set=utf8[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 重启mysql服务 1234$service mysqld restart#在mysql中查看字符编码show variables like 'character_set%';]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 防火墙优化]]></title>
    <url>%2F2019%2F12%2F11%2FCentos7-%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[Centos 7 防火墙优化简介Centos 7 使用的防火墙是 firewall，可以允许哪些服务可用，哪些端口可用 开关123456789$systemctl enable firewalld.service #启用 "开机启动"$systemctl disable firewalld.service #关闭 "开机启动"$systemctl start firewalld.service #启用防火墙$systemctl stop firewalld.service #关闭防火墙$systemctl status firewalld.service #查看防火墙状态【开机自启】$chkconfig firewalld on #"开机自启" 开启$chkconfig firewalld off #"开机自启" 关闭 端口端口其实就是 类似于门的东西，你只能通过这扇门来访问我的服务器， 因此对于服务器安全来说，这扇门还是很重要的。 开放端口 12345678910$firewall-cmd --zone=public --add-port=&#123;端口&#125;/tcp --permanent #开放端口#开放端口之后必须重新启动防火墙才可以生效$systemctl restart firewalld.service #重启防火墙# --zone 作用域# --add-port=&#123;端口&#125;/tcp 添加端口# --permanent 永久生效，没有这个重启之后就会失效#查看开启端口$firewall-cmd --list-ports 关闭端口 1$firewall-cmd --zone=public --remove-port=80/tcp --permanent 优化修改22端口 1、打开 /etc/ssh/sshd_config文件 1$vim /etc/ssh/sshd_config 2、将#Port 22 注释去掉，22改为你想设置的端口，如33881，保存 3、重启ssh 1systemctl restart sshd.service 4)将该端口加入防火墙例外并重启防火墙 123$firewall-cmd --permanent --zone=public --add-port=33881/tcp$sudo systemctl restart firewalld.service 密码长度与有效期 默认配置： 123456$cat /etc/login.defs |grep PASS_ |grep -v '#'PASS_MAX_DAYS 99999PASS_MIN_DAYS 0PASS_MIN_LEN 5PASS_WARN_AGE 7 加固方案: 1.备份配置文件： 1$ cp -a /etc/login.defs /etc/login.defs.default 2.编辑配置文件并将相关参数改成如下 12345$vi /etc/login.defsPASS_MAX_DAYS 90PASS_MIN_DAYS 6PASS_MIN_LEN 8PASS_WARN_AGE 30 备注: /etc/login.defs文件的pass_min_len 参数并不具备强制性，测试仍然可以设置7位密码。最终需要cracklib来实现。 参数说明： PASS_MAX_DAYS 密码有效期 PASS_MIN_DAYS 修改密码的最短期限 PASS_MIN_LEN 密码最短长度 PASS_WARN_AGE 密码过期提醒 禁止root通过ssh远程登录 默认配置: 12$cat /etc/ssh/sshd_config |grep PermitRootLogin#PermitRootLogin yes 加固方案: 123456781.备份配置文件$cp -a /etc/ssh/sshd_config /etc/ssh/sshd_config.default2.编辑配置文件$vi /etc/ssh/sshd_config将配置参数#PermitRootLogin yes改成PermitRootLogin no3.保存配置文件4.重启ssh服务$ /etc/init.d/sshd restart SSH 配置参数增强 12345678910111213141516171819202122231.备份配置文件2.编辑配置文件$vi /etc/ssh/sshd_config（1）禁止空密码登录将#PermitEmptyPasswords no参数的注释符号去掉，改成PermitEmptyPasswords no（2）关闭ssh的tcp转发将#AllowTcpForwarding yes参数改成AllowTcpForwarding no（3）关闭S/KEY（质疑-应答)认证方式将#ChallengeResponseAuthentication yes参数，改成ChallengeResponseAuthentication no（4）关闭基于GSSAPI 的用户认证将GSSAPIAuthentication yes参数，改成GSSAPIAuthentication no3.保存配置文件4.重启ssh服务 隐藏系统版本信息 123执行以下命令：$mv /etc/issue /etc/issue.bak$mv /etc/issue.net /etc/issue.net.bak 备注:登录界面显示系统版本信息 系统参数调优 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869701.备份配置文件cp -a /etc/sysctl.conf /etc/sysctl.conf.default2.添加以下调优参数到该文件中net.ipv4.ip_forward = 1net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.route.gc_timeout = 20net.ipv4.tcp_retries2 = 5net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000net.core.somaxconn = 262144net.core.netdev_max_backlog = 262144net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.route.gc_timeout = 20net.ipv4.ip_local_port_range = 10024 65535net.ipv4.tcp_retries2 = 5net.ipv4.tcp_syn_retries = 2net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_keepalive_time = 1800net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000fs.file-max = 65535kernel.pid_max = 65536net.ipv4.tcp_wmem = 4096 87380 8388608net.core.wmem_max = 8388608net.core.netdev_max_backlog = 5000net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_max_syn_backlog = 10240net.core.netdev_max_backlog = 262144net.core.somaxconn = 262144net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 120net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_max_tw_buckets = 36000]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis逆向工程]]></title>
    <url>%2F2019%2F11%2F21%2FMybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Mybatis逆向工程pom.xml插件123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="DB2Tables" targetRuntime="Mybatis3"&gt; &lt;!-- 避免生成重复代码的插件 --&gt; &lt;!-- &lt;plugin type="com.vi.tmall.util.OverlsMergeablePlugin"/&gt;--&gt; &lt;!-- 是否不生成注释 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true" /&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/tmall_ssm" userId="root" password="root"/&gt; &lt;!-- 这个元素的配置用来指定JDBC类型和Java类型如何转换。 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否强制将DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal --&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetPackage:生成实体类存放的包名, targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject="src/main/java"）--&gt; &lt;javaModelGenerator targetPackage="com.vi.tmall.pojo" targetProject="src/main/java"&gt; &lt;!--enableSubPackages 如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false--&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- trimStrings:是否对数据库查询结果进行trim操作，如果设置为true就会生成类似这样public void setUsername(String username)--&gt; &lt;property name="trimString" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!--生成xml映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成mapper类存放位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.vi.tmall.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名,enableXXX:XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句--&gt; &lt;table tableName="category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true" selectByExampleQueryId="false"&gt; &lt;property name="my.isgen.usekeys" value="true"/&gt; &lt;!--useActualColumnNames:如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式--&gt; &lt;property name="useActualColumnNames" value="true"/&gt; &lt;generatedKey column="id" sqlStatement="JDBC"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行在Maven中运行generator插件就行]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之面向对象设计模式]]></title>
    <url>%2F2019%2F11%2F18%2FJAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java设计模式之面向对象设计模式概述软件的可维护性和可复用性是两个非常重要的用于衡量软件质量的属性 面向对象设计，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。 单一职责原则定义一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 另一种定义方式就一个类而言，应该仅有一个引起它变化的原因。 解释在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被服用的可能性就越小，而且一个类承担的职责过多，相当于将这些指责耦合在一起，当一个职责变化的时候就可能引起其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一个类中。 单一职责原则是实现高内聚、低耦合的指导方针 开闭原则开闭原则是面向对象的可复用设计的第一块基石，他是最重要的面向对象设计原则。 定义软件实体应当对扩展开放，对修改关闭。 解释在开闭原则的定义中，软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。 如果一个软件设计符合开闭原则，那么可以非常方便的对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 实现为了满足开闭原则。，需要对系统进行抽象化设计，抽象化是开闭原则的关键。编程时，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。 在后面的24种设计模式中很多设计模式都符合开闭原则，在对每一个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可拓展性。 里氏代换原则定义所有引用基类的地方必须能透明地使用其子类的对象。 解释在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此判断我喜欢所有的动物。 里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在运用里氏代换原则时应该将父类设计为抽象类或者接口，让子类继承父类或者实现父接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 依赖倒转原则定义高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 解释依赖倒转原则要求针对接口编程，不需要针对实现编程。 依赖倒转原则要求在程序代码中传递参数时或者在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式注入所依赖的对象。 常用的三种注入方式： 构造注入，设值注入和接口注入。 后话开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，他们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。 接口隔离原则定义客户端不应该依赖那些它不需要的接口。 解释当一个接口太大时，需要把这个接口分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。 这里的“接口“往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的”接口“，有严格的定义和结构，例如 interface。 在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 合成复用原则定义优先使用对象组合，而不是通过继承来达到复用的目的。 解释合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。 在复用的时候，尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或者通过继承，但是首先应该考虑使用组合/聚合,组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对于其他类造成的影响相对较少；其次才考虑继承，在使用继承时需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，而且灵活性不够强，只能在有限的环境中使用。 组合/聚合可以将已有的对象纳入新对象中，使之成为新对象的一部分，相对继承关系而言，耦合性相对较低； 合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 扩展关联 关联指的是两个分开的类通过对象或者实例建立地关系。关联可以是一对一，一对多，多对一，多对多等关系。 关联比较宽泛，组合是聚合地一个子集。组合-》聚合-》关联； 聚合 聚合是关联的一种特殊形式：主要体现在三个方面 聚合代表了has-a的关系 并且是一种单向关系。单向的，比如说公寓里有学生，但是学生里面不能有公寓，这是一种天生的单向关系。 在聚合的关系中，两种实例是可以单独存在的，不会相互影响，一个实例的存在与否不会影响与之聚合的实例的存在与否。 组合 组合是一种聚合的限制形式，其中两个实体高度相互依赖，也就是说，两个类高度耦合。有以下特征： 代表着一种part-of关系，就是一个类是另一个类的一部分 在组合的关系中，实例是彼此依赖的 当两个实例是组合关系，他们就是高度耦合的，一个对象必须依赖另一个对象的存在而存在 比如图书馆中会有很多相同或者不同主题的图书，但是如果图书馆被销毁后，对应的图书也就没了，图书不能独立与图书馆而存在，这就是组合关系。 聚合和组合相比较 依赖：聚合代表被关联的一方可以独立于关联一方而存在的关系，比如说，银行和雇员，将银行删除后，雇员仍然存在；然后，组合代表着被关联的一方不能独立与另一方而存在的关系，比如，人没有心脏就不能生存，心脏没有人也就没有了心脏。 关系类型：聚合是has-a关系，组合是part-of关系。 关联类型：组合是一种强关联关系，聚合是一种弱关联关系 迪米特原则定义每一个软件单位对其他单位都只有最少的只是，而且局限于那些与本单位密切相关的软件单位。 解释迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则则要求限制软件实体之间通信的宽度和深度。 应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。 定义形式： 不要和 “陌生人” 说话 只与你的朋友直接通信 朋友的类别： 当前对象本身（this） 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 任意一个对象如果满足上面的条件之一，就是当前对象的 ”朋友“ ，否则就是 “陌生人” 。 在应用迪米特法则的时候，一个对象只能与直接朋友发生交互，不要与 “陌生人” 直接交互，这样可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。如果一个对象需要调用另一个对象的方法，可以通过 “第三者” 转发这个调用。简单说就是引用一个 “第三者” 来降低现有对象之间的耦合度。 注意： 类的划分上尽量创建松耦合类，类之间的耦合度越低，就越有利于复用，如果修改了一个类，不会对关联的类造成太大的影响。 类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 类的设计上，只要有可能，一个类型应该设计成不变类，在对其它类的引用上，一个对象对其他对象的引用应当降到最低。 小结低耦合，高内聚，可维护，可复用，可扩展]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（三）]]></title>
    <url>%2F2019%2F11%2F13%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（三）依赖如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。 依赖传递范围设定score：作用域，控制依赖传递 test 仅适用于第一类jar包，其不会向下传递 provided 仅适用于第二类jar包，其不会向下传递 runtime 仅适用于第三类jar包，会向下传递 compile 默认值。适用于第四类jar包，会向下传递 system &lt;systemPath&gt;${basedir}/lib/xxx.jar&lt;/systemPath&gt; import 下节课会说 jar包分类： 编译、运行、打包时都不需要 测试用jar包属于该类型，例如junit、spring-test 编译、运行时需要的jar，打包时不需要 servlet-api，jsp-api属于该类型 编译时不需要，但运行、打包时需要的jar包 mysql驱动属于该类型 Class.forName(“com.mysql.jdbc.Driver”); 编译、运行、打包时均需要的jar包 可选传递optional（可选的） true，表示当前依赖是可选的，即可要可不要 false，默认值，表示默认是传递的 exclusions： exclusion：排除依赖，将所选的依赖排除 依赖冲突直接依赖冲突在同一个工程中出现了同一个依赖的不同版本，系统会自动选择最后导入的那个版本 间接依赖冲突间接依赖冲突在工程中会出问题，所以需要手工删除发生冲突的依赖 上级的包传递到下级，下级版本与上级不一致 版本号的统一与管理 依赖的继承直接继承 可选继承 聚合 课外开源中国—-&gt;国产开源 开源项目管理软件—-&gt;易软天创（禅道） 无反射无框架，无代理无框架]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习中遇到的问题（一）]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习中遇到的问题（一）1、集合类型只能通过XML来实现 2、setting注入复杂类型数据 list: array value list value set value map: properties prop map entry key value 3、为什么IOC容器中获得bean的时候要把bean转化为接口类型？ 因为new对象的时候也是用接口实例化子类，而在spring-config.xml中已经实例化子类，所以把子类转化为接口类型，实现了多态。 4、javaBean使用包装类 Integer，String，Float等，因为如果值为空 不会显示0 可以显示null 5、线程绑定事务方法 TheadLocal ThreadLocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据 数据库事务控制 6、分页 可以使用分页框架实现 pagehelper 7、引入css样式后面一定要写上 rel=”stylesheet” 8、ResponseBody @ResponseBody是作用在方法上的，表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用（也就是ajax），在使用@RequestMapping后，返回值通常解析为跳转路径，但是加上@ReponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body 中，比如异步获取json数据，加上@ResponseBody后，会直接返回json数据。@RequestBody将HTTP请求正文插入方法中，使用适合的HttpMessageConverter将请求体写入某个对象。 9、 Mapper作用 为了把mapper这个DAO交給Spring管理 为了不再写mapper映射文件 为了给mapper接口 自动根据一个添加@Mapper注解的接口生成一个实现类 10、三层架构 三层架构：表现层，业务层，持久层 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是为了完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。 M称为模型，也就是实体类，用于数据的封装和数据的传输。 V称为视图，也就是GUI组件，用于数据的展示。 C称为控制，也就是事件，用于流程的控制。 设计原则 业务层接口的设计原则：一个实体类一个接口，一次提交一个事务方法。业务方法的参数来自表现层。 持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。 11、favicon报错 在head标签中最下面写上 1&lt;link rel="shortcut icon" href="#" /&gt; 12、centos防火墙端口 123456789101112131415161718#查看防火墙所有开放端口firewall-cmd --zone=public --list-ports#开启端口firewall-cmd --zone=public --add-port=80/tcp --permanent#命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效#关闭端口firewall-cmd --zone=public --remove-port=80/tcp --permanent#查看防火墙状态firewall-cmd --state #重启防火墙firewall-cmd --reload]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thymeleaf]]></title>
    <url>%2F2019%2F10%2F31%2Fthymeleaf%2F</url>
    <content type="text"><![CDATA[thymeleaf简介Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。 Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。 Thymeleaf的主要目标是提供一个优雅和高度可维护的创建模板的方式。 为了实现这一点，它建立在自然模板的概念之上，以不影响模板作为设计原型的方式将其逻辑注入到模板文件中。 这改善了设计沟通，弥合了前端设计和开发人员之间的理解偏差。 Thymeleaf也是从一开始就设计(特别是HTML5)允许创建完全验证的模板。 引入在头部引入xmls的参数 1234&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;/html&gt; 使用主要的使用标签 语法 说明 {home.welcome} 使用国际化文本,国际化传参直接追加(value…) ${user.name} 使用会话属性 @{} &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; – – ${} 中预存对象（表达式中基本对象） param 获取请求参数，比如${param.name},http://localhost:8080?name=jeff session 获取 session 的属性 application 获取 application 的属性 execInfo 有两个属性 templateName和 now(是 java 的 Calendar 对象) ctx vars locale httpServletRequest httpSession – – th扩展标签 th:text 普通字符串 th:utext 转义文本 th:href th:attr &lt;img src=&quot;../../images/gtvglogo.png&quot; th:attr=&quot;src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}&quot; /&gt; th:with 定义常量 th:attrappend th:classappend th:styleappend 其他th标签 * * * th:abbr th:accept th:accept-charset th:abbr th:accept th:accept-charset th:accesskey th:action th:align th:alt th:archive th:audio th:autocomplete th:axis th:background th:bgcolor th:border th:cellpadding th:cellspacing th:challenge th:charset th:cite th:class th:classid th:codebase th:codetype th:cols th:colspan th:compact th:content th:contenteditable th:contextmenu th:data th:datetime th:dir th:draggable th:dropzone th:enctype th:for th:form th:formaction th:formenctype th:formmethod th:formtarget th:frame th:frameborder th:headers th:height th:high th:href th:hreflang th:hspace th:http-equiv th:icon th:id th:keytype th:kind th:label th:lang th:list th:longdesc th:low th:manifest th:marginheight th:marginwidth th:max th:maxlength th:media th:method th:min th:name th:optimum th:pattern th:placeholder th:poster th:preload th:radiogroup th:rel th:rev th:rows th:rowspan th:rules th:sandbox th:scheme th:scope th:scrolling th:size th:sizes th:span th:spellcheck th:src th:srclang th:standby th:start th:step th:style th:summary th:tabindex th:target th:title th:type th:usemap th:value th:valuetype th:vspace th:width th:wrap th:xmlbase th:xmllang th:xmlspace th:alt-title 或th:lang-xmllang（如果其中两个属性值相同） 表达式语法简单的语法 #{...} ：Message 表达式 ${}：变量表达式 *{} ：选择变量表达式 @{}：链接 URL 表达式 变量 分类 示例 文本 ‘one text’ , ‘Another one!’ ,… 数字 0 , 34 , 3.0 , 12.3 ,… 真假 true , false 文字符号 one , sometext , main ,… 字符连接 分类 示例 + ‘The name is ‘+${name} … The name is ${name} 算数运算 语法 示例 +, -, *, /, % 二元运算符 - 减号（一元运算符） 真假运算 分类 示例 and , or 二元运算符 ! , not 否定（一元运算符） 比较运算 分类 示例 &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 比较 == , != ( eq , ne ) 平等 条件运算 分类 示例 if-then (if) ? (then) if-then-else (if) ? (then) : (else) Default (value) ?: (defaultvalue) 表达式中使用内置对象 123456789101112131415161718192021222324252627282930#dates :utility methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects.#numbers :utility methods for formatting numeric objects.#strings : utility methods for String objects: contains, startsWith, prepending/appending, etc. #objects : utility methods for objects in general.#bools : utility methods for boolean evaluation. #arrays : utility methods for arrays.#lists :utility methods for lists.#sets : utility methods for sets.#maps : utility methods for maps.#aggregates : utility methods for creating aggregates on arrays or collections.#messages : utility methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;...&#125; syntax.#ids : utility methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). 预处理 1__$&#123;expression&#125;__ 循环 1234567891011121314151617181920212223242526&lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt;&lt;/tr&gt;迭代器的状态index: 当前的索引，从0开始count: 当前的索引，从1开始size：总数current:even/odd:firstlast&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod,iterStat : $&#123;prods&#125;" th:class="$&#123;iterStat.odd&#125;? 'odd'"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 判断 1234567891011121314151617if&lt;a href="comments.html" th:href="@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;" th:if="$&#123;not #lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;unless&lt;a href="comments.html" th:href="@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;" th:unless="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;switch&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt;&lt;/div&gt;&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt; &lt;p th:case="*"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 模板布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354th:fragment示例templates/footer.html&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" &lt;body&gt; &lt;div th:fragment="copy"&gt; © 2011 The Good Thymes Virtual Grocery &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;templates/index.html中使用 &lt;body&gt; ... &lt;div th:include="footer :: copy"&gt;&lt;/div&gt; &lt;/body&gt;或者 ... &lt;div id="copy-section"&gt; © 2011 The Good Thymes Virtual Grocery &lt;/div&gt; ...使用 &lt;body&gt; ... &lt;div th:include="footer :: #copy-section"&gt;&lt;/div&gt; &lt;/body&gt;th:include 和 th:replace 区别th:include 加入代码th:replace 替换代码模板传参：参数传递顺序不强制 定义&lt;div th:fragment="frag (onevar,twovar)"&gt; &lt;p th:text="$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;"&gt;...&lt;/p&gt;&lt;/div&gt; 使用&lt;div th:include="::frag ($&#123;value1&#125;,$&#123;value2&#125;)"&gt;...&lt;/div&gt;&lt;div th:include="::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)"&gt;...&lt;/div&gt; 等价于 &lt;div th:include="::frag" th:with="onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;"&gt;） 移除标签 th:remove 取值范围 all：移除所有 body：不移除自己，但移除他的子标签 tag: 只移除自己，不移除他的子标签 all-but-first：移除所有内容除第一个外 none：啥都不做 执行顺序 thymeleaf注释语法 html 看不到，并且 thymeleaf 不会执行 1&lt;!--/* This code will be removed at thymeleaf parsing time! */--&gt; and 未运行可以在 html 中看到，运行后就消失 123&lt;!--/*--&gt; &lt;div&gt;you can see me only before thymeleaf processes me! &lt;/div&gt;&lt;!--*/--&gt; 运行后才会看到 12345678910&lt;table&gt; &lt;th:block th:each="user : $&#123;users&#125;"&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt;&lt;/table&gt; 推荐下面写法（编译前看不见） 123456789&lt;table&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt; &lt;/table&gt; 文本内联th:inline 略 验证模板的正确性 略 特殊用法展示 1&lt;td th:text="$&#123;#aggregates.sum(o.orderLines.&#123;purchasePrice * amount&#125;)&#125;"&gt;23.32&lt;/td&gt;]]></content>
      <categories>
        <category>thymeleaf</category>
      </categories>
      <tags>
        <tag>thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F10%2F30%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker简介Docker是一个开源的应用容器引擎； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。 核心概念 docker主机（Host）：安装了Docker程序的机器 docker客户端（Client）：连接docker主机进行操作 docker仓库（Registry）：用来保存各种打包好的软件镜像 docker镜像（images）：软件打包好的镜像，放在docker仓库中 docker容器（Container）：镜像启动后的一个实例称为一个容器 步骤： 1、安装Docker 2、去Docker仓库找到这个软件对应的镜像 3、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器 4、对容器的启动停止就是对软件的启动停止 安装环境12345678910111213141516171、检查内核版本必须是3.10及以上uname -r2、安装dockeryum install docker3、按y确认4、启动docker# systemctl start docker# docker -v5、开机启动docker# systemctl enable docker6、停止docker# sytemctl stop docker7、进入docker镜像# docker exec -it 容器id 这种方式进入容器，退回到前台时，容器还在运行# docker attach 容器id 这种方式进入容器，退出时，容器也跟着退出8、退出docker镜像# exit 容器操作软件镜像（类似于安装程序）—-运行镜像—-产生一个容器（正在运行的软件） 步骤： 123456789101112131415161718192021222324252627281、搜索镜像# docker search tomcat2、拉取镜像# docker pull tomcat3、根据镜像启动容器# docker run --name mytomcat -d tomcat:latest4、查看运行中的容器# docker ps5、停止运行中的容器# docker stop 容器id6、查看所有容器# docker ps -a7、启动容器# docker start 容器id8、删除一个容器# docker rm 容器id9、启动一个做了端口映射的tomcat-d：后台运行-p：将主机的端口映射到容器的一个端口 主机端口：容器内部的端口10、防火墙# service firewalld status 查看防火墙状态# service firewalld stop 关闭防火墙11、查看容器的日志# docker logs container -name/container -id更多命令可以上官网https://docs.docker.com/engine/reference/commandline/docker/可以参考文档 环境搭建docker官方镜像网站 https://hub.docker.com/ 安装mysql 1docker pull mysql 使用mysql 必选按照人家给的文档来指定参数 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 做了端口映射 1docker run -p 3306:3306 --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 几个其他的高级操作 12345678docker run --name some-mysql -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/my/custom文件夹挂载到 mysqldocker容器的/ect/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在/conf/mysql文件夹下docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些参数]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（三）日志]]></title>
    <url>%2F2019%2F10%2F23%2FSpringBoot%EF%BC%88%E4%B8%89%EF%BC%89%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Spring Boot（三）日志SpringBoot文档日志框架小张：开发一个大型系统： 1、 System.out.println(“”);将关键数据打印在控制台；老板要去掉？ 2、框架来记录系统的一些信息；日志框架；zhanglogging.jar； 3、高大上的几个功能？异步模式？自动归档？xxxx？zhanglogging-good.jar？ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglooging-perfect.jar； 5、JDBC—数据库驱动； 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； 给项目中导入具体的日志实现就行了； 我们之前的日至框架都是实现的抽象层； 市面上的日志框架： JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j。。。。 日志门面 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for java） jboss-logging LOg4j JUL(java.util.logging) Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面：SLF4j； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认使用的是JCL； SpringBoot选用SLF4j和logback； SLF4j的使用如何在系统中使用SLF4j以后开发的时候，日志记录的方法调用，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法； 应该给系统里面导入slf4j的jar包和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件，使用slf4j以后，配置文件还是做成日志实现框架的配置文件； 遗留问题a（slf4j+logback）；Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出； 如何让系统中所有日志都统一到slf4j1、 将系统中其他日志框架先排除出去 2、用中间包来替换原有的日志框架 3、我们导入slf4j其他的实现 SpringBoot日志关系123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; SpringBoot使用它来做日志功能： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 总结： 1、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 2、SpringBoot也把其他的日志都替换成了slf4j 3、中间替换包？ 4、如果我们要引入其他框架？一定要把这个框架的默认日子和依赖移除掉？ SpringBoot能自动适配所有日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架以来的日志框架排除掉； 日志使用默认配置SpringBoot帮我们配置好了日志； 12345678910111213141516171819202122232425/** * 记录器 */Logger logger = LoggerFactory.getLogger(getClass());@Testvoid contextLoads() &#123; /** * 日志的级别 * 由低到高 * trace&lt;debug&lt;warn&lt;error * 可以调整需要输出的日志级别； * 日志就只会在这个级别以后的高级别生效 */ logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); /** * SpringBoot默认给我们使用的是info级别的 * 没有指定级别的就用SpringBoot默认规定级别，root级别 */ logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 12345678日志和输出格式： %d表示日期时间， %thread表示线程名称， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分隔 %msg : 日志消息， %n 是换行符 %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.wys=trace#当前项目下生成springboot.log日志#支持绝对路径#可以指定完整的路径；#logging.file.name=springboot.log#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；#使用spring.log作为默认文件logging.file.path=/spring/log#在控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger - %msg%n#指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n 指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用它默认的配置了； Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml ：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项， 由SpringBoot来解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; &lt;!--可以指定某段配置只在某个环境中生效--&gt;&lt;/springProfile&gt; 否则 1no applicable action for [springProfile] 切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j + log4j的方式：排除不相关的依赖，导入自己需要的依赖就行； 可以在官方文档中进行资料查找； 切换为log4j2：导入log4j2的启动器依赖即可；]]></content>
      <categories>
        <category>Spring Boot学习笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键大全]]></title>
    <url>%2F2019%2F10%2F23%2FIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[IDEA快捷键大全Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件（查找文件） Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处（查找接口实现类） Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC常用注解]]></title>
    <url>%2F2019%2F10%2F20%2FSpring-MVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring MVC 常用注解@Controller这个注解表示当前类是一个控制器组件，并且把这个类装进Spring容器中； 在Spring MVC中，控制器Controller负责处理DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层之后封装成一个Model，然后把该Model返回给对应的View进行展示； 123@Controllerpublic class HelloWorldController &#123;&#125; @RequestMapping作用 用于请求地址映射，可以作用于类和方法上； 参数 value：定义request请求的映射地址； method：定义request请求的方式；包括（GET，POST，OPTIONS，PUT，PATCH，DELETE，TRACE）默认接受的是GET请求，如果请求方式和定义方式不一致，那么就会请求不到指定映射地址。 params：定义request请求中必须包含的参数； headers：定义request请求中必须包含某些指定的请求头；如：@RequestMapping(value=”/test”,headers=”content-type=text/*”)说明请求中必须包含“text/html”等类型的Content-type头，才是一个匹配的请求； consumes：定义请求提交内容的类型； produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型从才返回； 1234@RequestMapping("/hello")public String hello() &#123; return "hello world quick!";&#125; @RequestParam作用 用于获取传入参数的值 参数 value：参数的名称 required：定义该传入参数是否必须，默认为true，（和RequestMapping的params属性有点类似） 1234@RequestMapping("/hello")public String hello(@RequestParam(name = "myname") String name) &#123; return name;&#125; @PathViriable作用 用于定义路径参数值 参数 value：参数的名称 required：定义传入参数是否为必须值 1234@RequestMapping("/hello/&#123;myname&#125;")public String hello(@PathVariable(name="myname") String name) &#123; return name;&#125; @ResponseBody作用 作用于方法上，可以将整个返回结果以某种格式返回，如json或者xml等 @CookieValue作用 用于获取请求的Cookie值 1234@RequestMapping("/hello")public String hello(@CookieValue(value = "JSESSIONID",defaultValue = "") String cookie) &#123; return "hello world";&#125; @ModelAttribute作用 用于把参数保存到model中，可以注解方法或者参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在session中， 这个注解在使用的时候，如果没有指定名称，就默认按照返回类型的类名称（首字母小写）作为属性名称； @SessionAttributes作用 默认情况下，Spring MVC将模型中的数据存储在request域中。当一个请求结束的时候，数据就失效了，如果想要跨页面使用，就需要用的session。而SessionAttributes注解就可以使模型中数据存储一份到session中。]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（二）配置]]></title>
    <url>%2F2019%2F10%2F20%2FSpringBoot%EF%BC%88%E4%BA%8C%EF%BC%89%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot（二）配置配置文件SpringBoot使用一个全局的配置文件，配置文件名称是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好了； YAML （YAML Ain’t Markup Language） YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言 标记语言： 以前的配置文件：大多数都使用的是XXXX.xml文件； YAML：以数据为中心，比json，xml更适合做配置文件； YAML：语法配置例子 12server: port: 8081 XML：配置 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YAML语法基本语法 key:(空格)value ： 表示一对键值对； 以空格的缩进来控制层级关系； 只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感的； 值的写法字面量：普通的值（数字，字符串，布尔）： key: Value ：字面直接来写； 字符串默认不用加上单引号或者双引号； “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: “zhangsan\n lisi”：输出：zhangsan 换行 lisi ‘’: 单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: “zhangsan\n lisi”：输出：zhangsan\n lisi 对象、Map（属性和值）（键值对）： key: value : 在下一行来写对象的属性和值的关系；注意缩进 对象还是 key: value的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: &#123;cat,dog,pig&#125; 配置文件值注入：配置文件123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2019/10/10 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 JavaBean 12345678910111213141516171819202122232425262728293031package com.wys.springboot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * ConfigurationProperties：告诉SpringBoot将本类中所有属性和配置文件中相关的配置进行绑定 * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 我们可以导入配置文件处理器，以后编写配置就有提示了； 123456789&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 中文乱码idea中默认使用的是utf-8编码，所以需要去设置中，将 File Encodings 中的编码类型全都改成utf-8，并且将最下面的把utf-8编码转换成ascill码给勾上去。 @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value; 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 松散绑定属性松散绑定表示驼峰式、下划线(_)、短横线(-) 标准方式person.firstName 方式一大写用-person.first-name 方式二大写用_person.first_name 三种方式，都可以使用推荐，属性书写方式PERSON_FIRST_NAME @PropertySource&amp;@ImportResource@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")//@Validated@PropertySource(value=&#123;"classpath:person.properties"&#125;)public class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="张三/$&#123;key&#125; 从环境变量、配置文件获取值/#&#123;spEL&#125;"&gt;&lt;/property&gt; * &lt;/bean&gt; */ //@Value("$&#123;person.last-name&#125;") //lastName必须是邮箱类型 //@Email private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("false") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring配置文件生效，加载进来；@ImportResource标注在配置类上； 1@ImportResource(value = &#123;"classpath:beans.xml"&#125;) 不来编写Spring的配置文件 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.wys.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring Boot 推荐给容器中添加组件的方式：推荐使用全注解的方式； 配置类 ==== Spring配置文件 使用@Bean给容器中添加组件 12345678910111213@Configurationpublic class MyAppConfig &#123; /** * 将方法的返回值添加到容器中，容器中这个组件默认id就是方法名 * @return */ @Bean public HelloService helloService() &#123; System.out.println("给容器中添加组件了"); return new HelloService(); &#125;&#125; 配置文件占位符随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int&#123;1024,65536&#125;&#125; 占位符获取之前配置的，如果没有可以使用:指定默认值 123456789person.last-name=李四$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2019/10/10person.boss=falseperson.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 Profile概念 Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境 多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-(profile).properties/yml 默认使用application.properties配置； yml支持多文档块模式 12345678910111213141516server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定profile 在配置文件中指定 spring.profiles.active=dev 命令行： –spring.profiles.active=dev 可以直接在测试的时候，配置传入命令行参数 虚拟机参数： -Dspring.profiles.active=dev 配置文件加载位置spring boot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring Boot的默认配置文件 file:./config/ file:./ classpath:/config/ classpath:/ 以上是按照优先级从高到底的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 我们也可以通过配置spring.config.location来改变默认配置 Spring Boot会从这四个位置全部加载主配置文件：互补配置； 外部配置加载顺序Spring Boot支持多种外部配置方式 这些方式的优先级如下： 命令行参数 java -jar spring-boot-01-config-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context.path=/abc 多个配置用空格分开；–配置项=值 来自java:comp/env的JNDI属性 java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找 优先加载带profile jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 自动配置原理： SpringBoot启动的时候加载朱配置类，开启了自动配置功能@EnableAutoConfiguration @EnableAutoConfiguration作用： 利用AutoConfigurationImportSelector给容器中导入了一些组件 可以查看selectImports()方法的内容； 1234springFactoriesLoader.loadFactoryName()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把它们添加在容器中 将类路径下的 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到了容器中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 每一个自动配置类进行自动配置功能； 以HttpEncodingAutoConfiguration来为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334@Configuration( //表示这是一个配置类，以前编写的配置文件一样，也可以给容器添加组件 proxyBeanMethods = false)@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中@ConditionalOnWebApplication( //Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；判断当前应用是否是web应用，如果是，当前配置类生效 type = Type.SERVLET)@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断当前项目有没有这个类，CharacterEncodingFilter；Spring MVC中进行乱码解决的过滤器；@ConditionalOnProperty( //判断配置文件是否存在某个配置spring.http.encoding.enabled;如果不存在，判断也是成立的 //即使我们配置文件中不配置spring.http.encoding.enabled=true,也是默认生效的； prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参的构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean //给容器添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 123456@ConfigurationProperties ( //从配置文件中获取指定的值和bean的属性进行绑定 prefix = "spring.http")public class HttpProperties &#123; private boolean logRequestDetails; private final HttpProperties.Encoding encoding = new HttpProperties.Encoding(); 精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfiguration：自动配置类； 给容器中添加组件 xxxxProperties：封装配置文件中相关属性； 细节Conditional@Conditional派生注解（可以自己去了解一下原生的作用） 作用：必须是@Conditional指定的条件成立，才给容器添加组件，配置里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符号要求 @ConditionalOnBean 容器中存在指定的Bean @ConditionalOnMissingBean 容器中不存在指定的Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean,或者这个Bean是首先Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在制定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定条件下才能生效 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； Positive matches:（自动配置类启用的） Negative matches：（没有启用，没有匹配成功的自动配置类）]]></content>
      <categories>
        <category>Spring Boot学习笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（一）入门]]></title>
    <url>%2F2019%2F10%2F19%2FSpringBoot%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot入门SpringBoot 简介 简化Spring应用开发的框架； 整个Spring技术栈的大整合； J2EE开发的一站式解决方案； 微服务2014年martin fowler提出的微服务； 微服务是一种架构风格； 一个应用应该是一组小型服务；可以通过HTTP的方式互通； 单体应用：ALL IN ONE； 把整个应用打成war包就可以部署到服务器上； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 详细参照微服务文档 Spring Boot优缺点Spring Boot 官网 Spring Boot 来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。 底层就是Spring技术栈 SpringBoot优点 快速创建独立运行的Spring项目以及主流框架集成 快速嵌入式的Servlet容器，应用无需打成war包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 SpringBoot缺点 入门容易，精通难 SpringBoot封装机制不好懂 对底层api必须特别了解 Spring Boot 例子HelloWorld一个功能 浏览器发送hello请求，服务器接受请求并处理，响应hello world字符串。 1. 创建maven工程 jar包 2. 导入SpringBoot需要的依赖 官网中可以查找到依赖 Maven依赖 12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 编写一个主程序，启动Spring Boot应用 123456789101112131415161718package com.wys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.swing.*;/** * Spring应用 * @SpringBootApplication 来标注一个主程序类,说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldApplication.class,args); &#125;&#125; 4. 编写相关的Controller、Service 123456789101112131415package com.wys.HelloController;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5. 运行主程序测试 6. 简化部署 可执行jar包 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 导入这个maven插件就行，就可以将这个应用打成jar包，直接使用java -jar的命令进行执行 HelloWorld探究POM文件父项目 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本； 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web; spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成了一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 主程序类，主入口类1234567891011121314151617package com.wys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * Spring应用 * @SpringBootApplication 来标注一个主程序类,说明这是一个Spring Boot应用 * 主程序要放在包的位置，不然找不到页面 */@SpringBootApplicationpublic class HelloWorldApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldApplication.class,args); &#125;&#125; @SpringBootApplication： Spring Boot应用标注在某个类上，说明这个类是SpringBoot的主配置类，说明Spring Boot 就应该运行这个累的main方法，来启动SpringBoot应用。 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)@ConfigurationPropertiesScanpublic @interface SpringBootApplication &#123; @SpringBootConfiguration： Spring Boot的配置类； 标注在某个类上，表示这是一个Spring Boot的配置类； @Configuration：配置类上来标注这个注解； 配置类 —— 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置； 这个注解告诉SpringBoot开启自动配置功能；这样自动配置才能生效 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage：自动配置包 @Import({Registrar.class})； Spring的底层注解@Import，给容器导入一个组件；导入的组件Registrar.class 将主配置类（@SpringBootApplication标注的类）所在的包及所有子包里面的所有组件扫描到Spring容器中。 @Import({AutoConfigurationImportSelector.class})： 给容器中导入组件 AutoConfigurationImportSelector：导入哪些组件的选择器 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器导入所有组件，并配置好这些组件； 有了自动配置类，就免去了我们手动编写配置注入功能组件的工作； 以前我们需要自己配置的东西，自动配置类都帮我们配置了； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包中 使用Spring Initializer快速创建Spring Boot项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目 默认生成的Spring Boot项目： 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中的目录结构 static文件夹：保存所有的静态资源；js文件，css文件，图片文件等； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker，thymeleaf）； application.properties：Spring Boot应用的配置文件；]]></content>
      <categories>
        <category>Spring Boot学习笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring和MyBatis整合]]></title>
    <url>%2F2019%2F10%2F15%2FSpring%E5%92%8CMyBatis%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring和MyBatis整合因为学完了Spring和MyBatis，SpringMVC只看了书，没有敲实际代码，所以现在整合一下Spring和MyBatis然后敲个代码练练手，之后还会更新SSM全部整合。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mybatis_pratices_day(4)&lt;/groupId&gt; &lt;artifactId&gt;mybatis_pratices_day(4)&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context Spring应用上下文 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core Spring核心容器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans Bean模块提供BeanFactory，它是一个工厂模型的复杂实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop 为Spring提供了面向切面的编程方式 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring 整合Spring和MyBatis所需要的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 c3p0数据连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j 提供日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis mybatis核心jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit 测试环境 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test Spring单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring-config.xml因为要整合Spring和MyBatis所以不再使用mybatis-config.xml，统一整合到spring-config.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt; &lt;!--引入配置文件 context:property-placeholder --&gt; &lt;context:property-placeholder location="jdbc-config.properties"&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--配置信息--&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="10"&gt;&lt;/property&gt; &lt;property name="maxIdleTime" value="30"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="100"&gt;&lt;/property&gt; &lt;property name="minPoolSize" value="10"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--mybatis配置--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--加载数据源--&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--扫描mapper文件--&gt; &lt;property name="mapperLocations" value="com/dao/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--dao接口所在包名，Spring会自动查找其下的类 Mybatis MapperScannerConfigurer 自动扫描 将Mapper接口生成代理注入到Spring 整合spring与mybatis --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.dao"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 事务管理 事务是数据库中的概念，就是对数据库的一组操作，由一条或多条sql组成。 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml由于在spring-config.xml中就可以搜索mapper文件了，所以我就没有用这个 dao1234567891011121314151617181920package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * User持久层 */@Mapperpublic interface UserDao &#123; /** * 查找所有用户 * @return */ List&lt;User&gt; selectAllUser();&#125; mapper.xml1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;select id="selectAllUser" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类123456789101112131415161718192021package com.test;import com.dao.UserDao;import com.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;"classpath:spring-config.xml"&#125;)public class UserTest &#123; @Autowired private UserService userService; @Test public void testDao() &#123; System.out.println(userService.selectAllUser()); &#125;&#125; 整个上面就是一个完整的整合过程，剩下的内容就需要自己添加了 问题在整合过程中出现了很多很多问题，最后发现是在spring-config.xml中配置mybatis时，多写了个参数 1234567&lt;!--mybatis配置--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--加载数据源--&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--扫描mapper文件--&gt; &lt;property name="mapperLocations" value="com/dao/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; 这个地方配置了很长时间，是最容易出问题的地方，以后要注意。 上面就是spring与mybatis整合的过程，由于Spring和Spring MVC相近的关系，所以在此配置信息的基础上，加进去spring mvc应该就可以用了。 如果还有问题，我还会继续记录下来。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring和MyBatis整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（二）]]></title>
    <url>%2F2019%2F10%2F11%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（二）课前提问1. 介绍一下maven： 答： maven是一个纯java编写的，具有开源，跨平台，标准化的项目管理工具。 2. 跨平台的意思： 答：跨操作系统平台和IDE平台。 3. IDE是什么： 答： IDE是一个集成开发环境，例如 eclipse，idea等工具。 4. 标准化是什么意思： 答：项目构建标准化，可以跨操作系统平台，项目结构标准化，可以跨IDE平台 上课内容手工创建maven项目包的命名包的名称一般由四到五部分构成： 第一部分：甲方公司域名的倒叙，开发方域名倒叙。原因是为了保证当前项目的全球唯一性。 例如：cn.edu.aynu 和 ip 对应一一关系，之前用的ipv4，不够用，现在都在用ipv6，用不完。 第二部分：项目名称。为了保证在当前公司内部当前项目的唯一性。 例如： cn.edu.aynu.sms 第三部分：模块名称。为了保证资源在当前项目中的唯一性。 例如： cn.edu.aynu.sms.aaa.bbb.ccc 第四部分：功能顶层包。其是为了体现当前包中资源的功能特点。 例如：cn.edu.aynu.sms.aaa.bbb.ccc.service 例如：cn.edu.aynu.sms.aaa.bbb.ccc.dao 第五部分：impl子包。用于存放其父包中接口的实现类。 例如：cn.edu.aynu.sms.aaa.bbb.ccc.service.impl 项目结构标准化 maven常用命令查看命令帮助 mvn -h 清理target mvn clean （这个命令一般都是与其他命令结合使用的） 编译 mvn clean compile 测试 mvn clean test 打包 mvn clean package 安装包 mvn clean install 创建项目骨架（maven3） mvn archetype:generate 创建项目骨架（maven2） mvn org.apache.maven.plugins:maven-archetype-plugin:2.0-alpha-5:generate 查看当前项目已解析依赖 mvn dependency:list 查看当前项目的依赖树 mvn dependency:tree 分析当前项目的依赖 mvn dependency:analyze 将项目构建输出的构建部署到配置对应的远程仓库 mvn clean deploy …… 剩下的感觉都用不到，先不写，用到的时候再记录]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F10%2F07%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax学习介绍AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面 写法1234567891011121314151617181920//方式一:使用post请求的方式,不通过url传参,采用data传参 $.ajax(&#123; url:"$&#123;pageContext.request.contextPath&#125;/请求的控制器",//访问的地址 type:"post", data:&#123;key:value&#125;, dataType:'text',//后台返回的数据格式类型 //回调函数 success:function(data,status) &#123; &#125;&#125;)//方式二:使用get请求的方式，通过url传参$.ajax(&#123; url:"$&#123;pageContext.request.contextPath&#125;/请求的控制器?参数", type:"get", dataType:'text', success:function(data,status) &#123; &#125;&#125;)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC学习笔记（一）]]></title>
    <url>%2F2019%2F10%2F07%2FSpring-MVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring MVC学习笔记（一）Spring MVC的优势Spring 框架提供了构建Web应用程序的全功能MVC模块——Spring MVC。Spring MVC框架提供了一个DispatcherServlet作用前端控制器来分派请求，同时提供灵活的配置处理程序映射，视图解析，语言环境和主题解析，并支持文件上传。Spring MVC还包含多种视图技术，例如 Java Server Pages（JSP），Velocity，Tiles，iText和POI等。Spring MVC 分离了控制器，模型对象，分派器以及处理程序对象的角色，这种分离让他们更容易进行定制。 Spring MVC的特点 拥有强大的灵活性，非侵入性和可配置性。 提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象。 分工明确，包括控制器，验证器，命令对象，模型对象，处理程序映射视图解析器，等等，每一个功能实现由一个专门的对象完成。 可以自动绑定用户输入，并正确地转换数据类型。例如，Spring MVC能自动解析字符串，并将其设置为模型的int或float类型的属性。 使用一个名称/值Map对象实现更加灵活的模型数据传输。 内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式。 支持国际化，支持根据用户区域显示多国语言，并且国际化的配置非常简单。 支持多种视图技术，最常见的有JSP技术以及其他技术，包括Velocity和FreeMarker。 提供了一个简单而强大的JSP标签库，支持数据绑定功能，使得编写JSP页面更加容易。 第一个应用程序创建maven项目 选择这个创建 改变项目部署路径 导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置web.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--welcome pages--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置springmvc DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置dispatcher.xml作为mvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--把applicationContext.xml加入到配置文件中--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 配置dispatcher-servlet.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--此文件负责整个mvc中的配置--&gt; &lt;!--启用spring的一些annotation --&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源映射--&gt; &lt;!--本项目把静态资源放在了webapp的statics目录下，资源映射如下--&gt; &lt;mvc:resources mapping="/css/**" location="/statics/css/"/&gt; &lt;mvc:resources mapping="/js/**" location="/statics/js/"/&gt; &lt;mvc:resources mapping="/image/**" location="/statics/images/"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--这句要加上，要不然可能会访问不到静态资源，具体作用自行百度--&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id="defaultViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/view/"/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;property name="exposeContextBeansAsAttributes" value="true"/&gt; &lt;/bean&gt; &lt;!-- 自动扫描装配 --&gt; &lt;context:component-scan base-package="com.controller"/&gt;&lt;/beans&gt; 配置spring-config.xml 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; Controller类 123456789101112131415161718package com.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("/home")public class HelloController &#123; @RequestMapping("/welcome") public String welcome()&#123; return "welcome"; &#125; @RequestMapping("/index") public String index() &#123; return "index"; &#125;&#125; 运行]]></content>
      <categories>
        <category>Spring MVC学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三）]]></title>
    <url>%2F2019%2F09%2F26%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记（三）目标这部分内容是为了实现一次mybatis的增删改查（CRUD）操作，以及一些模糊查询等内容。 实现因为增删改查内容比较集中，所以这次完成操作后，把代码整理到一起 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", address='" + address + '\'' + ", sex='" + sex + '\'' + ", birthday=" + birthday + '&#125;'; &#125;&#125; 持久层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.dao;import com.pojo.User;import java.util.List;/** * * 用户持久层接口 */public interface UserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll(); /** * 根据ID查询 * @param id * @return */ User findOneById(Integer id); /** * 保存用户 * @param user * @return */ int saveUser(User user); /** * 更新用户 * @param user * @return */ int updateUser(User user); /** * 删除用户 * @param id * @return */ int deleteUser(Integer id); /** * 模糊查询用户信息 * @param name * @return */ List&lt;User&gt; findByName(String name); /** * 获取用户总记录数 * @return */ int findTotal();&#125; mybatis-config配置文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置个mysql环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?useUnicoder=true&amp;amp;characterEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射文件--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper映射文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;!--查询所有操作--&gt; &lt;select id="findAll" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt; &lt;!--根据Id查询--&gt; &lt;select id="findOneById" resultType="com.pojo.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--插入用户操作--&gt; &lt;insert id="saveUser" parameterType="com.pojo.User"&gt; &lt;!--配置插入成功后，获取插入数据的id keyproperty id 实体类的 keyColumn id 数据库的 resultType 映射值类型 order 在什么时候执行 不写这个的时候，执行完插入后，id值为null，写了之后可以获取到具体id值 --&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id() &lt;/selectKey&gt; insert into User(username, address, sex, birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;) &lt;/insert&gt; &lt;!--更新用户操作--&gt; &lt;update id="updateUser" parameterType="com.pojo.User"&gt; update User set username = #&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--删除用户操作--&gt; &lt;delete id="deleteUser" parameterType="Integer"&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt; &lt;!--根据用户名称查询--&gt; &lt;select id="findByName" parameterType="String" resultType="com.pojo.User"&gt; &lt;!-- 参数占位符 select * from user where username like #&#123;username&#125; --&gt; &lt;!--字符串拼接写法，比较的话上面那个好--&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!--测试用户总数量--&gt; &lt;select id="findTotal" resultType="int"&gt; select count(id) from user &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;/** * MyBatis的CRUD操作 */public class MyBatisTest &#123; private SqlSession session; private UserDao userDao; @Before public void before() throws Exception&#123; InputStream in = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); session = sqlSessionFactory.openSession(); userDao = (UserDao)session.getMapper(UserDao.class); &#125; @After public void after() &#123; session.commit(); session.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User i : users) &#123; System.out.println(i); &#125; &#125; /** * 根据ID查询 */ @Test public void testfindOneById() &#123; User user = userDao.findOneById(1); System.out.println(user); &#125; /** * 测试添加用户 */ @Test public void testSaveUser() &#123; User user = new User(); user.setUsername("testSaveUser--1"); user.setSex("女"); user.setAddress("北京"); user.setBirthday(new Date()); //保存操作之前 //System.out.println(user); userDao.saveUser(user); //保存操作之后 System.out.println(user); &#125; /** * 测试用户更新信息 */ @Test public void testUpdateUser() &#123; User user = new User(); //因为没有查询所以，只能指定修改人id user.setId(2); user.setUsername("testUpdateUser"); user.setAddress("北京"); user.setSex("女"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; /** * 测试用户删除操作 */ @Test public void testDeleteUser() &#123; userDao.deleteUser(1); &#125; /** * 根据用户姓名进行模糊查询 */ @Test public void testUserByName() &#123; //模糊查询是需要有百分号的，但是xml文件中的执行语句是没有的，需要自己添加 //第一种写法参数占位符 这个好，使用了预处理 //List&lt;User&gt; users = userDao.findByName("%老%"); //第二种写法字符串拼接写法 List&lt;User&gt; users = userDao.findByName("老"); for(User i : users) &#123; System.out.println(i); &#125; &#125; @Test public void testfindTotal() &#123; int total = userDao.findTotal(); System.out.println(total); &#125;&#125; 数据库文件的话自己可以根据上面的实体类来创建 详细内容都在代码上有注释，可以参考参考]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE框架第二次作业]]></title>
    <url>%2F2019%2F09%2F26%2FJAVAEE%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[JAVAEE框架第二次作业一对多（one-to-many）分析首先思考一下，一对多的关系都有哪些，很容易我们就可以想到，文章，一个人可以发很多篇文章，但是每篇文章只能对应一个人，这就是一对多关系，除此之外，还可以想到父子关系，一个父亲可以有多个孩子，但是每个孩子只能对应一个父亲，了解完关系之后，我们就能开始着手写了。 建表我们以作者和文章的关系来创建数据库的表，首先了解作者和文章的属性，然后确定数据库表的主键和外键。 作者（Author）属性: 作者编号，作者名称；其中主键是作者编号。编号为自增序列。 文章（Article）属性： 文章编号，文章名称，文章内容； 其中主键是文章编号，编号是自增序列。 建表： 理清楚上面关系后我们建表开始，sql命令如下： 12345678910111213create table article( article_id int not null auto_increment, name varchar(35) not null, content varchar(255), author_id int not null, primary key(article_id));create table author( author_id int not null auto_increment, name varchar(35) not null, primary key(author_id)); 这样我们就有了一个article表和author表，然后就可以写后台了。 pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pojo;import java.util.AbstractList;import java.util.ArrayList;import java.util.List;/** * 作者的实体类 */public class Author &#123; //作者编号 private int id; //作者名称 private String name; //作者所著文章 建立一对多关系 private List&lt;Article&gt; articles; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Article&gt; getArticles() &#123; return articles; &#125; public void setArticles(List&lt;Article&gt; articles) &#123; this.articles = articles; &#125; @Override public String toString() &#123; return "Author&#123;" + "id=" + id + ", name='" + name + '\'' + ", articles=" + articles + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.pojo;/** * 文章的实体类 */public class Article &#123; //文章编号 private int id; //文章名称 private String name; //文章内容 private String content; //作者 建立多对一关系 private Author author; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Author getAuthor() &#123; return author; &#125; public void setAuthor(Author author) &#123; this.author = author; &#125; @Override public String toString() &#123; return "Article&#123;" + "id=" + id + ", name='" + name + '\'' + ", content='" + content + '\'' + ", author=" + author + '&#125;'; &#125;&#125; 导入依赖（包名省略） 创建持久层 12345678910111213141516171819202122package com.dao;import com.pojo.Article;import com.pojo.Author;import java.util.List;/** * 作者的持久层 * 我们这个只需要完成一个一对多查询就行 * 所以只写了一个方法 */public interface AuthorDao &#123; /** * 查询作者所有文章 * @param id * @return */ Author selectArticlesList(int id);&#125; 创建mybatis配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;!--这个密码是我自己的，有需要可以修改--&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;!--可以XML配置，可以注解，这里就用xml配置了--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/Author.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建mapper映射文件 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.AuthorDao"&gt; &lt;!--一对多写法--&gt; &lt;resultMap id="AuthorMap" type="com.pojo.Author"&gt; &lt;id column="author_id" property="id"&gt;&lt;/id&gt; &lt;result column="author_name" property="name"&gt;&lt;/result&gt; &lt;collection property="articles" ofType="com.pojo.Article"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="name" property="name"&gt;&lt;/result&gt; &lt;result column="content" property="content"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--别名要加空格--&gt; &lt;select id="selectArticlesList" parameterType="int" resultMap="AuthorMap"&gt; select a.id author_id,a.name author_name, b.* from author a left join article b on a.id = b.author_id where a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import java.io.*;import java.util.List;import com.dao.AuthorDao;import com.pojo.Article;import com.pojo.Author;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;public class AuthorTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before() throws IOException &#123; InputStream in = Resources.getResourceAsStream("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); &#125; /** * 获取作者所写的所有文章 */ @Test public void getArticles() &#123; SqlSession session = sqlSessionFactory.openSession(); AuthorDao authorDao = session.getMapper(AuthorDao.class); Author author = authorDao.selectArticlesList(1); for(Article i : author.getArticles()) &#123; System.out.println(i.getName()); &#125; &#125;&#125; 多对一多对一在一对一基础上进行修改，增加了一个持久层和mapper文件，就是根据多个文章查找到作者信息。 持久层 1234567891011121314151617package com.dao;import com.pojo.Article;import com.pojo.Author;/** * 文章持久层 */public interface ArticleDao &#123; /** * 根据帖子ID查找作者信息 * @param id * @return */ Article selectAuthorByArticle(int id);&#125; mapper 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dao.ArticleDao"&gt; &lt;resultMap id="ArticleMap" type="com.pojo.Article"&gt; &lt;id column="article_id" property="id"&gt;&lt;/id&gt; &lt;result column="article_name" property="name"&gt;&lt;/result&gt; &lt;result column="content" property="content"&gt;&lt;/result&gt; &lt;!--存储查询的用户所属信息--&gt; &lt;association property="author" javaType="com.pojo.Author"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="name" property="name"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectAuthorByArticle" resultMap="ArticleMap" parameterType="int"&gt; select b.* from article a,author b where b.id= a.author_id and a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789@Testpublic void getAuthor() &#123; SqlSession session = sqlSessionFactory.openSession(); ArticleDao articleDao = session.getMapper(ArticleDao.class); Article article = articleDao.selectAuthorByArticle(1); System.out.println(article.getAuthor().getName()); session.close();&#125; 大概就上面那么多了，剩下的等上完课再进行修改吧。。。 还是有很多知识都不懂，很难受。。。]]></content>
      <categories>
        <category>JAVAEE框架作业</category>
      </categories>
      <tags>
        <tag>JAVAEE框架作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（四）]]></title>
    <url>%2F2019%2F09%2F23%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（四）Spring AOP的基本概念AOP（Aspect-Oriented Programming）即面向切面编程，他与OOP（Object-Oriented Programming,面向对象编程）相辅相成。 在OOP中，以类作为程序的基本单元，而AOP中的基本单元是Aspect（切面）。Struts2的拦截器设计就是基于AOP的思想，是一个比较经典的应用。 在业务处理代码中通常由日志记录，性能统计，安全控制，事务处理，异常处理等操作，尽管使用OOP可以封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中，因此，采用OOP等日志记录等操作不仅增加了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题，AOP思想应允而生。 AOP采取横向抽取机制，即将分散在各个方法中的重复代码提取出来，然后在程序编译或者运行阶段，将这些抽取出来的代码应用到需要执行的地方。这种横向抽取机制采用传统的OOP是无法办到的，因为OOP实现的是父子关系的纵向重用。但是AOP不是OOP的替代品，而是OOP的补充，他们是相辅相成的。 在AOP中，横向抽取机制的类与切面的关系如图所示： AOP的术语 名称 意义 切面 切面（Aspect）是指封装横切到系统功能（例如事务处理）的类。 连接点 连接点（Joinpoint）是指程序运行中的一些时间点，例如方法的调用或异常的抛出。 切入点 切入点（Pointcut）是指需要处理的连接点。在Spring Aop中，所有的方法执行都是连接点，二切入点是一个面熟信息，他修饰的是连接点，通过切入点确定那些连接点需要被处理。 通知 通知（Advice）是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。 引入 引入（Introduction）允许在现有的实现类中添加自定义的方法和属性 目标对象 目标对象（Target Object）是指所有被通知的对象。如果AOP框架使用运行时代代理的方式（动态AOP）来实现切面，那么通知对象总是一个代理对象。 代理 代理（Proxy）是通知应用到目标对象之后被动态创建的对象。 织入 织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术，AOP织入有3种方式：编译器织入，需要有特殊的java编译器；类装载期织入，需要有特殊的类装载器；动态代理织入，在运行期为目标类添加通知生成子类的方式。Spring AOP框架默认采用动态代理织入，而AspectJ（基于java语言的AOP框架）采用编译期织入和类装载期织入。 AOP依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 这些是aop依赖的核心部分 剩下的就是spring核心jar包了，此处就不一一列举 基于XML的AOPxml配置 12345678910111213141516&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* *.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref="MyAspect"&gt; &lt;!--前置通知--&gt; &lt;aop:before method="beforeAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt; &lt;!--后置通知--&gt; &lt;aop:after method="afterAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method="exceptionAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after-throwing&gt; &lt;!--最终通知--&gt; &lt;aop:after-returning method="finallyAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after-returning&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 实现类 12345678910111213141516171819202122232425262728293031323334353637package com.util;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面 */public class MyAspect &#123; public void beforeAdvice() &#123; System.out.println("这是前置通知!-----比如创建连接对象"); &#125; public void afterAdvice() &#123; System.out.println("这是后置通知!------比如提交事务"); &#125; public void finallyAdvice() &#123; System.out.println("这是最终通知-------比如关闭连接"); &#125; public void exceptionAdvice() &#123; System.out.println("这是异常通知-------比如回滚事务"); &#125; public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println("这是前置通知!-----比如创建连接对象"); try&#123; joinPoint.proceed(); System.out.println("这是后置通知!------比如提交事务"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("这是异常通知-------比如回滚事务"); &#125;finally &#123; System.out.println("这是最终通知-------比如关闭连接"); &#125; &#125;&#125; 环绕通知 123456789&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* *.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref="MyAspect"&gt; &lt;aop:around method="aroundAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 执行顺序 前置通知： 在方法执行前执行 后置通知： 在方法执行后执行，如果有异常，就不会执行这个 最终通知： 执行完所有通知之后执行 异常通知： 发生异常的时候执行 环绕通知： 包含了以上四种通知类型 基于注解的AOP注解 名称 作用 @Aspect 表示这是一个切面类 @Before 在方法执行前执行 @After 在方法执行后执行，如果有异常，就不会执行这个 @AfterReturning 执行完所有通知之后执行 @AfterThrowing 发生异常的时候执行 @Around 包含了以上四种通知类型 @Pointcut 切入点表达式 切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.util;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * 切面 */@Aspect@Componentpublic class MyAspect &#123; @Pointcut("execution(* *.*(..))") public void pointcut()&#123;&#125; @Before("pointcut()") public void beforeAdvice() &#123; System.out.println("这是前置通知!"); &#125; @After("pointcut()") public void afterAdvice() &#123; System.out.println("这是后置通知!"); &#125; @AfterReturning("pointcut()") public void finallyAdvice() &#123; System.out.println("这是最终通知"); &#125; @AfterThrowing("pointcut()") public void exceptionAdvice() &#123; System.out.println("这是异常通知"); &#125; @Around("pointcut()") public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println("前置通知"); try&#123; joinPoint.proceed(); System.out.println("后置通知"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("异常通知"); &#125;finally &#123; System.out.println("最终通知"); &#125; &#125;&#125; 一定要给这个类使用Component注解，不然不会把这个加入Spring容器中 在XML中开启注解支持 12&lt;!--启动基于注解的Aspect的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 测试类不变 结果和上面一致 课后习题1. 什么是AOP？AOP有哪些术语？为什么要学习AOP编程？ AOP就是面向切面编程，术语的话参考上面的AOP术语。 AOP可以处理OOP不能处理的问题，AOP可以减少大量代码编写，抽取重复代码块，增加代码复用率，减少耦合性，使开发者逻辑更清晰，工作更简单。 2. 在Java中有哪些常用的动态代理技术？ Proxy Cglib 3. AspectJ框架的AOP开发方式有几种？ 基于XML的开发方式 基于注解的开发方式]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit单元测试]]></title>
    <url>%2F2019%2F09%2F23%2FJunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[整合JUnit单元测试JUnit概述JUnit是一个基于java语言的单元测试框架，Junit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。 依赖所依赖的导包 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; spring-test是整合spring时所需要依赖的包 junit就是进行单元测试所需要依赖的包 还需要其他的Spring核心jar包，这就不一一列举了 注解RunWith@RunWith：就是一个运行器 @RunWith(JUnit4.class)：就是指用JUnit4来运行 @RunWith(SpringJUnit4ClassRunner.class)： 让测试运行于Spring测试环境 @RunWith(Suite.class)： 一套测试集合 ContextConfiguration概念： Spring整合JUnit4测试时，使用注解引入多个配置文件 单个文件： @ContextConfiguration(Locations=&quot;classpath:spring-config.xml&quot;) @ContextConfigruation(classes=Configuration.class) 多个文件： @ContextConfiguration(locations={&quot;classpath:spring-config1.xml&quot;,&quot;classpath:spring-config2.xml&quot;}) 样例123456789101112131415161718192021222324252627package com.test;import com.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * 初始化Spring容器 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:spring-config.xml")public class AccountTest &#123; @Resource(name="accountService") private AccountService accountService; @Test public void Test() &#123; accountService.saveAccount(); &#125;&#125;]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE框架第一次作业]]></title>
    <url>%2F2019%2F09%2F18%2FJAVAEE%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[JAVAEE框架第一次作业分析&nbsp;&nbsp;&nbsp;&nbsp;首先，我之前认为是为了优化实现类中的方法，所以想到了整合Spring然后利用AOP的事务通知来使持久层的实现类中方法解耦，后来才明白原来是直接将实现类中的方法整合在测试类中进行使用（是我太菜了，确信！） 代码整合删除实现类 &nbsp;&nbsp;&nbsp;&nbsp;这个过程是为了使测试类中提示错误，从而有针对性，便于修改 修改测试类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.abc;import static org.junit.Assert.assertTrue;import com.abc.beans.Student;import com.abc.dao.IStudentDao;import com.abc.utils.MyBatisUtil;import org.apache.ibatis.session.SqlSession;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Unit test for simple App. */public class MyTest&#123; private IStudentDao dao; private SqlSession sqlSession; @Before public void before() throws IOException &#123; sqlSession = MyBatisUtil.getSqlSession(); dao = sqlSession.getMapper(IStudentDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; /** * Rigorous Test :-) */ //插入学生信息 @Test public void Test01() &#123; Student student = new Student("王五",21,80.5); System.out.println("插入前："+student); dao.insertStudent(student); sqlSession.commit(); System.out.println("插入后："+student); System.out.println("插入成功！"); &#125; //获取新插入学生id @Test public void Test02() &#123; Student student = new Student("李四",19,90.5); System.out.println("插入前："+student); dao.insertStudentCatchId(student); sqlSession.commit(); System.out.println("插入后："+student); System.out.println("插入成功！"); &#125; //删除学生信息 @Test public void Test03() &#123; dao.deleteStudentById(29); sqlSession.commit(); System.out.println("删除成功！"); &#125; //修改学生信息 @Test public void Test04() &#123; Student student = new Student("小绿",22,96); student.setId(30); dao.updateStudent(student); sqlSession.commit(); System.out.println("修改成功！"); &#125; //查询全部学生信息List @Test public void Test05() &#123; List&lt;Student&gt; students = dao.selectAllStudent(); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //查询全部学生信息Map @Test public void Test06() &#123; Map&lt;String,Student&gt; map = dao.selectAllStudentMap(); System.out.println(map.get("李四")); &#125; //按照id查询学生信息 @Test public void Test07() &#123; Student student = dao.selectStudentById(30); System.out.println(student); &#125; //按照name查询学生信息 @Test public void Test08() &#123; List&lt;Student&gt; students = dao.selectStudentByName("小绿"); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息1 //把多个参数封装到对象 @Test public void Test09() &#123; Student student = new Student("小",20,-1); List&lt;Student&gt; students = dao.selectStudentByCondition(student); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息2 //把多个查询条件封装到map @Test public void Test10() &#123; Map map = new HashMap(); Student student1 = new Student(null,18,-1); Student student2 = new Student(null,22,-1); map.put("stu1",student1); map.put("stu2",student2); List&lt;Student&gt; students = dao.selectStudentByCondition2(map); for (Student s:students)&#123; System.out.println(s); &#125; &#125;&#125; Mapper配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.abc.dao.IStudentDao"&gt; &lt;!-- 1.parameterType可以省略，但若不省略一定把后边的类型填写正确 2.sql语句中value中的内容，必须是#&#123;&#125;，其中name，age，score指的 是传入参数对象的属性，其底层是通过反射机制从参数对象的get方法获取相应的属性值 --&gt; &lt;insert id="insertStudent" parameterType="com.abc.beans.Student"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;/insert&gt; &lt;insert id="insertStudentCatchId"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select last_insert_id() &lt;!--select @@identity--&gt; &lt;/selectKey&gt; &lt;/insert&gt; &lt;delete id="deleteStudentById" parameterType="int"&gt; delete from student where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id="updateStudent"&gt; update student set name=#&#123;name&#125;,age=#&#123;age&#125;,score=#&#123;score&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--resultType不是最终需要的结果类型，而是查询出每一条数据封装的结果类型--&gt; &lt;select id="selectAllStudent" resultType="Student"&gt; select id,name,age,score from student &lt;/select&gt; &lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id = #&#123;xx&#125; &lt;/select&gt; &lt;select id="selectStudentByName" resultType="Student"&gt; &lt;!--select id,name,age,score from student where name like '%小%'--&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' &lt;!--select id,name,age,score from student where name like concat('%',#&#123;name&#125;,'%')--&gt; &lt;!--select id,name,age,score from student where name like '%$&#123;value&#125;%'--&gt; &lt;/select&gt; &lt;select id="selectStudentByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' and age &amp;lt; #&#123;age&#125; &lt;/select&gt; &lt;select id="selectStudentByCondition2" resultType="Student"&gt; &lt;!--select id,name,age,score from student where age &gt; #&#123;min&#125; and age &amp;lt; #&#123;max&#125;--&gt; select id,name,age,score from student where age &gt; #&#123;stu1.age&#125; and age &amp;lt; #&#123;stu2.age&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;中可以写什么内容： 1.若传入参数为基本数据类型，可以为任意字符，起占位符的作用 2.若传入参数为对象，必须为对象的属性 3.若传入参数为map 1）如果map中的值为基础数据类型，可以放map的key 2）如果map中的值为对象，可以放map的key.属性 --&gt;&lt;/mapper&gt; 由于配置文件和持久层中有些方法命名不匹配，所以我都进行了修改，持久层代码 12345678910111213141516171819202122232425262728package com.abc.dao;import com.abc.beans.Student;import java.util.List;import java.util.Map;public interface IStudentDao &#123; void insertStudent(Student student); void deleteStudentById(int id); void insertStudentCatchId(Student student); void updateStudent(Student student); List&lt;Student&gt; selectAllStudent(); Map&lt;String, Student&gt; selectAllStudentMap(); Student selectStudentById(int id); List&lt;Student&gt; selectStudentByName(String name); List&lt;Student&gt; selectStudentByCondition(Student student); List&lt;Student&gt; selectStudentByCondition2(Map map);&#125; &nbsp;&nbsp;&nbsp;&nbsp;同时如果出现无法连接数据库等问题，请到MyBatis配置文件中修改数据库连接的信息，或者也需要去修改你自己的MySQL数据库中的数据库或者表的信息。 以上便是整个过程，如果有错误，我会及时修改。]]></content>
      <categories>
        <category>JAVAEE框架作业</category>
      </categories>
      <tags>
        <tag>JAVAEE框架作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA代理]]></title>
    <url>%2F2019%2F09%2F18%2FJAVA%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[jAVA代理代理模式​ 使用一个代理对象将对象包装起来，然后用该代理对象来取代该对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时调用原始对象的方法 静态代理​ 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。如下图： ​ Client调用Source的method()方法，实际上是Proxy来调用method()方法，静态代理中Source跟Proxy都要实现接口Sourceable。 实现方式创建接口 123456789package com.proxy;public interface ClientDao &#123; /** * 主体内容 */ void content();&#125; 创建实现类 1234567891011package com.proxy;public class ClientDaoImpl implements ClientDao&#123; /** * 实现的方法 */ @Override public void content() &#123; System.out.println("这是主体内容"); &#125;&#125; 创建代理类 12345678910111213141516package com.proxy;public class ClientStaticProxy implements ClientDao&#123; private ClientDao clientDao; public void setClientDao(ClientDao clientDao) &#123; this.clientDao = clientDao; &#125; @Override public void content() &#123; System.out.println("对方法增强前"); clientDao.content(); System.out.println("对方法增强后"); &#125;&#125; 测试类 1234567891011121314package com.test;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientStaticProxy clientStaticProxy = new ClientStaticProxy(); ClientDao clientDao = new ClientDaoImpl(); clientStaticProxy.setClientDao(clientDao); clientStaticProxy.content(); &#125;&#125; 结果 优点 可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截 缺点 因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增强方法，则目标对象和代理类都需要维护。 动态代理JDK代理​ 动态代理是指动态在内存中构建代理对象（需要我们指定要代理的目标对象实现的接口类型），利用JDK的API生成指定接口的对象，也称为JDK代理或者接口代理。 ​ 下面是原理图片： ​ 因为上面创建过类了，所以现在只需要创建动态代理类即可 1234567891011121314151617181920212223242526272829303132333435package com.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 动态代理类 */public class ClientAutoProxy &#123; //被代理的对象 private Object targetObject; public ClientAutoProxy(Object targetObject) &#123; this.targetObject = targetObject; &#125; public Object getProxyInstance() &#123; return Proxy.newProxyInstance( //代理对象的类加载器 targetObject.getClass().getClassLoader(), //目标对象实现的接口，因为需要根据接口动态生成对象 targetObject.getClass().getInterfaces(), //InvocationHandler:事件处理器，即对目标对象方法的执行进行处理 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("方法增强前"); Object resultValue = method.invoke(targetObject, args); System.out.println("方法增强后"); return resultValue; &#125; &#125;); &#125;&#125; 测试类 123456789101112131415package com.test;import com.proxy.ClientAutoProxy;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientDao clientDao = new ClientDaoImpl(); ClientAutoProxy clientAutoProxy = new ClientAutoProxy(clientDao); ClientDao clientDaoProxy = (ClientDao)clientAutoProxy.getProxyInstance(); clientDaoProxy.content(); &#125;&#125; 结果与之前一样 需要注意的地方： 1Object resultValue = method.invoke(targetObject, args); ​ 这条语句在执行的时候，一开始我把targetObject对象写成了proxy对象，导致程序进入了死循环，经百度之后，了解到，因为proxy对象表示当前代理对象，这么调用之后又会调用到SimpleInvocationHandler的invoke方法，这个就要涉及到底层原理知识了，现阶段不过多讨论。 ​ 还有就是，在测试类中，因为返回类型为Object类型的对象，所以需要强转为所需要的类型。 优点 ​ 代理对象不需要实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需要在事件处理器中添加对方法的判断即可。 缺点 ​ 代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。]]></content>
      <categories>
        <category>JAVA代理</category>
      </categories>
      <tags>
        <tag>JAVA代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（一）]]></title>
    <url>%2F2019%2F09%2F18%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（一）Maven概述maven特性 纯java编写： 具有跨平台特性，只需要一套程序就行 开源： 可以对源码修改 互联网思维： 分享，共享 树立自己的IP，让自己流量变大，然后使自己变得有价值 跨平台： 跨两个平台： 跨OS平台（操作系统），跨IDE平台 IDE（Integrated Development Enviroment）：用于提供程序开发环境的应用程序 不同的IDE工具创建的项目结构不同，不能互相导入项目 maven把项目结构标准化，在哪开发都能导入项目 标准化的： 项目构建标准化： 跨操作系统平台（跨OS平台） 项目结构标准化： 跨IDE平台 Maven项目本身是和IDE没有任何关系的 基于项目对象模型（POM）： pom文件可以继承，具有继承性 一般导入依赖是通过 groupId，artifactId，version，简称gav坐标 maven核心都是由插件完成的，导入坐标可以自动下载插 项目构建： maven的管理模块来生成一些必要的组件，节省人工 依赖管理，对jar包进行管理，只需要导入坐标就行 报告生成： Maven 可以生成站点报告, 可以较为方便的实现对项目的管理。 Maven工作原理 maven寻找依赖过程 本地仓库 -&gt; maven私服（阿里云或者公司内部） -&gt; maven中心仓库 依次，到各级库的范围越来越广 Maven的安装与配置官网下载maven https://maven.apache.org/download.cgi 解压到某个文件夹 例如F盘 设置环境变量 在系统变量中创建 MAVEN_HOME ，内容填Maven的目录 例如 F:\apache-maven-3.6.2-bin\apache-maven-3.6.2 然后在path中添加MAVEN_HOME的bin目录 %MAVEN_HOME%\bin; 然后在cmd中测试一下，输入 mvn -v查看版本 如果有的话就没问题了 Maven换源（这个是最重要的）setting.xml文件 这个文件在maven文件夹下的conf文件夹中，找到后用编辑器打开 需要设置两个地方： 首先是本地仓库： 找到localRepository这个标签所在位置，一般来说都是注释状态，我们把注释去掉，然后把标签内内容改成maven文件夹的绝对路径就行 接下来最重要了，更换镜像： ​ 找到mirrors标签，然后把阿里云镜像添加进去即可： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 课外内容： 英语口语发音要注意，发音正确不一定学习好，但发音错误说明一定不是好学校 tar.gz文件夹： 高度压缩过的文件夹 zip： 普遍压缩 bin文件夹： 编译过的文件，二进制文件 src： 源码，未经过编译的]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二）]]></title>
    <url>%2F2019%2F09%2F17%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记视频篇（二）紧接着上面的入门案例，这次使用注解的方式 准备​ 首先新建一个maven项目，然后将java和resources文件夹复制过来，然后test文件夹也复制过来，还有pom.xml依赖也复制过来。 ​ 紧接着将resources文件夹下的com文件夹删除 修改​ 我们首先把sqlMapConfig.xml内容修改一下 123456&lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果使用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt; &lt;mapper class="com.dao.UserDao"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 只需要把最下面的mapper换成类名即可 ​ 然后是类中添加注解 12345678910111213141516171819package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ @Select("select * from user") List&lt;User&gt; findAll();&#125; ​ 在方法名上面添加注解标签Select，代表查询语句，参数则是具体查询语句，进行测试，发现结果与xml方式时的运行结果一致。 明确： ​ 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式，不管是使用XML还是注解配置，但是MyBatis它是支持写实现类的。 ​ 因此我们下来就手写一次实现类，来试一试。 开始手写实现类还是基于第一次的xml来实现的 创建一个dao的实现类 1234567891011121314151617181920212223242526package com.dao.impl;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; //使用工厂创建session对象 SqlSession session = factory.openSession(); //使用session进行查询 List&lt;User&gt; users = session.selectList("com.dao.UserDao.findAll"); session.close(); return users; &#125;&#125; UserDao的mapper不做修改 修改测试类内容 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import com.dao.UserDao;import com.dao.impl.UserDaoImpl;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream("sqlMapConfig.xml"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂创建dao对象 UserDao userdao = new UserDaoImpl(factory); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 in.close(); &#125;&#125; 因为session转移到实现类中，所以此处只需要new一个实现类就行 实际开发中并不使用这种方式，写这个是为了告诉我们，在mapper.xml中，只靠id是无法定位到具体的方法中的，还需要我们加上namespace才能找到执行语句。 mybatis入门案例模式中的设计模式分析]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一）]]></title>
    <url>%2F2019%2F09%2F17%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBits学习笔记视频篇（一）框架1. 什么是框架 ​ 他是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题，例如，MyBits解决的是持久层的问题，Spring和Spring MVC 解决的是表现层的问题。 2. 使用框架的好处 ​ 框架风阻航了很多细节，是开发者可以使用极简的方式实现功能，大大提高开发效率。 三层架构​ 表现层：用于展示数据的 ​ 业务层：处理业务需求 ​ 持久层：和数据库交互的 持久层技术解决方案1. JDBC技术 ​ Connection ​ PreparedStatement ​ ResultSet 2. Spring的JdbcTemplate： ​ Spring中对jdbc的简单封装 3. Apache的DBUtils ​ 它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装 4. 以上这些都不是框架 ​ JDBC是规范 ​ Spring的JdbcTemplate和Apache的DBUtils都只是工具类 MyBatis框架概述​ mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，是开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等复杂的过程。 ​ 它使用了ORM思想，实现了结果集的封装，Object Relational Mapping 对象关系映射，简单地说，就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。 ​ 实体类中的属性和数据库表的字段名名称保持一致。 MyBatis的入门mybatis的环境搭建 ​ 首先创建一个maven项目 ​ 在pom.xml中导入相关的包 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;my_pratices_mybits_day_1&lt;/groupId&gt; &lt;artifactId&gt;my_pratices_mybits_day_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 创建接口 1234567891011121314151617package com.dao;import com.pojo.User;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ List&lt;User&gt; findAll();&#125; 创建Mybatis-config.xml整体配置文件 因为我这里没有，所以创建了一个模板 创建模板过程就是： 打开idea设置中的File and Code Templates中的Files 然后点击“+”号，Name输入MyBatis-config.xml，Extendsion填写 xml 然后下面模板中添加如下代码 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 整个模板就配置完毕了，然后创建就行 在MyBatis-config.xml配置文件中写入以下代码 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意上面一定要把environments的default和environment的id都写上去 创建映射配置文件UserDao.xml 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;!--配置查询所有--&gt; &lt;select id="findAll" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 这个地方会报错，原因是没有写resultType参数，结果集不知道封装到哪里去。 而且那个sql语句末尾不能加“；”符号 环境搭建注意的事项： ​ 第一个是： 创建UserDao.xml和UserDao.java时名称是为了和我们之前的知识保持一致。在MyBatis中它把持久层的操作接口名称和映射文件，也叫做Mapper，所以UserDao和UserMapper是一样的。​ 第二个是： 在idea中创建目录时，他和包是不一样的，包在创建时，com.dao他是二级结构，而创建目录的时候，com.dao他是一级结构，所以必须要一层一层创建​ 第三个是：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个是：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 ​ 第五个是：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 ​ 当我们遵从了第三，四，五点之后，我们在开发中就无须再写doa的实现类了。 创建log4j.properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344# priority :debug&lt;info&lt;warn&lt;error#you cannot specify every priority with different file for log4j log4j.rootLogger=debug,stdout,info,debug,warn,error #consolelog4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern= [%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n#info loglog4j.logger.info=infolog4j.appender.info=org.apache.log4j.DailyRollingFileAppender log4j.appender.info.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.info.File=./src/com/hp/log/info.loglog4j.appender.info.Append=truelog4j.appender.info.Threshold=INFOlog4j.appender.info.layout=org.apache.log4j.PatternLayout log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#debug loglog4j.logger.debug=debuglog4j.appender.debug=org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.debug.File=./src/com/hp/log/debug.loglog4j.appender.debug.Append=truelog4j.appender.debug.Threshold=DEBUGlog4j.appender.debug.layout=org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#warn loglog4j.logger.warn=warnlog4j.appender.warn=org.apache.log4j.DailyRollingFileAppender log4j.appender.warn.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.warn.File=./src/com/hp/log/warn.loglog4j.appender.warn.Append=truelog4j.appender.warn.Threshold=WARNlog4j.appender.warn.layout=org.apache.log4j.PatternLayout log4j.appender.warn.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#errorlog4j.logger.error=errorlog4j.appender.error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.error.File = ./src/com/hp/log/error.log log4j.appender.error.Append = truelog4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n 创建测试类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream("MyBatis-config.xml"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 UserDao userdao = session.getMapper(UserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 结果展示 mybatis的入门案例 ​ 第一步： 读取配置文件 ​ 第二步： 创建SqlSessionFactory工厂 ​ 第三步：创建SqlSession ​ 第四步：创建Dao接口的代理对象 ​ 第五步：执行dao中的方法 ​ 第六步：释放资源 ​ 注意事项： ​ 不要忘记在映射配置中告知mybits要封装到哪个实体类中 ​ 配置的方式：指定实体类的全限定类名]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit的基本注解]]></title>
    <url>%2F2019%2F09%2F17%2FJunit%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Junit的基本注解注解类型 注解名称 注解作用 @Before 表示在任意使用@Test注解标注的public static void 方法执行之前执行 @After 表示在任意使用@Test注解标注的public static void 方法执行之后执行 @Test 使用该注解标注的public void 方法会表示为一个测试方法，可以直接执行 @BeforeClass 表示在类中的任意public static void 方法执行之前执行 @AfterClass 表示在类中的任意public static void 方法执行之后执行 下面是测试样例： 1234567891011121314151617181920212223242526package com.test;import org.junit.*;public class BasicAnnotationTest &#123; @BeforeClass public static void beforeClass() &#123; System.out.println("这是beforeClass前置通知"); &#125; @AfterClass public static void afterClass() &#123; System.out.println("这是afterClass后置通知"); &#125; @Before public void before() &#123; System.out.println("这是before前置通知"); &#125; @After public void after() &#123; System.out.println("这是after后置通知"); &#125; @Test public void test1() &#123; System.out.println("这是test1"); &#125;&#125; 结果：]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub学习笔记]]></title>
    <url>%2F2019%2F09%2F16%2FGitHub%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[GitHub学习笔记基本概念仓库（Repository）仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目存在多个仓库。 收藏（Star）收藏项目，方便查看 复制克隆项目（Fork）点击之后，会别人的仓库完整的复制一份给你，该fork仓库之独立存在的，而且上面会有从哪个地方克隆的。 发起合并请求（Push Request）这个是基于Fork的，如果想要克隆来源的地方也更新同样的代码，然后可以点击之后，会发起合并请求，查看同意之后就可以合并了。 关注（Watch）关注项目之后，项目更新可以接受到通知 事物卡片（Issue）发现代码有BUG，但是目前没有成型代码，需要讨论时用 Github主页账号登录成功之后，点击左上角就回到github主页，显示自己的动态和关注的动态，右边显示git库 仓库主页显示项目信息，如：项目代码，版本，收藏/关注/fork情况等 创建仓库 仓库主页 仓库管理点击create new file新建文件 写好之后，填写提交的目的，原因：为了方便其他开发者知道本次添加或修改的原因 创建完毕跳转到主页 点击目的之后可以看到文件的详细描述，还有文件的修改内容 编辑文件 点击之后回来到编辑模式之下 删除文件同上面一样 上传文件 可以拖动文件也可以点击上传多个文件 下面是写上传文件的信息 搜索文件 输入文件名进行筛选 也可以按快捷键T就可以进行查找文件 下载文件]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用的网站]]></title>
    <url>%2F2019%2F09%2F16%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一些常用的网站链接Spring官方文档（涵盖各个版本的）https://docs.spring.io/spring/docs/ Maven仓库https://mvnrepository.com/ Json格式化网站https://www.json.cn/ 不错的java学习网站http://how2j.cn/stage/39.html CMD Markdown网站https://www.zybuluo.com/mdeditor （可以在线记录markdown文档，缺点是有些功能收费） Leetcodehttps://leetcode-cn.com/ 站长工具http://tool.chinaz.com/ 谷歌网上应用商店https://chrome.google.com/webstore/category/extensions?h1=zh 慕课网https://www.imooc.com/ 牛客https://www.nowcoder.com/ 代码托管平台Githubhttps://github.com/ 待更新。。。。。。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置文件整理]]></title>
    <url>%2F2019%2F09%2F16%2FMyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MyBatis配置文件整理log4j.properties123456789101112131415161718192021222324 ### 设置###log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n ### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n mybatis模板123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--属性--&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!--设置--&gt; &lt;settings&gt; &lt;setting name="" value=""/&gt; &lt;/settings&gt; &lt;!--别名--&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!--类型处理器--&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!--对象工厂--&gt; &lt;objectFactory type=""&gt;&lt;/objectFactory&gt; &lt;!--插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=""&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;!--配置环境--&gt; &lt;environments default=""&gt; &lt;!--环境变量--&gt; &lt;environment id=""&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type=""&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=""&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--数据库厂商标识--&gt; &lt;databaseIdProvider type=""&gt;&lt;/databaseIdProvider&gt; &lt;!--映射器,告诉mybatis去哪里找映射文件--&gt; &lt;mappers&gt; &lt;mapper&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper模板12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 在MyBatis中，Mapper中的namespace用于绑定Dao接口的，即面向接口编程。 它的好处在于当使用了namespace之后就可以不用写接口实现类， 业务逻辑会直接通过这个绑定寻找到相对应的SQL语句进行对应的数据处理--&gt;&lt;mapper namespace=""&gt; &lt;!--查询--&gt; &lt;select id=""&gt;&lt;/select&gt; &lt;!--增加--&gt; &lt;insert id=""&gt;&lt;/insert&gt; &lt;!--删除--&gt; &lt;delete id=""&gt;&lt;/delete&gt; &lt;!--修改--&gt; &lt;update id=""&gt;&lt;/update&gt; &lt;!--提供缓存支持--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!--参照缓存,用来引用另一个缓存--&gt; &lt;cache-ref namespace=""/&gt; &lt;!-- ParameterMap和ResultMap类似，设置入参字段映射，很少使用（不建议使用）--&gt; &lt;parameterMap id="" type=""&gt;&lt;/parameterMap&gt; &lt;!--查询结果集，映射java对象--&gt; &lt;resultMap id="" type=""&gt;&lt;/resultMap&gt;&lt;/mapper&gt; Spring整合模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSouce" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;!--加载数据库驱动--&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8"&gt;&lt;/property&gt; &lt;!--账户--&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;!--密码--&gt; &lt;property name="password" value="wang123"&gt;&lt;/property&gt; &lt;!--最大连接数--&gt; &lt;property name="maxTotal" value="30"&gt;&lt;/property&gt; &lt;!--最大空闲数--&gt; &lt;property name="maxIdle" value="10"&gt;&lt;/property&gt; &lt;!--初始化连接数--&gt; &lt;property name="initialSize" value="5"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--添加事务支持--&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager="txManager" /&gt; &lt;!--配置MyBatis工厂,同时指定数据源，并于MyBatis完美整合--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--指定数据源--&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;!--configLocation的属性值为MyBatis的核心配置文件--&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配 (Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口) --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!--mybatis-spring组件的扫描器--&gt; &lt;property name="basePackage" value=""&gt;&lt;/property&gt; &lt;!--注入工厂--&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring5约束头1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;/beans&gt; 整合Spring和MyBatis所使用的pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.my_priatices.aop&lt;/groupId&gt; &lt;artifactId&gt;my_priatices.aop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 待更新。。。。。。]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（三）]]></title>
    <url>%2F2019%2F09%2F12%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（三）基于XML装配Spring提供了两种基于XML的装配方式，分别是setter注入和构造方法注入 首先创建Bean的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;/** * 复杂数据的注入 */public class ComplexUser &#123; private String name; private List&lt;String&gt; hobbyList; private Map&lt;String,String&gt; residenceMap; private Set&lt;String&gt; aliasSet; private String[] array; public ComplexUser(String name, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array) &#123; this.name = name; this.hobbyList = hobbyList; this.residenceMap = residenceMap; this.aliasSet = aliasSet; this.array = array; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getHobbyList() &#123; return hobbyList; &#125; public void setHobbyList(List&lt;String&gt; hobbyList) &#123; this.hobbyList = hobbyList; &#125; public Map&lt;String, String&gt; getResidenceMap() &#123; return residenceMap; &#125; public void setResidenceMap(Map&lt;String, String&gt; residenceMap) &#123; this.residenceMap = residenceMap; &#125; public Set&lt;String&gt; getAliasSet() &#123; return aliasSet; &#125; public void setAliasSet(Set&lt;String&gt; aliasSet) &#123; this.aliasSet = aliasSet; &#125; public String[] getArray() &#123; return array; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; @Override public String toString() &#123; return "ComplexUser&#123;" + "name='" + name + '\'' + ", hobbyList=" + hobbyList + ", residenceMap=" + residenceMap + ", aliasSet=" + aliasSet + ", array=" + Arrays.toString(array) + '&#125;'; &#125;&#125; 配置Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="u1" class="com.bean.ComplexUser"&gt; &lt;!--构造方法注入--&gt; &lt;constructor-arg index="0" value="myname"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;码代码&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;map&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;entry key="beijing" value="北京"&gt;&lt;/entry&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;set&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang1&lt;/value&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang2&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="u2" class="com.bean.ComplexUser"&gt; &lt;property name="name" value="shuai"&gt;&lt;/property&gt; &lt;property name="hobbyList"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;搬砖&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="residenceMap"&gt; &lt;map&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="aliasSet"&gt; &lt;set&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s2&lt;/value&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="array"&gt; &lt;array&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;你太美&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类 123456789101112131415161718package com.test;import com.bean.ComplexUser;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); ComplexUser u1 = (ComplexUser)applicationContext.getBean("u1"); System.out.println(u1.toString()); ComplexUser u2 = (ComplexUser)applicationContext.getBean("u2"); System.out.println(u2.toString()); &#125;&#125; 结果 基于注解的装配因为要用到注解，所以我们来看看都有哪些基础的注解： 名称 作用 Component 代表一个组件对象，就是把普通的pojo实例到Spring容器中 Repository 此注解用于数据访问层（DAO），功能与Component相同 Service 此注解用于业务逻辑组件层（Service层），功能与Component相同 Controller 此注解用于标注一个控制器组件类（SpringMVC的Controller），功能与Component相同 AutoWired 此诸结可以对类成员变量，方法及构造方法进行标注，完成自动装配的工作。通过使用Autowired来消除setter和getter方法。默认按照Bean的类型进行装配，如果想按照名称来注入，就必须要和Qualifier搭配使用。 Resource 此注解与AutoWired相同，区别在于这个注解是按照名称来装配注入的，只有当找不到与名称匹配的名称时，才按照Bean的类型进行装配。 Qualifier 此注解要和AutoWired配合使用，Bean的实例名称有此注解的参数指定。 首先创建一个DAO层，和他的实现类，然后标上注解： TestDao 12345678910111213package com.dao;import org.springframework.stereotype.Repository;/** * 创建dao接口 */public interface TestDao &#123; /** * 保存 */ void save();&#125; TestDaoImpl 12345678910111213package com.dao.impl;import com.dao.TestDao;import org.springframework.stereotype.Repository;@Repository("testDao")public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println("TestDao save"); &#125;&#125; TestService 1234567891011package com.servlet;import org.springframework.stereotype.Service;/** * 业务层接口 */public interface TestService &#123; void save();&#125; TestServiceImpl 1234567891011121314151617181920212223package com.servlet.impl;import com.dao.TestDao;import com.servlet.TestService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * 业务层实现类 */@Service("testService")public class TestServiceImpl implements TestService &#123; @Resource(name="testDao") private TestDao testDao; @Override public void save() &#123; testDao.save(); System.out.println("TestService save"); &#125;&#125; TestController 12345678910111213141516171819package com.controller;import com.servlet.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controllerpublic class TestController &#123; @Autowired private TestService testService; public void save()&#123; testService.save(); System.out.println("TestController save"); &#125;&#125; 测试类 12345678910111213package com.test;import com.controller.TestController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); TestController testController = (TestController)applicationContext.getBean("testController"); testController.save(); &#125;&#125; 结果 课后题Bean的实例化有哪几种常见的方法？ ​ 答： 三种，构造方法，静态工厂，实例工厂 简述基于注解装配方式的基本用法？ ​ 答： 见上面的表格。 @AutoWired和@Resource有什么区别？ ​ 答：一个是按类别，一个是按名称 Bean的默认作用域是什么？ ​ 答：singleton 单例模式 使用类似于@Controller一样的注解的时候，Bean的id是什么？ ​ 答： 默认是首字母小写的类名]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F09%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[基础部分 javaSE MySQL，刚开始只需要了解一些基础的sql语句，例如增删改查，复杂一点的后面可以在学。 idea可以直接连接数据库 database，一开始可以多用用，熟悉熟悉 javaWeb：jsp（了解即可），（Servlet ，Filter，Listener），重点放在Listener 现在大多数都是异步机制和回调机制，Listener监听用的多，Filter用的少 （重点部分）SSM：Spring + MyBatis+Spring MVC Spring MVC：是Spring中的一部分 Spring：本身是一个容器 响应式编程 WebFlux，在开发中用的也不是很多，主要解决的是高并发问题，建议了解一下 Lambda表达式，基于接口实现的，建议学习 项目管理工具 Maven，得了解原理。 项目管理工具Git，也是分布式版本管理工具，然后项目要放到github上面 （重点部分）Spring Boot （快速开发框架），使用这个原因是因为SSM配置文件非常多，基本上都是样板式代码，因此必须把可重用性代码封装起来，所以这个Spring Boot必须得好好学习，重点！ 分布式开发技术（进阶部分） linux基础，因为服务器现在基本上都是搭建在无可视化界面的linux上面的 本地服务器搭建的工具（VMware（搭建虚拟机）+secureCRT（客户端）+CentOS 7 Mini版本（只有操作界面） 分布式协调服务器Zookeeper 反向代理服务器 Nginx 真正请求的服务器在后面，这个是代理集群，集群里面部署的应用都是一样的，一般都会选一个master作为主要的 正解：正向解析，把域名解析成ip地址 反解：反向代理，把ip地址解析成域名 正代：由内向外作代理 反代：由外向内做代理 分布式内存数据库Redis（NoSql非关系型数据库） 分布式消息队列Kafka，RocketMQ，RabbitMQ（ActiveMQ不用管它） 应用方面：削减峰值，并发量高的时候需要使用 分布式RPC框架Dubbo（阿里的框架）和微服务框架Spring Cloud 微服务：把服务分散开，每一个都是独立的工程，用哪个调哪个 高内聚，低耦合，便于复用 Spring Boot 一定要好好学习！！！]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>前进方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（二）]]></title>
    <url>%2F2019%2F09%2F04%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBeanBean的配置​ Spring用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持Xml和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 ​ &lt;bean&gt;元素的常用属性及其子元素 描述 属性或子元素名称 id Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称 class Bean的具体实现类，使用类的名（例如dao.TestDIDaoImpl） scope 指定Bean实例的作用域 &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值 &lt;property&gt; &lt;bean&gt;元素的子元素用于设置一个属性，该元素的name属性指定Bean实例中相应的属性名称，value属性指定Bean的属性值，ref属性指定属性对BeanFactory中其他Bean的引用关系 &lt;list&gt; &lt;property&gt;元素的子元素，用于封装List或数组类型的依赖注入 &lt;map&gt; &lt;property&gt;元素的子元素，用于封装Map类型的依赖注入 &lt;set&gt; &lt;property&gt;元素的子元素，用于封装Set类型的依赖注入 &lt;entry&gt; &lt;map&gt;元素的子元素，用于设置一个键值对 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，也需要实例化Bean，Spring框架实例化Bean有三种方式 即，构造方法实例化、静态工厂实例化和实例工厂实例化（最常用就是构造方法实例化）。 1. 构造方法实例化 spring-config.xml配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213package com.test;import com.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); AccountService accountService = (AccountService)applicationContext.getBean("accountService"); accountService.addAccountMoney("张三",1000f); &#125;&#125; 2. 静态工厂实例化对象（开发中不使用，再次不列举使用方法）3. 实例工厂实例化对象（这个也不列举）Bean的作用域 作用域名称 描述 singleton 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例 prototype Spring容器每次获取protopyte定义的Bean，容器都将创建一个新的Bean实例 request 在一次Http请求中容器将返回一个Bean实例，不同的Http请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用 session 在一个HTTP Session 中，容器将返回同一个Bean实例。尽在Web Spring应用程序上下文中使用 application 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例，尽在Web Spring应用程序上下文中使用 websocket 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用 1. singleton作用域​ 由于singleton是bean的scope默认设置，所以写好bean之后就可以进行测试 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.test.AccountServiceImpl" scope="singleton"&gt;&lt;/bean&gt;&lt;/beans&gt; 代码如下 123456789101112131415package com.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); //第一个对象 AccountServiceImpl a1 = (AccountServiceImpl)applicationContext.getBean("accountService"); //第二个对象 AccountServiceImpl a2 = (AccountServiceImpl)applicationContext.getBean("accountService"); System.out.println(a1 == a2); &#125;&#125; 结果展示： 2. prototype作用域代码如上所述，然后只设置scope作用域即可 结果展示: Bean的生命周期​ 一个对象的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段，在Spring中，Bean对象周期也遵循这一过程，但是Spring提供了许多对外接口，允许开发者对3个过程（实例化、初始化、销毁）的前后做一些操作。在Spring Bean中，实例化是为Bean对象开辟空间，初始化则是对属性的初始化。 ​ Bean生命周期整个过程如下： ​ （1）根据Bean的配置情况实例化一个Bean。 ​ （2）根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。 ​ （3）如果Bean实现了BeanNameAware 接口，将调用它实现的，setBeanName（String beanId）方法， 此处参数传递的是Spring配置文件中Bean的id。 ​ （4）如果Bean实现BeanFactoryAware接口，将调用它实现的setBeanFactory方法，此处参数传递的是当前Spring工厂实例的引用。 ​ （5）如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext（ApplicationContext）方法，此处参数传递的是Spring上下文实例的引用。 ​ （6）如果Bean关联了BeanPostProcessor接口，将调用初始化方法postProcessBeforeInitialization（Object obj， String s）对Bean进行操作。 ​ （7）如果Bean实现了InitializingBean接口， 将调用afterPropertiesSet方法。 ​ （8）如果Bean在Spring配置文件中配置了 init-method 属性，将自动调用其配置的初始化方法。 ​ （9）如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization（Object obj，String s）方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。 ​ （10）当Bean不再需要时将进入销毁阶段，如果Bean实现了DisposableBean接口，则调用其实现的destroy方法将Spring中的Bean销毁。 ​ （11）如果在配置文件中通过destory-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。 ​ 在Spring中，通过特定的接口或通过&lt;bean&gt;元素的属性设置可以对Bean的生命周期过程产生影响。 ​ 例子： ​ 创建Bean的实现类 12345678910111213package com.test;/** * @author wys */public class BeanLife &#123; public void initMyself()&#123; System.out.println(this.getClass().getName()+"执行了自定义的初始化方法"); &#125; public void destroyMyself() &#123; System.out.println(this.getClass().getName()+"执行了自定义的销毁方法"); &#125;&#125; ​ 配置Bean 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="beanLife" class="com.test.BeanLife" init-method="initMyself" destroy-method="destroyMyself"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 测试生命周期 12345678910111213141516package com.test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("spring-config.xml"); System.out.println("获得对象前"); BeanLife beanLife = (BeanLife)ctx.getBean("beanLife"); System.out.println("获得对象后"+beanLife); ctx.close(); &#125;&#125; 结果如下:]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next界面美化]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E7%9A%84next%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[设置中文首先查看一下next/theme/language中的语言类型，一般就是zh-CN或者是zh-Hans`这个类型 然后在hexo的配置文件_config.yml把写上去就行 主题风格将next中的_config.yml配置文件修改一下 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 这个把前面的#去掉换另一种就行，我觉得第三种就挺好看的。个人喜好 设置分类还是在next中的_config.yml配置文件修改 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把对应菜单的选项注释去掉就好 然后创建目录,不同标签对应不同的代码 1$ hexo new page categories 创建完毕之后，进去修改一下 类似于categories这种的 123456---title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: "categories"--- 添加头像搜索next中的_config.yml配置文件 搜索Sidebar Avatar这个关键字，去掉avatar前面的# 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.gif 然后把头像放到指定的文件夹 设置侧边栏的的社交链接打开themes/next/_config.yml文件，搜索关键字social，然后添加社交站点名称与地址即可。 1234567891011social: GitHub: https://github.com/wyscoder|| github E-Mail: mailto:714133840@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 修改底部的声明和版权主题配置文件下，搜索关键字post_copyright，enable改为true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 去掉强力驱动 找到hexo根目录&gt;&gt;themes&gt;&gt;next&gt;&gt;layout&gt;&gt;_partials下的footer.swig文件 然后打开删除 123456789101112131415161718&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 这部分内容就好 最后修改一下hexo中的配置文件名字就行 添加搜索功能首先安装一下搜索插件 $ npm install hexo-generator-searchdb --save 打开Hexo站点的_config.yml，添加配置 : 12345search: path: search.xml field: post format: html limit: 10000 打开themes/next/_config.yml，搜索关键字local_search，设置为true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 本地站点推送到GitHub上安装插件 1$ npm install hexo-deployer-git --save 在Hexo站点的_config.yml中配置deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo g -d 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=110 src=&quot;//music.163.com/outchain/player?type=0&amp;id=408443429&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 就好了 添加背景动画效果 修改_layout.swig 打开 next/layout/_layout.swig 在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话 可以这么设置====&gt; 在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加代码复制功能首先找到这个目录themes/next/layout/_third-party/ 然后在此文件夹下创建名为copy-code.swig的文件，在此文件中输入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125;&lt;/style&gt;&lt;script&gt; $('.highlight').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap') $(e).after($wrap) $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text() &#125;).toArray().join('\n') var ta = document.createElement('textarea') document.body.appendChild(ta) ta.style.position = 'absolute' ta.style.top = '0px' ta.style.left = '0px' ta.value = code ta.select() ta.focus() var result = document.execCommand('copy') document.body.removeChild(ta) if(result)$(this).text('复制成功') else $(this).text('复制失败') $(this).blur() &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn') setTimeout(function () &#123; $b.text('复制') &#125;, 300) &#125;).append(e) &#125;)&lt;/script&gt; 然后返回上一层目录，即layout文件夹下，编辑_layout.swig， 在最底部，&lt;/body&gt;上面添加 1&#123;% include &apos;_third-party/copy-code.swig&apos; %&#125; 这句话接着就能用了]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO搭建博客（搭建在github上面）]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言学长给的几个教程链接 https://blog.csdn.net/u013332124/article/details/80680156 https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html#validate-next-theme https://blog.csdn.net/llmmll08/article/details/70246150 1.什么是hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.安装1.前提​ 必须有Node.js 和 Git, 还有Github账号，都具备之后就开始了 2.创建github pages页面 首先创建仓库（repository ），然后仓库名字必须得是 yourname.github.io 这个，比如我的github名称是wyscoder，所以仓库名称就是 wyscoder.github.io 然后记住这个仓库的git地址 https://github.com/wyscoder/wyscoder.github.io 3.安装hexo 这个是需要node.js和git作为前置的，如果没有就去下载node.js和git 接下来就只需要npm就可以完成安装了 使用这个命令进行安装hexo$ npm install -g hexo-cli 等待下载完毕就行 4. 建站 安装hexo完成之后，执行下面命令就会在指定文件夹创建需要的文件 1234node.js$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 具体参数信息请查看官方文档 https://hexo.io/zh-cn/docs/configuration package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-stylus": "^0.3.3", "hexo-renderer-marked": "^0.3.2", "hexo-server": "^0.3.3" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 5.上传站点生成后,就可以开始写文章了。dos界面下,进入所在站点目录，输入hexo new [layout] &lt;title&gt;命令。hexo会自动帮你生成一个 &lt;title&gt;.md 的文件。然后你就可以在这个文件上编写你的博客内容了。 写完博客后,我们先试着在本地部署一下服务。还是在dos命令下，进入站点目录。一次输入: 123hexo clean # 清除缓存,之后会经常用到hexo g # 生成站点静态文件hexo s # 部署服务 上面是本地部署，之后就可以通过localhost:4000来访问博客了 但是如果想让别人访问你的还需要提交到git上面 打开cmd 然后输入npm install hexo-deployer-git --save安装git工具 开站点目录下面的配置文件_config.yml(用任意编辑器),配置deploy参数。一开始配置文件是这样的: 12deploy: type: 我们把它改成我们的git仓库地址。 1234deploy: type: git repository: ssh://git@github.com/wyscoder/wyscoder.github.io branch: master 修改好之后执行 123hexo clean hexo g hexo d # 部署到远程仓库 令全部执行完后。我们就可以访问我们的博客网站了。https://wyscoder.github.io 6.问题在使用hexo d提交的时候出现了几个问题 首先是你得使用git命令来设置用户和邮箱 config --global user.name "nameVal" ```12```git config --global user.email &quot;eamil@qq.com&quot; 其中我还测试了一下那个git的基本命令，都是卡在提交那一点，原因是没有密匙 如果电脑上没有ssh密匙我建议还是要安装一下 7.美化博客：使用nexT主题博客是搭建好了, 但是我们发现hexo的默认主题风格比较丑。好在hexo的主题是可定制的。所以我们可以更换别人已经做好的主题。nexT就是其中一个比较强大的主题。下面简单的教大家怎么切换到这个主题。​ 先去nexT的github页面下载nexT项目。https://github.com/iissnan/hexo-theme-next。然后放到站点目录下面的一个themes文件夹中。解压。 解压后会得到一个hexo-theme-next-master文件夹。重命名成next。 修改站点配置文件_config.yml里面的theme参数,修改值为next。 ​ 重新清除缓存,生成新的资源文件，然后部署,主题就切换成next了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（一）]]></title>
    <url>%2F2019%2F08%2F10%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring简介1. Spring由来 目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题 2. Spring体系结构 核心容器（Core Container） 数据访问/ 集成（Data Access/Integration）层 Web层 AOP（Aspect Oriented Programming，面向切面的编程）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test） Spring体系结构 SpringIOC1. Spring IOC基本概念控制反转是一个比较抽象的概念，是Spring框架的核心，用来削减计算机程序的耦合问题。 依赖注入是IOC的另外一种说法。 解释 &nbsp;&nbsp;当某个java对象需要调用另一个对象时，在传统编程模式下，调用者通常会采用 “new 被调用者” 的方式来创建对象，这种方式会增加调用者和被调用者之间的耦合性，不利于后期代码的维护。 &nbsp;&nbsp;当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 &nbsp;&nbsp;从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入他所依赖的实例，这就是Spring依赖注入。 &nbsp;&nbsp;综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方产生或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入。 2. SpringIOC容器SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口。 BeanFactory(1). 概念&nbsp;&nbsp;BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，它提供了完整的Ioc服务支持，是一个管理BeanFactory的工厂，主要负责初始化各种Bean。BeanFactory接口有许多实现类，比较常用的就是org.springframework.beans.factory.xml.XmlBeanFactory.这个类会根据XML来装配Bean，创建时候需要提供XML文件的绝对路径。 123456public static void main(String[] args)&#123; //初始化Spring容器，加载配置文件 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("绝对路径")); TestDao testDao = (TestDao)beanFactory.getBean("testDao"); testDao.sayHello();&#125; 这种写法开发中一般不常见，了解即可。 ApplicationContext&nbsp;&nbsp;ApplicationContext是BeanFactory的子接口，也称为应用上下文，org.springwork.context.ApplicationContext接口定义，ApplicationContext接口除了包含BeanFactory的所有功能外，还添加了国际化，资源访问，事件传播等内容的支持。 &nbsp;&nbsp;创建ApplicationContext接口实例通常有以下三种方式: (1). *通过ClassPathXmlApplicationContext创建 *：&nbsp;&nbsp;ClassPathXmlApplicationContext将类路径目录（src根目录）中寻找指定的XML配置文件，代码如下： 1234567public static void main(String[] args)&#123; //初始化Spring容器ApplicationContext,加载配置文件 ApplicationContext ac = ClassPathXmlApplicationContext("spring-config.xml"); //通过容器获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; (2). 通过FileSystemXmlApplicationContext创建：&nbsp;&nbsp;FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public stsatic void main(String[] args)&#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext ac = new FileSystemXmlApplication("C:\Users\hp\IdeaProjects\my_pratices_account_day_01\src\main\resources\spring-config.xml"); //获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。 (3). 通过Web服务器实例化ApplicationContext容器&nbsp;&nbsp;在Web服务器实例化ApplicationContext容器时，一般使用org.springframework.web.context.ContextLoaderListener的实现方式（需要导入spring-web.5.0.2.RELEASE.jar包），此方法只需在web.xml中添加如下代码： 1234567891011&lt;context-param&gt; &lt;!--加载src目录下的spring-config.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3. 依赖注入的类型构造方法注入&nbsp;&nbsp;Spring框架可以采用java的反射机制，通过构造方法完成依赖注入 首先创建持久层接口 1234567891011package com.test.dao;/** * 创建持久层 */public interface TestDao &#123; /** * Hello方法 */ void sayHello();&#125; 然后创建持久层实现类 1234567891011package com.test.dao.impl;import com.test.dao.TestDao;public class TestDaoImpl implements TestDao &#123; @Override public void sayHello()&#123; System.out.println("Hello World"); &#125;&#125; 创建业务层接口 12345678package com.test.service;/** * 业务层 */public interface TestService &#123; void sayHello();&#125; 创建业务层实现类 12345678910111213141516171819package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public TestServiceImpl(TestDao testDao)&#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 配置spring-config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;constructor-arg ref="testDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后在测试类中测试一下 1234567891011121314package com.test;import com.test.service.TestService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-config.xml"); TestService testService = (TestService)ac.getBean("testService"); testService.sayHello(); &#125;&#125; 然后看一下结果 以上就是构造注入 属性的setter注入&nbsp;&nbsp;和上面创建一样，只需要更改一下TestServiceImpl中的代码和spring-config.xml就行 123456789101112131415161718192021package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public void setTestDao(TestDao testDao) &#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;property name="testDao" ref="testDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 4. 课后习题 举例说明IOC容器的实现方式有哪些？ 控制反转和依赖注入 spring中什么是控制反转？什么是依赖注入？使用控制反转与依赖注入的优点？ 控制反转：是一种通过描述并通过第三方去产生去获取特定对象的方式 依赖注入：使用spring框架创建对象时动态的将其所依赖的对象注入到Bean组件中。 控制反转优点： ​ 1.获取对象可以通过注解等方式获取对象，打破传统的获取方式 ​ 2.对象不再由程序本身进行创建，而是交给spring容器创建，降低了程序的耦合性 ​ 3.控制反转能做到更多的事情，例如事务控制 ​ 4.后期维护方便 依赖注入优点： ​ 1.项目开发讲究高内聚，低耦合 ​ 2.使用依赖注入可以避免使用new关键字创建对象，从而降低类与类之间的耦合度 spring框架采用java的反射机制进行依赖注入.]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
