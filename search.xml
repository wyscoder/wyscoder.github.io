<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多模块项目理解]]></title>
    <url>%2F2020%2F03%2F17%2F%E5%A4%9A%E6%A8%A1%E5%9D%97%E9%A1%B9%E7%9B%AE%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[多模块项目理解介绍为什么要用多模块？ 1、 做项目首先讲究 “高内聚，低耦合”，因此传统的项目是将一个项目分为多个包，随着项目复杂，如果想复用一个模块的话，因为是包的形式，复用起来会很麻烦，耦合性很强，常用的方法就是复制代码修改，但是这样会做出很多无用功和增加出错几率。 2、 springboot多模块简单说，就是把包按分模块的模式，借助maven升级到jar方式，抽象性就更强了，假如jar再升级到war或者多个集合的jar，就成微服务了，在多模块jar模式下，可以将某个jar拿出来对外共用，能大大提高代码复用率和开发效率。 3、 开发者对自己或者别人负责的代码边界很模糊，这是复杂项目中最容易遇到的，导致结果就是开发者很容易修改别人代码，而且代码负责人还不知道，责任追踪很麻烦。 4、简单来说就是 高内聚，低耦合，容易维护，便于开发者确定自己负责的内容。 5、以上都是百度的。 开发思路1、首先确定项目开发结构 2、创建最基本的项目模块 3、理清楚各模块之间的依赖关系 4、修改pom文件，统一版本号和使用的jar包版本，如果在此期间觉得哪几个模块能够合并，就优化一下 可能会存在的问题（1） 划分模块的方式 划分模块主要根据是职责单一性和耦合性，如果是项目创建初期就使用多模块来规划项目，那么职责单一性就应该是首先考虑的，也就是通常意义上的按照层次划分，如果是从一个十分复杂的项目开始拆分，那么在划分模块的石航就不仅仅是考虑职责单一性了，职责单一会造成大量的子模块产生导致pom文件臃肿且不容易识别，如果将耦合性考虑进去就应该将关系较为紧密的模块合并降低模块的数量提高实用性。 （2） 公有依赖的抽象 parent中的以来配置主要是有一些公有的依赖，例如log，apache，commons，spring等，怎么界定一个依赖是否属于公有呢？一般情况下如果这个依赖被超过2/3的子模块所依赖就可以将其认定为公有依赖，另外也可以将依赖的某些配置（例如版本号）以parent中pom的属性的形式加以声明，这样在升级某些依赖的时候只要改动一处就行了（很类似C语言中的#define） （3） 模块的存在与消亡 模块的划分并不是一成不变的，模块的存在就是为了方便维护和提高生产效率，如果某些模块不合理并且影响了开发效率，那么这些模块就需要再好好斟酌一下，一般情况下这种情况出现不是为了模块过于庞大就是因为模块的碎片化，对于前者需要拆分更多模块以提高复用和去除冗余，后者则需要酌情合并一些耦合性较高的模块。 （4） 子模块的子模块 这种情况的出现往往就意味着这个项目本身就应该被分成多个项目，多个项目之间也可以继承同一个parent的pom.xml这主要是为了方便统一构建多个项目。所以子模块的子模块应该避免出现。 待更新。。。引用如下: https://blog.csdn.net/wuzhenwei0419/article/details/84029454 https://www.cnblogs.com/ruanjianlaowang/p/11214271.html]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
      <tags>
        <tag>开发经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos基本信息和ssh]]></title>
    <url>%2F2019%2F12%2F12%2FCentos%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%92%8Cssh%2F</url>
    <content type="text"><![CDATA[Centos 基本信息和SSHCentos介绍CentOS Linux是一个社区支持的发行版，该发行版来自在Red Hat或CentOS git上免费提供给公众的资源适用于Red Hat Enterprise Linux（RHEL）。因此，CentOS Linux旨在与RHEL在功能上兼容。CentOS专案主要更改软件包以删除上游供应商的品牌和艺术品。CentOS Linux是免费的，可以免费重新分发。每个CentOS版本都会得到维护，直到等效的RHEL版本不再受到一般支持为止。一旦重建了新的RHEL版本，便会提供一个新的CentOS版本-大约每6-12个月发行一次次要点发布，几年则更新一次主要版本。重建所需的时间从点发布的几周到主要版本变更的几个月不等。这样就形成了一个安全，低维护，可靠，可预测和可再现的Linux环境。 下载下载地址 常用命令文件与目录操作 命令 解析 cd /home 进入 ‘/home’ 目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd - 返回上次所在目录 cp file1 file2 将file1复制为file2 cp -a dir1 dir2 复制一个目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录（.代表当前目录） ls 查看目录中的文件 ls -a 显示隐藏文件 ls -l 显示详细信息 ls -lrt 按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序） pwd 显示工作路径 mkdir dir1 创建 ‘dir1’ 目录 mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 mv dir1 dir2 移动/重命名一个目录 rm -f file1 删除 ‘file1’ rm -rf dir1 删除 ‘dir1’ 目录及其子目录内容 查看文件内容 命令 解析 cat file1 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 more file1 查看一个长文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 tail -3 file1 查看一个文件的最后三行 vi file 打开并浏览文件 文本内容处理 命令 解析 grep str /tmp/test 在文件 ‘/tmp/test’ 中查找 “str” grep ^str /tmp/test 在文件 ‘/tmp/test’ 中查找以 “str” 开始的行 grep [0-9] /tmp/test 查找 ‘/tmp/test’ 文件中所有包含数字的行 grep str -r /tmp/* 在目录 ‘/tmp’ 及其子目录中查找 “str” diff file1 file2 找出两个文件的不同处 sdiff file1 file2 以对比的方式显示两个文件的不同 vi file 操作解析i进入编辑文本模式Esc退出编辑文本模式:w保存当前修改:q不保存退出vi:wq保存当前修改并退出vi 查询操作 命令 解析 find / -name file1 从 ‘/’ 开始进入根文件系统查找文件和目录 find / -user user1 查找属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件 find /usr/bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 find -name ‘*.[ch]’ | xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ find -type f -print0 | xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ find -maxdepth 1 -type f | xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 压缩、解压 命令 解析 bzip2 file1 压缩 file1 bunzip2 file1.bz2 解压 file1.bz2 gzip file1 压缩 file1 gzip -9 file1 最大程度压缩 file1 gunzip file1.gz 解压 file1.gz tar -cvf archive.tar file1 把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数） tar -cvf archive.tar file1 dir1 把 file1，dir1 打包成 archive.tar tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 把压缩包释放到 /tmp目录下 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 dir1 把文件和目录压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式的压缩包到当前目录 unzip test.zip -d /tmp/ 解压一个zip格式的压缩包到 /tmp 目录 yum安装器 命令 解析 yum -y install [package] 下载并安装一个rpm包 yum localinstall [package.rpm] 安装一个rpm包，使用你自己的软件仓库解决所有依赖关系 yum -y update 更新当前系统中安装的所有rpm包 yum update [package] 更新一个rpm包 yum remove [package] 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search [package] 在rpm仓库中搜寻软件包 yum clean [package] 清除缓存目录（/var/cache/yum）下的软件包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 网络相关 命令 解析 ifconfig eth0 显示一个以太网卡的配置 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 配置网卡的IP地址 ifdown eth0 禁用 ‘eth0’ 网络设备 ifup eth0 启用 ‘eth0’ 网络设备 iwconfig eth1 显示一个无线网卡的配置 iwlist scan 显示无线网络 ip addr show 显示网卡的IP地址 系统相关 命令 解析 su - 切换到root权限（与su有区别） shutdown -h now 关机 shutdown -r now 重启 top 罗列使用CPU资源最多的linux任务 （输入q退出） pstree 以树状图显示程序 man ping 查看参考手册（例如ping 命令） passwd 修改密码 df -h 显示磁盘的使用情况 cal -3 显示前一个月，当前月以及下一个月的月历 cal 10 1988 显示指定月，年的月历 date –date ‘1970-01-01 UTC 1427888888 seconds’ 把一相对于1970-01-01 00:00的秒数转换成时间 XSheel 5相关操作窗体快捷键 命令 解析 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + a 光标移动到行首（ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（end of line） Ctrl + f 光标向前（forward）移动一个字符位置 Ctrl + b 光标往回（backward）移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + r 显示:号提示，根据用户输入查找相关历史命令（reverse-i-search） Ctrl + w 删除从光标位置前到当前所处单词（word）的开头 Ctrl + t 交换光标位置前的两个字符 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + Alt + d 显示桌面 Alt + b 光标往回（backward）移动到前一个单词 Alt + d 删除从光标位置到当前所处单词的末尾 Alt + F2 运行 Alt + F4 关闭当前窗口 Alt + F9 最小化当前窗口 Alt + F10 最大化当前窗口 Alt + Tab 切换窗口 Alt + 左键 移动窗口（或在最下面的任务栏滚动鼠标滑轮） SSH介绍SSH 为 [Secure Shell](https://baike.baidu.com/item/Secure Shell) 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 SSH用法检查是否开启ssh1$rpm -qa | grep ssh 安装ssh1$yum install openssh-server 开启ssh1$ /bin/systemctl start sshd.service 继续检查是否开启1$ps -e | grep sshd 将ssh添加自启动1$systemctl enable sshd.service]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos mysql配置]]></title>
    <url>%2F2019%2F12%2F11%2FCentos7-mysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Centos 7 Mysql配置Yum安装123456#安装$yum install mysql-server#启动$systemctl start mysqld #登录$mysql -u root -p 配置修改root密码 1234567891011121314进入mysql系统表use mysql;对用户进行排序desc user;修改root密码update user set password = password(“root”) where user = ‘root’;刷新权限flush privileges;赋予其他机器可以访问的权限grant all privileges on . to root@’%’ identified by ‘root’ with grant option; 修改字符集 1$vim /etc/my.cnf 修改成这个样子 1234567891011121314151617181920[client]port=3306socket=/var/lib/mysql/mysql.sockdefault-character-set=utf8[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysql# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0character-set-server=utf8[mysql]no-auto-rehashdefault-character-set=utf8[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 重启mysql服务 1234$service mysqld restart#在mysql中查看字符编码show variables like 'character_set%';]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 防火墙优化]]></title>
    <url>%2F2019%2F12%2F11%2FCentos7-%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[Centos 7 防火墙优化简介Centos 7 使用的防火墙是 firewall，可以允许哪些服务可用，哪些端口可用 开关123456789$systemctl enable firewalld.service #启用 "开机启动"$systemctl disable firewalld.service #关闭 "开机启动"$systemctl start firewalld.service #启用防火墙$systemctl stop firewalld.service #关闭防火墙$systemctl status firewalld.service #查看防火墙状态【开机自启】$chkconfig firewalld on #"开机自启" 开启$chkconfig firewalld off #"开机自启" 关闭 端口端口其实就是 类似于门的东西，你只能通过这扇门来访问我的服务器， 因此对于服务器安全来说，这扇门还是很重要的。 开放端口 12345678910$firewall-cmd --zone=public --add-port=&#123;端口&#125;/tcp --permanent #开放端口#开放端口之后必须重新启动防火墙才可以生效$systemctl restart firewalld.service #重启防火墙# --zone 作用域# --add-port=&#123;端口&#125;/tcp 添加端口# --permanent 永久生效，没有这个重启之后就会失效#查看开启端口$firewall-cmd --list-ports 关闭端口 1$firewall-cmd --zone=public --remove-port=80/tcp --permanent 优化修改22端口 1、打开 /etc/ssh/sshd_config文件 1$vim /etc/ssh/sshd_config 2、将#Port 22 注释去掉，22改为你想设置的端口，如33881，保存 3、重启ssh 1systemctl restart sshd.service 4)将该端口加入防火墙例外并重启防火墙 123$firewall-cmd --permanent --zone=public --add-port=33881/tcp$sudo systemctl restart firewalld.service 密码长度与有效期 默认配置： 123456$cat /etc/login.defs |grep PASS_ |grep -v '#'PASS_MAX_DAYS 99999PASS_MIN_DAYS 0PASS_MIN_LEN 5PASS_WARN_AGE 7 加固方案: 1.备份配置文件： 1$ cp -a /etc/login.defs /etc/login.defs.default 2.编辑配置文件并将相关参数改成如下 12345$vi /etc/login.defsPASS_MAX_DAYS 90PASS_MIN_DAYS 6PASS_MIN_LEN 8PASS_WARN_AGE 30 备注: /etc/login.defs文件的pass_min_len 参数并不具备强制性，测试仍然可以设置7位密码。最终需要cracklib来实现。 参数说明： PASS_MAX_DAYS 密码有效期 PASS_MIN_DAYS 修改密码的最短期限 PASS_MIN_LEN 密码最短长度 PASS_WARN_AGE 密码过期提醒 禁止root通过ssh远程登录 默认配置: 12$cat /etc/ssh/sshd_config |grep PermitRootLogin#PermitRootLogin yes 加固方案: 123456781.备份配置文件$cp -a /etc/ssh/sshd_config /etc/ssh/sshd_config.default2.编辑配置文件$vi /etc/ssh/sshd_config将配置参数#PermitRootLogin yes改成PermitRootLogin no3.保存配置文件4.重启ssh服务$ /etc/init.d/sshd restart SSH 配置参数增强 12345678910111213141516171819202122231.备份配置文件2.编辑配置文件$vi /etc/ssh/sshd_config（1）禁止空密码登录将#PermitEmptyPasswords no参数的注释符号去掉，改成PermitEmptyPasswords no（2）关闭ssh的tcp转发将#AllowTcpForwarding yes参数改成AllowTcpForwarding no（3）关闭S/KEY（质疑-应答)认证方式将#ChallengeResponseAuthentication yes参数，改成ChallengeResponseAuthentication no（4）关闭基于GSSAPI 的用户认证将GSSAPIAuthentication yes参数，改成GSSAPIAuthentication no3.保存配置文件4.重启ssh服务 隐藏系统版本信息 123执行以下命令：$mv /etc/issue /etc/issue.bak$mv /etc/issue.net /etc/issue.net.bak 备注:登录界面显示系统版本信息 系统参数调优 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869701.备份配置文件cp -a /etc/sysctl.conf /etc/sysctl.conf.default2.添加以下调优参数到该文件中net.ipv4.ip_forward = 1net.ipv4.conf.default.rp_filter = 1net.ipv4.conf.default.accept_source_route = 0kernel.sysrq = 0kernel.core_uses_pid = 1kernel.msgmnb = 65536kernel.msgmax = 65536kernel.shmmax = 68719476736kernel.shmall = 4294967296net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.route.gc_timeout = 20net.ipv4.tcp_retries2 = 5net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000net.core.somaxconn = 262144net.core.netdev_max_backlog = 262144net.core.wmem_default = 8388608net.core.rmem_default = 8388608net.core.rmem_max = 16777216net.core.wmem_max = 16777216net.ipv4.route.gc_timeout = 20net.ipv4.ip_local_port_range = 10024 65535net.ipv4.tcp_retries2 = 5net.ipv4.tcp_syn_retries = 2net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_timestamps = 0net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_keepalive_time = 1800net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_wmem = 8192 131072 16777216net.ipv4.tcp_rmem = 32768 131072 16777216net.ipv4.tcp_mem = 94500000 915000000 927000000fs.file-max = 65535kernel.pid_max = 65536net.ipv4.tcp_wmem = 4096 87380 8388608net.core.wmem_max = 8388608net.core.netdev_max_backlog = 5000net.ipv4.tcp_window_scaling = 1net.ipv4.tcp_max_syn_backlog = 10240net.core.netdev_max_backlog = 262144net.core.somaxconn = 262144net.ipv4.tcp_max_orphans = 3276800net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_timestamps = 0net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30net.ipv4.tcp_keepalive_time = 120net.ipv4.ip_local_port_range = 10000 65000net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_max_tw_buckets = 36000]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis逆向工程]]></title>
    <url>%2F2019%2F11%2F21%2FMybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Mybatis逆向工程pom.xml插件123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; generatorConfig.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="DB2Tables" targetRuntime="Mybatis3"&gt; &lt;!-- 避免生成重复代码的插件 --&gt; &lt;!-- &lt;plugin type="com.vi.tmall.util.OverlsMergeablePlugin"/&gt;--&gt; &lt;!-- 是否不生成注释 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true" /&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/tmall_ssm" userId="root" password="root"/&gt; &lt;!-- 这个元素的配置用来指定JDBC类型和Java类型如何转换。 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 是否强制将DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal --&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetPackage:生成实体类存放的包名, targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject="src/main/java"）--&gt; &lt;javaModelGenerator targetPackage="com.vi.tmall.pojo" targetProject="src/main/java"&gt; &lt;!--enableSubPackages 如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。默认为false--&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;!-- trimStrings:是否对数据库查询结果进行trim操作，如果设置为true就会生成类似这样public void setUsername(String username)--&gt; &lt;property name="trimString" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!--生成xml映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成mapper类存放位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.vi.tmall.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名,enableXXX:XXX代表多种SQL方法，该属性用来指定是否生成对应的XXX语句--&gt; &lt;table tableName="category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="true" selectByExampleQueryId="false"&gt; &lt;property name="my.isgen.usekeys" value="true"/&gt; &lt;!--useActualColumnNames:如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式--&gt; &lt;property name="useActualColumnNames" value="true"/&gt; &lt;generatedKey column="id" sqlStatement="JDBC"/&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行在Maven中运行generator插件就行]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设计模式之面向对象设计模式]]></title>
    <url>%2F2019%2F11%2F18%2FJAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[java设计模式之面向对象设计模式概述软件的可维护性和可复用性是两个非常重要的用于衡量软件质量的属性 面向对象设计，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。 单一职责原则定义一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 另一种定义方式就一个类而言，应该仅有一个引起它变化的原因。 解释在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被服用的可能性就越小，而且一个类承担的职责过多，相当于将这些指责耦合在一起，当一个职责变化的时候就可能引起其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将他们封装在同一个类中。 单一职责原则是实现高内聚、低耦合的指导方针 开闭原则开闭原则是面向对象的可复用设计的第一块基石，他是最重要的面向对象设计原则。 定义软件实体应当对扩展开放，对修改关闭。 解释在开闭原则的定义中，软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。 如果一个软件设计符合开闭原则，那么可以非常方便的对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 实现为了满足开闭原则。，需要对系统进行抽象化设计，抽象化是开闭原则的关键。编程时，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。 在后面的24种设计模式中很多设计模式都符合开闭原则，在对每一个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可拓展性。 里氏代换原则定义所有引用基类的地方必须能透明地使用其子类的对象。 解释在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此判断我喜欢所有的动物。 里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在运用里氏代换原则时应该将父类设计为抽象类或者接口，让子类继承父类或者实现父接口，并实现在父类中声明的方法，在运行时子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 依赖倒转原则定义高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 解释依赖倒转原则要求针对接口编程，不需要针对实现编程。 依赖倒转原则要求在程序代码中传递参数时或者在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无需修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式注入所依赖的对象。 常用的三种注入方式： 构造注入，设值注入和接口注入。 后话开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，他们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。 接口隔离原则定义客户端不应该依赖那些它不需要的接口。 解释当一个接口太大时，需要把这个接口分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。 这里的“接口“往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的”接口“，有严格的定义和结构，例如 interface。 在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。 合成复用原则定义优先使用对象组合，而不是通过继承来达到复用的目的。 解释合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。 在复用的时候，尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或者通过继承，但是首先应该考虑使用组合/聚合,组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对于其他类造成的影响相对较少；其次才考虑继承，在使用继承时需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，而且灵活性不够强，只能在有限的环境中使用。 组合/聚合可以将已有的对象纳入新对象中，使之成为新对象的一部分，相对继承关系而言，耦合性相对较低； 合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 扩展关联 关联指的是两个分开的类通过对象或者实例建立地关系。关联可以是一对一，一对多，多对一，多对多等关系。 关联比较宽泛，组合是聚合地一个子集。组合-》聚合-》关联； 聚合 聚合是关联的一种特殊形式：主要体现在三个方面 聚合代表了has-a的关系 并且是一种单向关系。单向的，比如说公寓里有学生，但是学生里面不能有公寓，这是一种天生的单向关系。 在聚合的关系中，两种实例是可以单独存在的，不会相互影响，一个实例的存在与否不会影响与之聚合的实例的存在与否。 组合 组合是一种聚合的限制形式，其中两个实体高度相互依赖，也就是说，两个类高度耦合。有以下特征： 代表着一种part-of关系，就是一个类是另一个类的一部分 在组合的关系中，实例是彼此依赖的 当两个实例是组合关系，他们就是高度耦合的，一个对象必须依赖另一个对象的存在而存在 比如图书馆中会有很多相同或者不同主题的图书，但是如果图书馆被销毁后，对应的图书也就没了，图书不能独立与图书馆而存在，这就是组合关系。 聚合和组合相比较 依赖：聚合代表被关联的一方可以独立于关联一方而存在的关系，比如说，银行和雇员，将银行删除后，雇员仍然存在；然后，组合代表着被关联的一方不能独立与另一方而存在的关系，比如，人没有心脏就不能生存，心脏没有人也就没有了心脏。 关系类型：聚合是has-a关系，组合是part-of关系。 关联类型：组合是一种强关联关系，聚合是一种弱关联关系 迪米特原则定义每一个软件单位对其他单位都只有最少的只是，而且局限于那些与本单位密切相关的软件单位。 解释迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中的某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则则要求限制软件实体之间通信的宽度和深度。 应用迪米特法则可以降低系统的耦合度，使类与类之间保持松散的耦合关系。 定义形式： 不要和 “陌生人” 说话 只与你的朋友直接通信 朋友的类别： 当前对象本身（this） 以参数形式传入到当前对象方法中的对象 当前对象的成员对象 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友 当前对象所创建的对象 任意一个对象如果满足上面的条件之一，就是当前对象的 ”朋友“ ，否则就是 “陌生人” 。 在应用迪米特法则的时候，一个对象只能与直接朋友发生交互，不要与 “陌生人” 直接交互，这样可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。如果一个对象需要调用另一个对象的方法，可以通过 “第三者” 转发这个调用。简单说就是引用一个 “第三者” 来降低现有对象之间的耦合度。 注意： 类的划分上尽量创建松耦合类，类之间的耦合度越低，就越有利于复用，如果修改了一个类，不会对关联的类造成太大的影响。 类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； 类的设计上，只要有可能，一个类型应该设计成不变类，在对其它类的引用上，一个对象对其他对象的引用应当降到最低。 小结低耦合，高内聚，可维护，可复用，可扩展]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（三）]]></title>
    <url>%2F2019%2F11%2F13%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（三）依赖如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。 依赖传递范围设定score：作用域，控制依赖传递 test 仅适用于第一类jar包，其不会向下传递 provided 仅适用于第二类jar包，其不会向下传递 runtime 仅适用于第三类jar包，会向下传递 compile 默认值。适用于第四类jar包，会向下传递 system &lt;systemPath&gt;${basedir}/lib/xxx.jar&lt;/systemPath&gt; import 下节课会说 jar包分类： 编译、运行、打包时都不需要 测试用jar包属于该类型，例如junit、spring-test 编译、运行时需要的jar，打包时不需要 servlet-api，jsp-api属于该类型 编译时不需要，但运行、打包时需要的jar包 mysql驱动属于该类型 Class.forName(“com.mysql.jdbc.Driver”); 编译、运行、打包时均需要的jar包 可选传递optional（可选的） true，表示当前依赖是可选的，即可要可不要 false，默认值，表示默认是传递的 exclusions： exclusion：排除依赖，将所选的依赖排除 依赖冲突直接依赖冲突在同一个工程中出现了同一个依赖的不同版本，系统会自动选择最后导入的那个版本 间接依赖冲突间接依赖冲突在工程中会出问题，所以需要手工删除发生冲突的依赖 上级的包传递到下级，下级版本与上级不一致 版本号的统一与管理 依赖的继承直接继承 可选继承 聚合 课外开源中国—-&gt;国产开源 开源项目管理软件—-&gt;易软天创（禅道） 无反射无框架，无代理无框架]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习中遇到的问题（一）]]></title>
    <url>%2F2019%2F11%2F13%2F%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[学习中遇到的问题（一）1、集合类型只能通过XML来实现 2、setting注入复杂类型数据 list: array value list value set value map: properties prop map entry key value 3、为什么IOC容器中获得bean的时候要把bean转化为接口类型？ 因为new对象的时候也是用接口实例化子类，而在spring-config.xml中已经实例化子类，所以把子类转化为接口类型，实现了多态。 4、javaBean使用包装类 Integer，String，Float等，因为如果值为空 不会显示0 可以显示null 5、线程绑定事务方法 TheadLocal ThreadLocal而是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据 数据库事务控制 6、分页 可以使用分页框架实现 pagehelper 7、引入css样式后面一定要写上 rel=”stylesheet” 8、ResponseBody @ResponseBody是作用在方法上的，表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用（也就是ajax），在使用@RequestMapping后，返回值通常解析为跳转路径，但是加上@ReponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body 中，比如异步获取json数据，加上@ResponseBody后，会直接返回json数据。@RequestBody将HTTP请求正文插入方法中，使用适合的HttpMessageConverter将请求体写入某个对象。 9、 Mapper作用 为了把mapper这个DAO交給Spring管理 为了不再写mapper映射文件 为了给mapper接口 自动根据一个添加@Mapper注解的接口生成一个实现类 10、三层架构 三层架构：表现层，业务层，持久层 持久层：采用DAO模式，建立实体类和数据库表映射（ORM映射）。也就是哪个类对应哪个表，哪个属性对应哪个列。持久层的目的就是为了完成对象数据和关系数据的转换。 业务层：采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作，即保证同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。 表现层：采用MVC模式。 M称为模型，也就是实体类，用于数据的封装和数据的传输。 V称为视图，也就是GUI组件，用于数据的展示。 C称为控制，也就是事件，用于流程的控制。 设计原则 业务层接口的设计原则：一个实体类一个接口，一次提交一个事务方法。业务方法的参数来自表现层。 持久层接口的设计原则：一个实体类一个接口，一次数据库操作一个持久方法。 11、favicon报错 在head标签中最下面写上 1&lt;link rel="shortcut icon" href="#" /&gt; 12、centos防火墙端口 123456789101112131415161718#查看防火墙所有开放端口firewall-cmd --zone=public --list-ports#开启端口firewall-cmd --zone=public --add-port=80/tcp --permanent#命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效#关闭端口firewall-cmd --zone=public --remove-port=80/tcp --permanent#查看防火墙状态firewall-cmd --state #重启防火墙firewall-cmd --reload]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thymeleaf]]></title>
    <url>%2F2019%2F10%2F31%2Fthymeleaf%2F</url>
    <content type="text"><![CDATA[thymeleaf简介Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。 Thymeleaf的主要目标是将优雅的自然模板带到您的开发工作流程中—HTML能够在浏览器中正确显示，并且可以作为静态原型，从而在开发团队中实现更强大的协作。Thymeleaf能够处理HTML，XML，JavaScript，CSS甚至纯文本。 Thymeleaf的主要目标是提供一个优雅和高度可维护的创建模板的方式。 为了实现这一点，它建立在自然模板的概念之上，以不影响模板作为设计原型的方式将其逻辑注入到模板文件中。 这改善了设计沟通，弥合了前端设计和开发人员之间的理解偏差。 Thymeleaf也是从一开始就设计(特别是HTML5)允许创建完全验证的模板。 引入在头部引入xmls的参数 1234&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;/html&gt; 使用主要的使用标签 语法 说明 {home.welcome} 使用国际化文本,国际化传参直接追加(value…) ${user.name} 使用会话属性 @{} &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; – – ${} 中预存对象（表达式中基本对象） param 获取请求参数，比如${param.name},http://localhost:8080?name=jeff session 获取 session 的属性 application 获取 application 的属性 execInfo 有两个属性 templateName和 now(是 java 的 Calendar 对象) ctx vars locale httpServletRequest httpSession – – th扩展标签 th:text 普通字符串 th:utext 转义文本 th:href th:attr &lt;img src=&quot;../../images/gtvglogo.png&quot; th:attr=&quot;src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}&quot; /&gt; th:with 定义常量 th:attrappend th:classappend th:styleappend 其他th标签 * * * th:abbr th:accept th:accept-charset th:abbr th:accept th:accept-charset th:accesskey th:action th:align th:alt th:archive th:audio th:autocomplete th:axis th:background th:bgcolor th:border th:cellpadding th:cellspacing th:challenge th:charset th:cite th:class th:classid th:codebase th:codetype th:cols th:colspan th:compact th:content th:contenteditable th:contextmenu th:data th:datetime th:dir th:draggable th:dropzone th:enctype th:for th:form th:formaction th:formenctype th:formmethod th:formtarget th:frame th:frameborder th:headers th:height th:high th:href th:hreflang th:hspace th:http-equiv th:icon th:id th:keytype th:kind th:label th:lang th:list th:longdesc th:low th:manifest th:marginheight th:marginwidth th:max th:maxlength th:media th:method th:min th:name th:optimum th:pattern th:placeholder th:poster th:preload th:radiogroup th:rel th:rev th:rows th:rowspan th:rules th:sandbox th:scheme th:scope th:scrolling th:size th:sizes th:span th:spellcheck th:src th:srclang th:standby th:start th:step th:style th:summary th:tabindex th:target th:title th:type th:usemap th:value th:valuetype th:vspace th:width th:wrap th:xmlbase th:xmllang th:xmlspace th:alt-title 或th:lang-xmllang（如果其中两个属性值相同） 表达式语法简单的语法 #{...} ：Message 表达式 ${}：变量表达式 *{} ：选择变量表达式 @{}：链接 URL 表达式 变量 分类 示例 文本 ‘one text’ , ‘Another one!’ ,… 数字 0 , 34 , 3.0 , 12.3 ,… 真假 true , false 文字符号 one , sometext , main ,… 字符连接 分类 示例 + ‘The name is ‘+${name} … The name is ${name} 算数运算 语法 示例 +, -, *, /, % 二元运算符 - 减号（一元运算符） 真假运算 分类 示例 and , or 二元运算符 ! , not 否定（一元运算符） 比较运算 分类 示例 &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 比较 == , != ( eq , ne ) 平等 条件运算 分类 示例 if-then (if) ? (then) if-then-else (if) ? (then) : (else) Default (value) ?: (defaultvalue) 表达式中使用内置对象 123456789101112131415161718192021222324252627282930#dates :utility methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects.#numbers :utility methods for formatting numeric objects.#strings : utility methods for String objects: contains, startsWith, prepending/appending, etc. #objects : utility methods for objects in general.#bools : utility methods for boolean evaluation. #arrays : utility methods for arrays.#lists :utility methods for lists.#sets : utility methods for sets.#maps : utility methods for maps.#aggregates : utility methods for creating aggregates on arrays or collections.#messages : utility methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;...&#125; syntax.#ids : utility methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). 预处理 1__$&#123;expression&#125;__ 循环 1234567891011121314151617181920212223242526&lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt;&lt;/tr&gt;迭代器的状态index: 当前的索引，从0开始count: 当前的索引，从1开始size：总数current:even/odd:firstlast&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod,iterStat : $&#123;prods&#125;" th:class="$&#123;iterStat.odd&#125;? 'odd'"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 判断 1234567891011121314151617if&lt;a href="comments.html" th:href="@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;" th:if="$&#123;not #lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;unless&lt;a href="comments.html" th:href="@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;" th:unless="$&#123;#lists.isEmpty(prod.comments)&#125;"&gt;view&lt;/a&gt;switch&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt;&lt;/div&gt;&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt; &lt;p th:case="*"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 模板布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354th:fragment示例templates/footer.html&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml" &lt;body&gt; &lt;div th:fragment="copy"&gt; © 2011 The Good Thymes Virtual Grocery &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;templates/index.html中使用 &lt;body&gt; ... &lt;div th:include="footer :: copy"&gt;&lt;/div&gt; &lt;/body&gt;或者 ... &lt;div id="copy-section"&gt; © 2011 The Good Thymes Virtual Grocery &lt;/div&gt; ...使用 &lt;body&gt; ... &lt;div th:include="footer :: #copy-section"&gt;&lt;/div&gt; &lt;/body&gt;th:include 和 th:replace 区别th:include 加入代码th:replace 替换代码模板传参：参数传递顺序不强制 定义&lt;div th:fragment="frag (onevar,twovar)"&gt; &lt;p th:text="$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;"&gt;...&lt;/p&gt;&lt;/div&gt; 使用&lt;div th:include="::frag ($&#123;value1&#125;,$&#123;value2&#125;)"&gt;...&lt;/div&gt;&lt;div th:include="::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)"&gt;...&lt;/div&gt; 等价于 &lt;div th:include="::frag" th:with="onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;"&gt;） 移除标签 th:remove 取值范围 all：移除所有 body：不移除自己，但移除他的子标签 tag: 只移除自己，不移除他的子标签 all-but-first：移除所有内容除第一个外 none：啥都不做 执行顺序 thymeleaf注释语法 html 看不到，并且 thymeleaf 不会执行 1&lt;!--/* This code will be removed at thymeleaf parsing time! */--&gt; and 未运行可以在 html 中看到，运行后就消失 123&lt;!--/*--&gt; &lt;div&gt;you can see me only before thymeleaf processes me! &lt;/div&gt;&lt;!--*/--&gt; 运行后才会看到 12345678910&lt;table&gt; &lt;th:block th:each="user : $&#123;users&#125;"&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt;&lt;/table&gt; 推荐下面写法（编译前看不见） 123456789&lt;table&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt; &lt;/table&gt; 文本内联th:inline 略 验证模板的正确性 略 特殊用法展示 1&lt;td th:text="$&#123;#aggregates.sum(o.orderLines.&#123;purchasePrice * amount&#125;)&#125;"&gt;23.32&lt;/td&gt;]]></content>
      <categories>
        <category>thymeleaf</category>
      </categories>
      <tags>
        <tag>thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F10%2F30%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker简介Docker是一个开源的应用容器引擎； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。 核心概念 docker主机（Host）：安装了Docker程序的机器 docker客户端（Client）：连接docker主机进行操作 docker仓库（Registry）：用来保存各种打包好的软件镜像 docker镜像（images）：软件打包好的镜像，放在docker仓库中 docker容器（Container）：镜像启动后的一个实例称为一个容器 步骤： 1、安装Docker 2、去Docker仓库找到这个软件对应的镜像 3、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器 4、对容器的启动停止就是对软件的启动停止 安装环境12345678910111213141516171、检查内核版本必须是3.10及以上uname -r2、安装dockeryum install docker3、按y确认4、启动docker# systemctl start docker# docker -v5、开机启动docker# systemctl enable docker6、停止docker# sytemctl stop docker7、进入docker镜像# docker exec -it 容器id 这种方式进入容器，退回到前台时，容器还在运行# docker attach 容器id 这种方式进入容器，退出时，容器也跟着退出8、退出docker镜像# exit 容器操作软件镜像（类似于安装程序）—-运行镜像—-产生一个容器（正在运行的软件） 步骤： 123456789101112131415161718192021222324252627281、搜索镜像# docker search tomcat2、拉取镜像# docker pull tomcat3、根据镜像启动容器# docker run --name mytomcat -d tomcat:latest4、查看运行中的容器# docker ps5、停止运行中的容器# docker stop 容器id6、查看所有容器# docker ps -a7、启动容器# docker start 容器id8、删除一个容器# docker rm 容器id9、启动一个做了端口映射的tomcat-d：后台运行-p：将主机的端口映射到容器的一个端口 主机端口：容器内部的端口10、防火墙# service firewalld status 查看防火墙状态# service firewalld stop 关闭防火墙11、查看容器的日志# docker logs container -name/container -id更多命令可以上官网https://docs.docker.com/engine/reference/commandline/docker/可以参考文档 环境搭建docker官方镜像网站 https://hub.docker.com/ 安装mysql 1docker pull mysql 使用mysql 必选按照人家给的文档来指定参数 1docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 做了端口映射 1docker run -p 3306:3306 --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag 几个其他的高级操作 12345678docker run --name some-mysql -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/my/custom文件夹挂载到 mysqldocker容器的/ect/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在/conf/mysql文件夹下docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些参数]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（三）日志]]></title>
    <url>%2F2019%2F10%2F23%2FSpringBoot%EF%BC%88%E4%B8%89%EF%BC%89%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Spring Boot（三）日志SpringBoot文档日志框架小张：开发一个大型系统： 1、 System.out.println(“”);将关键数据打印在控制台；老板要去掉？ 2、框架来记录系统的一些信息；日志框架；zhanglogging.jar； 3、高大上的几个功能？异步模式？自动归档？xxxx？zhanglogging-good.jar？ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglooging-perfect.jar； 5、JDBC—数据库驱动； 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； 给项目中导入具体的日志实现就行了； 我们之前的日至框架都是实现的抽象层； 市面上的日志框架： JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j。。。。 日志门面 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for java） jboss-logging LOg4j JUL(java.util.logging) Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面：SLF4j； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认使用的是JCL； SpringBoot选用SLF4j和logback； SLF4j的使用如何在系统中使用SLF4j以后开发的时候，日志记录的方法调用，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法； 应该给系统里面导入slf4j的jar包和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件，使用slf4j以后，配置文件还是做成日志实现框架的配置文件； 遗留问题a（slf4j+logback）；Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出； 如何让系统中所有日志都统一到slf4j1、 将系统中其他日志框架先排除出去 2、用中间包来替换原有的日志框架 3、我们导入slf4j其他的实现 SpringBoot日志关系123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; SpringBoot使用它来做日志功能： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 总结： 1、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 2、SpringBoot也把其他的日志都替换成了slf4j 3、中间替换包？ 4、如果我们要引入其他框架？一定要把这个框架的默认日子和依赖移除掉？ SpringBoot能自动适配所有日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架以来的日志框架排除掉； 日志使用默认配置SpringBoot帮我们配置好了日志； 12345678910111213141516171819202122232425/** * 记录器 */Logger logger = LoggerFactory.getLogger(getClass());@Testvoid contextLoads() &#123; /** * 日志的级别 * 由低到高 * trace&lt;debug&lt;warn&lt;error * 可以调整需要输出的日志级别； * 日志就只会在这个级别以后的高级别生效 */ logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); /** * SpringBoot默认给我们使用的是info级别的 * 没有指定级别的就用SpringBoot默认规定级别，root级别 */ logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 12345678日志和输出格式： %d表示日期时间， %thread表示线程名称， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分隔 %msg : 日志消息， %n 是换行符 %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.wys=trace#当前项目下生成springboot.log日志#支持绝对路径#可以指定完整的路径；#logging.file.name=springboot.log#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；#使用spring.log作为默认文件logging.file.path=/spring/log#在控制台输出的日志格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger - %msg%n#指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; === %msg%n 指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用它默认的配置了； Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml ：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项， 由SpringBoot来解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; &lt;!--可以指定某段配置只在某个环境中生效--&gt;&lt;/springProfile&gt; 否则 1no applicable action for [springProfile] 切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j + log4j的方式：排除不相关的依赖，导入自己需要的依赖就行； 可以在官方文档中进行资料查找； 切换为log4j2：导入log4j2的启动器依赖即可；]]></content>
      <categories>
        <category>Spring Boot学习笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键大全]]></title>
    <url>%2F2019%2F10%2F23%2FIDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[IDEA快捷键大全Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件（查找文件） Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处（查找接口实现类） Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC常用注解]]></title>
    <url>%2F2019%2F10%2F20%2FSpring-MVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring MVC 常用注解@Controller这个注解表示当前类是一个控制器组件，并且把这个类装进Spring容器中； 在Spring MVC中，控制器Controller负责处理DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层之后封装成一个Model，然后把该Model返回给对应的View进行展示； 123@Controllerpublic class HelloWorldController &#123;&#125; @RequestMapping作用 用于请求地址映射，可以作用于类和方法上； 参数 value：定义request请求的映射地址； method：定义request请求的方式；包括（GET，POST，OPTIONS，PUT，PATCH，DELETE，TRACE）默认接受的是GET请求，如果请求方式和定义方式不一致，那么就会请求不到指定映射地址。 params：定义request请求中必须包含的参数； headers：定义request请求中必须包含某些指定的请求头；如：@RequestMapping(value=”/test”,headers=”content-type=text/*”)说明请求中必须包含“text/html”等类型的Content-type头，才是一个匹配的请求； consumes：定义请求提交内容的类型； produces：指定返回的内容类型，仅当request请求头中的（Accept）类型中包含该指定类型从才返回； 1234@RequestMapping("/hello")public String hello() &#123; return "hello world quick!";&#125; @RequestParam作用 用于获取传入参数的值 参数 value：参数的名称 required：定义该传入参数是否必须，默认为true，（和RequestMapping的params属性有点类似） 1234@RequestMapping("/hello")public String hello(@RequestParam(name = "myname") String name) &#123; return name;&#125; @PathViriable作用 用于定义路径参数值 参数 value：参数的名称 required：定义传入参数是否为必须值 1234@RequestMapping("/hello/&#123;myname&#125;")public String hello(@PathVariable(name="myname") String name) &#123; return name;&#125; @ResponseBody作用 作用于方法上，可以将整个返回结果以某种格式返回，如json或者xml等 @CookieValue作用 用于获取请求的Cookie值 1234@RequestMapping("/hello")public String hello(@CookieValue(value = "JSESSIONID",defaultValue = "") String cookie) &#123; return "hello world";&#125; @ModelAttribute作用 用于把参数保存到model中，可以注解方法或者参数，注解在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在session中， 这个注解在使用的时候，如果没有指定名称，就默认按照返回类型的类名称（首字母小写）作为属性名称； @SessionAttributes作用 默认情况下，Spring MVC将模型中的数据存储在request域中。当一个请求结束的时候，数据就失效了，如果想要跨页面使用，就需要用的session。而SessionAttributes注解就可以使模型中数据存储一份到session中。]]></content>
      <categories>
        <category>Spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（二）配置]]></title>
    <url>%2F2019%2F10%2F20%2FSpringBoot%EF%BC%88%E4%BA%8C%EF%BC%89%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot（二）配置配置文件SpringBoot使用一个全局的配置文件，配置文件名称是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好了； YAML （YAML Ain’t Markup Language） YAML A Markup Language：是一个标记语言 YAML isn’t Markup Language：不是一个标记语言 标记语言： 以前的配置文件：大多数都使用的是XXXX.xml文件； YAML：以数据为中心，比json，xml更适合做配置文件； YAML：语法配置例子 12server: port: 8081 XML：配置 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; YAML语法基本语法 key:(空格)value ： 表示一对键值对； 以空格的缩进来控制层级关系； 只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感的； 值的写法字面量：普通的值（数字，字符串，布尔）： key: Value ：字面直接来写； 字符串默认不用加上单引号或者双引号； “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: “zhangsan\n lisi”：输出：zhangsan 换行 lisi ‘’: 单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 name: “zhangsan\n lisi”：输出：zhangsan\n lisi 对象、Map（属性和值）（键值对）： key: value : 在下一行来写对象的属性和值的关系；注意缩进 对象还是 key: value的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）： 用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: &#123;cat,dog,pig&#125; 配置文件值注入：配置文件123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2019/10/10 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 JavaBean 12345678910111213141516171819202122232425262728293031package com.wys.springboot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;import java.util.Map;/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * ConfigurationProperties：告诉SpringBoot将本类中所有属性和配置文件中相关的配置进行绑定 * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 我们可以导入配置文件处理器，以后编写配置就有提示了； 123456789&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 中文乱码idea中默认使用的是utf-8编码，所以需要去设置中，将 File Encodings 中的编码类型全都改成utf-8，并且将最下面的把utf-8编码转换成ascill码给勾上去。 @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value; 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 松散绑定属性松散绑定表示驼峰式、下划线(_)、短横线(-) 标准方式person.firstName 方式一大写用-person.first-name 方式二大写用_person.first_name 三种方式，都可以使用推荐，属性书写方式PERSON_FIRST_NAME @PropertySource&amp;@ImportResource@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")//@Validated@PropertySource(value=&#123;"classpath:person.properties"&#125;)public class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="张三/$&#123;key&#125; 从环境变量、配置文件获取值/#&#123;spEL&#125;"&gt;&lt;/property&gt; * &lt;/bean&gt; */ //@Value("$&#123;person.last-name&#125;") //lastName必须是邮箱类型 //@Email private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("false") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring配置文件生效，加载进来；@ImportResource标注在配置类上； 1@ImportResource(value = &#123;"classpath:beans.xml"&#125;) 不来编写Spring的配置文件 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.wys.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring Boot 推荐给容器中添加组件的方式：推荐使用全注解的方式； 配置类 ==== Spring配置文件 使用@Bean给容器中添加组件 12345678910111213@Configurationpublic class MyAppConfig &#123; /** * 将方法的返回值添加到容器中，容器中这个组件默认id就是方法名 * @return */ @Bean public HelloService helloService() &#123; System.out.println("给容器中添加组件了"); return new HelloService(); &#125;&#125; 配置文件占位符随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int&#123;1024,65536&#125;&#125; 占位符获取之前配置的，如果没有可以使用:指定默认值 123456789person.last-name=李四$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2019/10/10person.boss=falseperson.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 Profile概念 Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境 多Profile文件 我们在主配置文件编写的时候，文件名可以是 application-(profile).properties/yml 默认使用application.properties配置； yml支持多文档块模式 12345678910111213141516server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 激活指定profile 在配置文件中指定 spring.profiles.active=dev 命令行： –spring.profiles.active=dev 可以直接在测试的时候，配置传入命令行参数 虚拟机参数： -Dspring.profiles.active=dev 配置文件加载位置spring boot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring Boot的默认配置文件 file:./config/ file:./ classpath:/config/ classpath:/ 以上是按照优先级从高到底的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容 我们也可以通过配置spring.config.location来改变默认配置 Spring Boot会从这四个位置全部加载主配置文件：互补配置； 外部配置加载顺序Spring Boot支持多种外部配置方式 这些方式的优先级如下： 命令行参数 java -jar spring-boot-01-config-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context.path=/abc 多个配置用空格分开；–配置项=值 来自java:comp/env的JNDI属性 java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找 优先加载带profile jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 自动配置原理： SpringBoot启动的时候加载朱配置类，开启了自动配置功能@EnableAutoConfiguration @EnableAutoConfiguration作用： 利用AutoConfigurationImportSelector给容器中导入了一些组件 可以查看selectImports()方法的内容； 1234springFactoriesLoader.loadFactoryName()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把它们添加在容器中 将类路径下的 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值加入到了容器中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 每一个自动配置类进行自动配置功能； 以HttpEncodingAutoConfiguration来为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334@Configuration( //表示这是一个配置类，以前编写的配置文件一样，也可以给容器添加组件 proxyBeanMethods = false)@EnableConfigurationProperties(&#123;HttpProperties.class&#125;)//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到IOC容器中@ConditionalOnWebApplication( //Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；判断当前应用是否是web应用，如果是，当前配置类生效 type = Type.SERVLET)@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断当前项目有没有这个类，CharacterEncodingFilter；Spring MVC中进行乱码解决的过滤器；@ConditionalOnProperty( //判断配置文件是否存在某个配置spring.http.encoding.enabled;如果不存在，判断也是成立的 //即使我们配置文件中不配置spring.http.encoding.enabled=true,也是默认生效的； prefix = "spring.http.encoding", value = &#123;"enabled"&#125;, matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参的构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean //给容器添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 123456@ConfigurationProperties ( //从配置文件中获取指定的值和bean的属性进行绑定 prefix = "spring.http")public class HttpProperties &#123; private boolean logRequestDetails; private final HttpProperties.Encoding encoding = new HttpProperties.Encoding(); 精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfiguration：自动配置类； 给容器中添加组件 xxxxProperties：封装配置文件中相关属性； 细节Conditional@Conditional派生注解（可以自己去了解一下原生的作用） 作用：必须是@Conditional指定的条件成立，才给容器添加组件，配置里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符号要求 @ConditionalOnBean 容器中存在指定的Bean @ConditionalOnMissingBean 容器中不存在指定的Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean,或者这个Bean是首先Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在制定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定条件下才能生效 我们怎么知道哪些自动配置类生效； 我们可以通过启用 debug=true属性；来让控制台自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； Positive matches:（自动配置类启用的） Negative matches：（没有启用，没有匹配成功的自动配置类）]]></content>
      <categories>
        <category>Spring Boot学习笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot（一）入门]]></title>
    <url>%2F2019%2F10%2F19%2FSpringBoot%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot入门SpringBoot 简介 简化Spring应用开发的框架； 整个Spring技术栈的大整合； J2EE开发的一站式解决方案； 微服务2014年martin fowler提出的微服务； 微服务是一种架构风格； 一个应用应该是一组小型服务；可以通过HTTP的方式互通； 单体应用：ALL IN ONE； 把整个应用打成war包就可以部署到服务器上； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元 详细参照微服务文档 Spring Boot优缺点Spring Boot 官网 Spring Boot 来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。 底层就是Spring技术栈 SpringBoot优点 快速创建独立运行的Spring项目以及主流框架集成 快速嵌入式的Servlet容器，应用无需打成war包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成 SpringBoot缺点 入门容易，精通难 SpringBoot封装机制不好懂 对底层api必须特别了解 Spring Boot 例子HelloWorld一个功能 浏览器发送hello请求，服务器接受请求并处理，响应hello world字符串。 1. 创建maven工程 jar包 2. 导入SpringBoot需要的依赖 官网中可以查找到依赖 Maven依赖 12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. 编写一个主程序，启动Spring Boot应用 123456789101112131415161718package com.wys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import javax.swing.*;/** * Spring应用 * @SpringBootApplication 来标注一个主程序类,说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldApplication.class,args); &#125;&#125; 4. 编写相关的Controller、Service 123456789101112131415package com.wys.HelloController;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5. 运行主程序测试 6. 简化部署 可执行jar包 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 导入这个maven插件就行，就可以将这个应用打成jar包，直接使用java -jar的命令进行执行 HelloWorld探究POM文件父项目 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本； 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web; spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成了一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。 主程序类，主入口类1234567891011121314151617package com.wys;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * Spring应用 * @SpringBootApplication 来标注一个主程序类,说明这是一个Spring Boot应用 * 主程序要放在包的位置，不然找不到页面 */@SpringBootApplicationpublic class HelloWorldApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldApplication.class,args); &#125;&#125; @SpringBootApplication： Spring Boot应用标注在某个类上，说明这个类是SpringBoot的主配置类，说明Spring Boot 就应该运行这个累的main方法，来启动SpringBoot应用。 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)@ConfigurationPropertiesScanpublic @interface SpringBootApplication &#123; @SpringBootConfiguration： Spring Boot的配置类； 标注在某个类上，表示这是一个Spring Boot的配置类； @Configuration：配置类上来标注这个注解； 配置类 —— 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； 以前我们需要配置的东西，Spring Boot帮我们自动配置； 这个注解告诉SpringBoot开启自动配置功能；这样自动配置才能生效 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage：自动配置包 @Import({Registrar.class})； Spring的底层注解@Import，给容器导入一个组件；导入的组件Registrar.class 将主配置类（@SpringBootApplication标注的类）所在的包及所有子包里面的所有组件扫描到Spring容器中。 @Import({AutoConfigurationImportSelector.class})： 给容器中导入组件 AutoConfigurationImportSelector：导入哪些组件的选择器 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器导入所有组件，并配置好这些组件； 有了自动配置类，就免去了我们手动编写配置注入功能组件的工作； 以前我们需要自己配置的东西，自动配置类都帮我们配置了； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.2.0.RELEASE.jar这个包中 使用Spring Initializer快速创建Spring Boot项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目 默认生成的Spring Boot项目： 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中的目录结构 static文件夹：保存所有的静态资源；js文件，css文件，图片文件等； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker，thymeleaf）； application.properties：Spring Boot应用的配置文件；]]></content>
      <categories>
        <category>Spring Boot学习笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring和MyBatis整合]]></title>
    <url>%2F2019%2F10%2F15%2FSpring%E5%92%8CMyBatis%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[Spring和MyBatis整合因为学完了Spring和MyBatis，SpringMVC只看了书，没有敲实际代码，所以现在整合一下Spring和MyBatis然后敲个代码练练手，之后还会更新SSM全部整合。 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mybatis_pratices_day(4)&lt;/groupId&gt; &lt;artifactId&gt;mybatis_pratices_day(4)&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context Spring应用上下文 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core Spring核心容器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans Bean模块提供BeanFactory，它是一个工厂模型的复杂实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop 为Spring提供了面向切面的编程方式 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring 整合Spring和MyBatis所需要的jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 c3p0数据连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j 提供日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis mybatis核心jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit 测试环境 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test Spring单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; spring-config.xml因为要整合Spring和MyBatis所以不再使用mybatis-config.xml，统一整合到spring-config.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt; &lt;!--引入配置文件 context:property-placeholder --&gt; &lt;context:property-placeholder location="jdbc-config.properties"&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--配置信息--&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="initialPoolSize" value="10"&gt;&lt;/property&gt; &lt;property name="maxIdleTime" value="30"&gt;&lt;/property&gt; &lt;property name="maxPoolSize" value="100"&gt;&lt;/property&gt; &lt;property name="minPoolSize" value="10"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--mybatis配置--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--加载数据源--&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--扫描mapper文件--&gt; &lt;property name="mapperLocations" value="com/dao/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--dao接口所在包名，Spring会自动查找其下的类 Mybatis MapperScannerConfigurer 自动扫描 将Mapper接口生成代理注入到Spring 整合spring与mybatis --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.dao"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!-- 事务管理 事务是数据库中的概念，就是对数据库的一组操作，由一条或多条sql组成。 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml由于在spring-config.xml中就可以搜索mapper文件了，所以我就没有用这个 dao1234567891011121314151617181920package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;/** * User持久层 */@Mapperpublic interface UserDao &#123; /** * 查找所有用户 * @return */ List&lt;User&gt; selectAllUser();&#125; mapper.xml1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;select id="selectAllUser" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类123456789101112131415161718192021package com.test;import com.dao.UserDao;import com.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;"classpath:spring-config.xml"&#125;)public class UserTest &#123; @Autowired private UserService userService; @Test public void testDao() &#123; System.out.println(userService.selectAllUser()); &#125;&#125; 整个上面就是一个完整的整合过程，剩下的内容就需要自己添加了 问题在整合过程中出现了很多很多问题，最后发现是在spring-config.xml中配置mybatis时，多写了个参数 1234567&lt;!--mybatis配置--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--加载数据源--&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--扫描mapper文件--&gt; &lt;property name="mapperLocations" value="com/dao/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; 这个地方配置了很长时间，是最容易出问题的地方，以后要注意。 上面就是spring与mybatis整合的过程，由于Spring和Spring MVC相近的关系，所以在此配置信息的基础上，加进去spring mvc应该就可以用了。 如果还有问题，我还会继续记录下来。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring和MyBatis整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（二）]]></title>
    <url>%2F2019%2F10%2F11%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（二）课前提问1. 介绍一下maven： 答： maven是一个纯java编写的，具有开源，跨平台，标准化的项目管理工具。 2. 跨平台的意思： 答：跨操作系统平台和IDE平台。 3. IDE是什么： 答： IDE是一个集成开发环境，例如 eclipse，idea等工具。 4. 标准化是什么意思： 答：项目构建标准化，可以跨操作系统平台，项目结构标准化，可以跨IDE平台 上课内容手工创建maven项目包的命名包的名称一般由四到五部分构成： 第一部分：甲方公司域名的倒叙，开发方域名倒叙。原因是为了保证当前项目的全球唯一性。 例如：cn.edu.aynu 和 ip 对应一一关系，之前用的ipv4，不够用，现在都在用ipv6，用不完。 第二部分：项目名称。为了保证在当前公司内部当前项目的唯一性。 例如： cn.edu.aynu.sms 第三部分：模块名称。为了保证资源在当前项目中的唯一性。 例如： cn.edu.aynu.sms.aaa.bbb.ccc 第四部分：功能顶层包。其是为了体现当前包中资源的功能特点。 例如：cn.edu.aynu.sms.aaa.bbb.ccc.service 例如：cn.edu.aynu.sms.aaa.bbb.ccc.dao 第五部分：impl子包。用于存放其父包中接口的实现类。 例如：cn.edu.aynu.sms.aaa.bbb.ccc.service.impl 项目结构标准化 maven常用命令查看命令帮助 mvn -h 清理target mvn clean （这个命令一般都是与其他命令结合使用的） 编译 mvn clean compile 测试 mvn clean test 打包 mvn clean package 安装包 mvn clean install 创建项目骨架（maven3） mvn archetype:generate 创建项目骨架（maven2） mvn org.apache.maven.plugins:maven-archetype-plugin:2.0-alpha-5:generate 查看当前项目已解析依赖 mvn dependency:list 查看当前项目的依赖树 mvn dependency:tree 分析当前项目的依赖 mvn dependency:analyze 将项目构建输出的构建部署到配置对应的远程仓库 mvn clean deploy …… 剩下的感觉都用不到，先不写，用到的时候再记录]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F10%2F07%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax学习介绍AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面 写法1234567891011121314151617181920//方式一:使用post请求的方式,不通过url传参,采用data传参 $.ajax(&#123; url:"$&#123;pageContext.request.contextPath&#125;/请求的控制器",//访问的地址 type:"post", data:&#123;key:value&#125;, dataType:'text',//后台返回的数据格式类型 //回调函数 success:function(data,status) &#123; &#125;&#125;)//方式二:使用get请求的方式，通过url传参$.ajax(&#123; url:"$&#123;pageContext.request.contextPath&#125;/请求的控制器?参数", type:"get", dataType:'text', success:function(data,status) &#123; &#125;&#125;)]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC学习笔记（一）]]></title>
    <url>%2F2019%2F10%2F07%2FSpring-MVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring MVC学习笔记（一）Spring MVC的优势Spring 框架提供了构建Web应用程序的全功能MVC模块——Spring MVC。Spring MVC框架提供了一个DispatcherServlet作用前端控制器来分派请求，同时提供灵活的配置处理程序映射，视图解析，语言环境和主题解析，并支持文件上传。Spring MVC还包含多种视图技术，例如 Java Server Pages（JSP），Velocity，Tiles，iText和POI等。Spring MVC 分离了控制器，模型对象，分派器以及处理程序对象的角色，这种分离让他们更容易进行定制。 Spring MVC的特点 拥有强大的灵活性，非侵入性和可配置性。 提供了一个前端控制器DispatcherServlet，开发者无须额外开发控制器对象。 分工明确，包括控制器，验证器，命令对象，模型对象，处理程序映射视图解析器，等等，每一个功能实现由一个专门的对象完成。 可以自动绑定用户输入，并正确地转换数据类型。例如，Spring MVC能自动解析字符串，并将其设置为模型的int或float类型的属性。 使用一个名称/值Map对象实现更加灵活的模型数据传输。 内置了常见的校验器，可以校验用户输入，如果校验不通过，则重定向回输入表单。输入校验是可选的，并且支持编程方式及声明方式。 支持国际化，支持根据用户区域显示多国语言，并且国际化的配置非常简单。 支持多种视图技术，最常见的有JSP技术以及其他技术，包括Velocity和FreeMarker。 提供了一个简单而强大的JSP标签库，支持数据绑定功能，使得编写JSP页面更加容易。 第一个应用程序创建maven项目 选择这个创建 改变项目部署路径 导入依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置web.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--welcome pages--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置springmvc DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置dispatcher.xml作为mvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--把applicationContext.xml加入到配置文件中--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-config.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 配置dispatcher-servlet.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--此文件负责整个mvc中的配置--&gt; &lt;!--启用spring的一些annotation --&gt; &lt;context:annotation-config/&gt; &lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源映射--&gt; &lt;!--本项目把静态资源放在了webapp的statics目录下，资源映射如下--&gt; &lt;mvc:resources mapping="/css/**" location="/statics/css/"/&gt; &lt;mvc:resources mapping="/js/**" location="/statics/js/"/&gt; &lt;mvc:resources mapping="/image/**" location="/statics/images/"/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!--这句要加上，要不然可能会访问不到静态资源，具体作用自行百度--&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id="defaultViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/view/"/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;property name="exposeContextBeansAsAttributes" value="true"/&gt; &lt;/bean&gt; &lt;!-- 自动扫描装配 --&gt; &lt;context:component-scan base-package="com.controller"/&gt;&lt;/beans&gt; 配置spring-config.xml 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; Controller类 123456789101112131415161718package com.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("/home")public class HelloController &#123; @RequestMapping("/welcome") public String welcome()&#123; return "welcome"; &#125; @RequestMapping("/index") public String index() &#123; return "index"; &#125;&#125; 运行]]></content>
      <categories>
        <category>Spring MVC学习笔记</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三）]]></title>
    <url>%2F2019%2F09%2F26%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记（三）目标这部分内容是为了实现一次mybatis的增删改查（CRUD）操作，以及一些模糊查询等内容。 实现因为增删改查内容比较集中，所以这次完成操作后，把代码整理到一起 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", address='" + address + '\'' + ", sex='" + sex + '\'' + ", birthday=" + birthday + '&#125;'; &#125;&#125; 持久层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.dao;import com.pojo.User;import java.util.List;/** * * 用户持久层接口 */public interface UserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll(); /** * 根据ID查询 * @param id * @return */ User findOneById(Integer id); /** * 保存用户 * @param user * @return */ int saveUser(User user); /** * 更新用户 * @param user * @return */ int updateUser(User user); /** * 删除用户 * @param id * @return */ int deleteUser(Integer id); /** * 模糊查询用户信息 * @param name * @return */ List&lt;User&gt; findByName(String name); /** * 获取用户总记录数 * @return */ int findTotal();&#125; mybatis-config配置文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置个mysql环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?useUnicoder=true&amp;amp;characterEncoding=utf8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射文件--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper映射文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;!--查询所有操作--&gt; &lt;select id="findAll" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt; &lt;!--根据Id查询--&gt; &lt;select id="findOneById" resultType="com.pojo.User"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--插入用户操作--&gt; &lt;insert id="saveUser" parameterType="com.pojo.User"&gt; &lt;!--配置插入成功后，获取插入数据的id keyproperty id 实体类的 keyColumn id 数据库的 resultType 映射值类型 order 在什么时候执行 不写这个的时候，执行完插入后，id值为null，写了之后可以获取到具体id值 --&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id() &lt;/selectKey&gt; insert into User(username, address, sex, birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;) &lt;/insert&gt; &lt;!--更新用户操作--&gt; &lt;update id="updateUser" parameterType="com.pojo.User"&gt; update User set username = #&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--删除用户操作--&gt; &lt;delete id="deleteUser" parameterType="Integer"&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt; &lt;!--根据用户名称查询--&gt; &lt;select id="findByName" parameterType="String" resultType="com.pojo.User"&gt; &lt;!-- 参数占位符 select * from user where username like #&#123;username&#125; --&gt; &lt;!--字符串拼接写法，比较的话上面那个好--&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!--测试用户总数量--&gt; &lt;select id="findTotal" resultType="int"&gt; select count(id) from user &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;/** * MyBatis的CRUD操作 */public class MyBatisTest &#123; private SqlSession session; private UserDao userDao; @Before public void before() throws Exception&#123; InputStream in = Resources.getResourceAsStream("mybatis-config.xml"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); session = sqlSessionFactory.openSession(); userDao = (UserDao)session.getMapper(UserDao.class); &#125; @After public void after() &#123; session.commit(); session.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User i : users) &#123; System.out.println(i); &#125; &#125; /** * 根据ID查询 */ @Test public void testfindOneById() &#123; User user = userDao.findOneById(1); System.out.println(user); &#125; /** * 测试添加用户 */ @Test public void testSaveUser() &#123; User user = new User(); user.setUsername("testSaveUser--1"); user.setSex("女"); user.setAddress("北京"); user.setBirthday(new Date()); //保存操作之前 //System.out.println(user); userDao.saveUser(user); //保存操作之后 System.out.println(user); &#125; /** * 测试用户更新信息 */ @Test public void testUpdateUser() &#123; User user = new User(); //因为没有查询所以，只能指定修改人id user.setId(2); user.setUsername("testUpdateUser"); user.setAddress("北京"); user.setSex("女"); user.setBirthday(new Date()); userDao.updateUser(user); &#125; /** * 测试用户删除操作 */ @Test public void testDeleteUser() &#123; userDao.deleteUser(1); &#125; /** * 根据用户姓名进行模糊查询 */ @Test public void testUserByName() &#123; //模糊查询是需要有百分号的，但是xml文件中的执行语句是没有的，需要自己添加 //第一种写法参数占位符 这个好，使用了预处理 //List&lt;User&gt; users = userDao.findByName("%老%"); //第二种写法字符串拼接写法 List&lt;User&gt; users = userDao.findByName("老"); for(User i : users) &#123; System.out.println(i); &#125; &#125; @Test public void testfindTotal() &#123; int total = userDao.findTotal(); System.out.println(total); &#125;&#125; 数据库文件的话自己可以根据上面的实体类来创建 详细内容都在代码上有注释，可以参考参考]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE框架第二次作业]]></title>
    <url>%2F2019%2F09%2F26%2FJAVAEE%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[JAVAEE框架第二次作业一对多（one-to-many）分析首先思考一下，一对多的关系都有哪些，很容易我们就可以想到，文章，一个人可以发很多篇文章，但是每篇文章只能对应一个人，这就是一对多关系，除此之外，还可以想到父子关系，一个父亲可以有多个孩子，但是每个孩子只能对应一个父亲，了解完关系之后，我们就能开始着手写了。 建表我们以作者和文章的关系来创建数据库的表，首先了解作者和文章的属性，然后确定数据库表的主键和外键。 作者（Author）属性: 作者编号，作者名称；其中主键是作者编号。编号为自增序列。 文章（Article）属性： 文章编号，文章名称，文章内容； 其中主键是文章编号，编号是自增序列。 建表： 理清楚上面关系后我们建表开始，sql命令如下： 12345678910111213create table article( article_id int not null auto_increment, name varchar(35) not null, content varchar(255), author_id int not null, primary key(article_id));create table author( author_id int not null auto_increment, name varchar(35) not null, primary key(author_id)); 这样我们就有了一个article表和author表，然后就可以写后台了。 pojo类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.pojo;import java.util.AbstractList;import java.util.ArrayList;import java.util.List;/** * 作者的实体类 */public class Author &#123; //作者编号 private int id; //作者名称 private String name; //作者所著文章 建立一对多关系 private List&lt;Article&gt; articles; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Article&gt; getArticles() &#123; return articles; &#125; public void setArticles(List&lt;Article&gt; articles) &#123; this.articles = articles; &#125; @Override public String toString() &#123; return "Author&#123;" + "id=" + id + ", name='" + name + '\'' + ", articles=" + articles + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.pojo;/** * 文章的实体类 */public class Article &#123; //文章编号 private int id; //文章名称 private String name; //文章内容 private String content; //作者 建立多对一关系 private Author author; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Author getAuthor() &#123; return author; &#125; public void setAuthor(Author author) &#123; this.author = author; &#125; @Override public String toString() &#123; return "Article&#123;" + "id=" + id + ", name='" + name + '\'' + ", content='" + content + '\'' + ", author=" + author + '&#125;'; &#125;&#125; 导入依赖（包名省略） 创建持久层 12345678910111213141516171819202122package com.dao;import com.pojo.Article;import com.pojo.Author;import java.util.List;/** * 作者的持久层 * 我们这个只需要完成一个一对多查询就行 * 所以只写了一个方法 */public interface AuthorDao &#123; /** * 查询作者所有文章 * @param id * @return */ Author selectArticlesList(int id);&#125; 创建mybatis配置文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;!--这个密码是我自己的，有需要可以修改--&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;!--可以XML配置，可以注解，这里就用xml配置了--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/Author.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建mapper映射文件 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.AuthorDao"&gt; &lt;!--一对多写法--&gt; &lt;resultMap id="AuthorMap" type="com.pojo.Author"&gt; &lt;id column="author_id" property="id"&gt;&lt;/id&gt; &lt;result column="author_name" property="name"&gt;&lt;/result&gt; &lt;collection property="articles" ofType="com.pojo.Article"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="name" property="name"&gt;&lt;/result&gt; &lt;result column="content" property="content"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--别名要加空格--&gt; &lt;select id="selectArticlesList" parameterType="int" resultMap="AuthorMap"&gt; select a.id author_id,a.name author_name, b.* from author a left join article b on a.id = b.author_id where a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import java.io.*;import java.util.List;import com.dao.AuthorDao;import com.pojo.Article;import com.pojo.Author;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;public class AuthorTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void before() throws IOException &#123; InputStream in = Resources.getResourceAsStream("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); &#125; /** * 获取作者所写的所有文章 */ @Test public void getArticles() &#123; SqlSession session = sqlSessionFactory.openSession(); AuthorDao authorDao = session.getMapper(AuthorDao.class); Author author = authorDao.selectArticlesList(1); for(Article i : author.getArticles()) &#123; System.out.println(i.getName()); &#125; &#125;&#125; 多对一多对一在一对一基础上进行修改，增加了一个持久层和mapper文件，就是根据多个文章查找到作者信息。 持久层 1234567891011121314151617package com.dao;import com.pojo.Article;import com.pojo.Author;/** * 文章持久层 */public interface ArticleDao &#123; /** * 根据帖子ID查找作者信息 * @param id * @return */ Article selectAuthorByArticle(int id);&#125; mapper 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dao.ArticleDao"&gt; &lt;resultMap id="ArticleMap" type="com.pojo.Article"&gt; &lt;id column="article_id" property="id"&gt;&lt;/id&gt; &lt;result column="article_name" property="name"&gt;&lt;/result&gt; &lt;result column="content" property="content"&gt;&lt;/result&gt; &lt;!--存储查询的用户所属信息--&gt; &lt;association property="author" javaType="com.pojo.Author"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="name" property="name"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectAuthorByArticle" resultMap="ArticleMap" parameterType="int"&gt; select b.* from article a,author b where b.id= a.author_id and a.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789@Testpublic void getAuthor() &#123; SqlSession session = sqlSessionFactory.openSession(); ArticleDao articleDao = session.getMapper(ArticleDao.class); Article article = articleDao.selectAuthorByArticle(1); System.out.println(article.getAuthor().getName()); session.close();&#125; 大概就上面那么多了，剩下的等上完课再进行修改吧。。。 还是有很多知识都不懂，很难受。。。]]></content>
      <categories>
        <category>JAVAEE框架作业</category>
      </categories>
      <tags>
        <tag>JAVAEE框架作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（四）]]></title>
    <url>%2F2019%2F09%2F23%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（四）Spring AOP的基本概念AOP（Aspect-Oriented Programming）即面向切面编程，他与OOP（Object-Oriented Programming,面向对象编程）相辅相成。 在OOP中，以类作为程序的基本单元，而AOP中的基本单元是Aspect（切面）。Struts2的拦截器设计就是基于AOP的思想，是一个比较经典的应用。 在业务处理代码中通常由日志记录，性能统计，安全控制，事务处理，异常处理等操作，尽管使用OOP可以封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中，因此，采用OOP等日志记录等操作不仅增加了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题，AOP思想应允而生。 AOP采取横向抽取机制，即将分散在各个方法中的重复代码提取出来，然后在程序编译或者运行阶段，将这些抽取出来的代码应用到需要执行的地方。这种横向抽取机制采用传统的OOP是无法办到的，因为OOP实现的是父子关系的纵向重用。但是AOP不是OOP的替代品，而是OOP的补充，他们是相辅相成的。 在AOP中，横向抽取机制的类与切面的关系如图所示： AOP的术语 名称 意义 切面 切面（Aspect）是指封装横切到系统功能（例如事务处理）的类。 连接点 连接点（Joinpoint）是指程序运行中的一些时间点，例如方法的调用或异常的抛出。 切入点 切入点（Pointcut）是指需要处理的连接点。在Spring Aop中，所有的方法执行都是连接点，二切入点是一个面熟信息，他修饰的是连接点，通过切入点确定那些连接点需要被处理。 通知 通知（Advice）是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要执行的程序代码，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。 引入 引入（Introduction）允许在现有的实现类中添加自定义的方法和属性 目标对象 目标对象（Target Object）是指所有被通知的对象。如果AOP框架使用运行时代代理的方式（动态AOP）来实现切面，那么通知对象总是一个代理对象。 代理 代理（Proxy）是通知应用到目标对象之后被动态创建的对象。 织入 织入（Weaving）是将切面代码插入到目标对象上，从而生成代理对象的过程。根据不同的实现技术，AOP织入有3种方式：编译器织入，需要有特殊的java编译器；类装载期织入，需要有特殊的类装载器；动态代理织入，在运行期为目标类添加通知生成子类的方式。Spring AOP框架默认采用动态代理织入，而AspectJ（基于java语言的AOP框架）采用编译期织入和类装载期织入。 AOP依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 这些是aop依赖的核心部分 剩下的就是spring核心jar包了，此处就不一一列举 基于XML的AOPxml配置 12345678910111213141516&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* *.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref="MyAspect"&gt; &lt;!--前置通知--&gt; &lt;aop:before method="beforeAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt; &lt;!--后置通知--&gt; &lt;aop:after method="afterAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after&gt; &lt;!--异常通知--&gt; &lt;aop:after-throwing method="exceptionAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after-throwing&gt; &lt;!--最终通知--&gt; &lt;aop:after-returning method="finallyAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:after-returning&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 实现类 12345678910111213141516171819202122232425262728293031323334353637package com.util;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面 */public class MyAspect &#123; public void beforeAdvice() &#123; System.out.println("这是前置通知!-----比如创建连接对象"); &#125; public void afterAdvice() &#123; System.out.println("这是后置通知!------比如提交事务"); &#125; public void finallyAdvice() &#123; System.out.println("这是最终通知-------比如关闭连接"); &#125; public void exceptionAdvice() &#123; System.out.println("这是异常通知-------比如回滚事务"); &#125; public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println("这是前置通知!-----比如创建连接对象"); try&#123; joinPoint.proceed(); System.out.println("这是后置通知!------比如提交事务"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("这是异常通知-------比如回滚事务"); &#125;finally &#123; System.out.println("这是最终通知-------比如关闭连接"); &#125; &#125;&#125; 环绕通知 123456789&lt;!--配置AOP--&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id="pointcut" expression="execution(* *.*(..))"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref="MyAspect"&gt; &lt;aop:around method="aroundAdvice" pointcut-ref="pointcut"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 执行顺序 前置通知： 在方法执行前执行 后置通知： 在方法执行后执行，如果有异常，就不会执行这个 最终通知： 执行完所有通知之后执行 异常通知： 发生异常的时候执行 环绕通知： 包含了以上四种通知类型 基于注解的AOP注解 名称 作用 @Aspect 表示这是一个切面类 @Before 在方法执行前执行 @After 在方法执行后执行，如果有异常，就不会执行这个 @AfterReturning 执行完所有通知之后执行 @AfterThrowing 发生异常的时候执行 @Around 包含了以上四种通知类型 @Pointcut 切入点表达式 切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.util;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * 切面 */@Aspect@Componentpublic class MyAspect &#123; @Pointcut("execution(* *.*(..))") public void pointcut()&#123;&#125; @Before("pointcut()") public void beforeAdvice() &#123; System.out.println("这是前置通知!"); &#125; @After("pointcut()") public void afterAdvice() &#123; System.out.println("这是后置通知!"); &#125; @AfterReturning("pointcut()") public void finallyAdvice() &#123; System.out.println("这是最终通知"); &#125; @AfterThrowing("pointcut()") public void exceptionAdvice() &#123; System.out.println("这是异常通知"); &#125; @Around("pointcut()") public void aroundAdvice(ProceedingJoinPoint joinPoint) &#123; System.out.println("前置通知"); try&#123; joinPoint.proceed(); System.out.println("后置通知"); &#125;catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("异常通知"); &#125;finally &#123; System.out.println("最终通知"); &#125; &#125;&#125; 一定要给这个类使用Component注解，不然不会把这个加入Spring容器中 在XML中开启注解支持 12&lt;!--启动基于注解的Aspect的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 测试类不变 结果和上面一致 课后习题1. 什么是AOP？AOP有哪些术语？为什么要学习AOP编程？ AOP就是面向切面编程，术语的话参考上面的AOP术语。 AOP可以处理OOP不能处理的问题，AOP可以减少大量代码编写，抽取重复代码块，增加代码复用率，减少耦合性，使开发者逻辑更清晰，工作更简单。 2. 在Java中有哪些常用的动态代理技术？ Proxy Cglib 3. AspectJ框架的AOP开发方式有几种？ 基于XML的开发方式 基于注解的开发方式]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit单元测试]]></title>
    <url>%2F2019%2F09%2F23%2FJunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[整合JUnit单元测试JUnit概述JUnit是一个基于java语言的单元测试框架，Junit在测试驱动的开发方面有很重要的发展，是起源于JUnit的一个统称为xUnit的单元测试框架之一。 依赖所依赖的导包 1234567891011121314&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; spring-test是整合spring时所需要依赖的包 junit就是进行单元测试所需要依赖的包 还需要其他的Spring核心jar包，这就不一一列举了 注解RunWith@RunWith：就是一个运行器 @RunWith(JUnit4.class)：就是指用JUnit4来运行 @RunWith(SpringJUnit4ClassRunner.class)： 让测试运行于Spring测试环境 @RunWith(Suite.class)： 一套测试集合 ContextConfiguration概念： Spring整合JUnit4测试时，使用注解引入多个配置文件 单个文件： @ContextConfiguration(Locations=&quot;classpath:spring-config.xml&quot;) @ContextConfigruation(classes=Configuration.class) 多个文件： @ContextConfiguration(locations={&quot;classpath:spring-config1.xml&quot;,&quot;classpath:spring-config2.xml&quot;}) 样例123456789101112131415161718192021222324252627package com.test;import com.service.AccountService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Configuration;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;/** * 初始化Spring容器 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:spring-config.xml")public class AccountTest &#123; @Resource(name="accountService") private AccountService accountService; @Test public void Test() &#123; accountService.saveAccount(); &#125;&#125;]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE框架第一次作业]]></title>
    <url>%2F2019%2F09%2F18%2FJAVAEE%E6%A1%86%E6%9E%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[JAVAEE框架第一次作业分析&nbsp;&nbsp;&nbsp;&nbsp;首先，我之前认为是为了优化实现类中的方法，所以想到了整合Spring然后利用AOP的事务通知来使持久层的实现类中方法解耦，后来才明白原来是直接将实现类中的方法整合在测试类中进行使用（是我太菜了，确信！） 代码整合删除实现类 &nbsp;&nbsp;&nbsp;&nbsp;这个过程是为了使测试类中提示错误，从而有针对性，便于修改 修改测试类代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.abc;import static org.junit.Assert.assertTrue;import com.abc.beans.Student;import com.abc.dao.IStudentDao;import com.abc.utils.MyBatisUtil;import org.apache.ibatis.session.SqlSession;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Unit test for simple App. */public class MyTest&#123; private IStudentDao dao; private SqlSession sqlSession; @Before public void before() throws IOException &#123; sqlSession = MyBatisUtil.getSqlSession(); dao = sqlSession.getMapper(IStudentDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; /** * Rigorous Test :-) */ //插入学生信息 @Test public void Test01() &#123; Student student = new Student("王五",21,80.5); System.out.println("插入前："+student); dao.insertStudent(student); sqlSession.commit(); System.out.println("插入后："+student); System.out.println("插入成功！"); &#125; //获取新插入学生id @Test public void Test02() &#123; Student student = new Student("李四",19,90.5); System.out.println("插入前："+student); dao.insertStudentCatchId(student); sqlSession.commit(); System.out.println("插入后："+student); System.out.println("插入成功！"); &#125; //删除学生信息 @Test public void Test03() &#123; dao.deleteStudentById(29); sqlSession.commit(); System.out.println("删除成功！"); &#125; //修改学生信息 @Test public void Test04() &#123; Student student = new Student("小绿",22,96); student.setId(30); dao.updateStudent(student); sqlSession.commit(); System.out.println("修改成功！"); &#125; //查询全部学生信息List @Test public void Test05() &#123; List&lt;Student&gt; students = dao.selectAllStudent(); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //查询全部学生信息Map @Test public void Test06() &#123; Map&lt;String,Student&gt; map = dao.selectAllStudentMap(); System.out.println(map.get("李四")); &#125; //按照id查询学生信息 @Test public void Test07() &#123; Student student = dao.selectStudentById(30); System.out.println(student); &#125; //按照name查询学生信息 @Test public void Test08() &#123; List&lt;Student&gt; students = dao.selectStudentByName("小绿"); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息1 //把多个参数封装到对象 @Test public void Test09() &#123; Student student = new Student("小",20,-1); List&lt;Student&gt; students = dao.selectStudentByCondition(student); for (Student s:students)&#123; System.out.println(s); &#125; &#125; //按照复合条件查询学生信息2 //把多个查询条件封装到map @Test public void Test10() &#123; Map map = new HashMap(); Student student1 = new Student(null,18,-1); Student student2 = new Student(null,22,-1); map.put("stu1",student1); map.put("stu2",student2); List&lt;Student&gt; students = dao.selectStudentByCondition2(map); for (Student s:students)&#123; System.out.println(s); &#125; &#125;&#125; Mapper配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.abc.dao.IStudentDao"&gt; &lt;!-- 1.parameterType可以省略，但若不省略一定把后边的类型填写正确 2.sql语句中value中的内容，必须是#&#123;&#125;，其中name，age，score指的 是传入参数对象的属性，其底层是通过反射机制从参数对象的get方法获取相应的属性值 --&gt; &lt;insert id="insertStudent" parameterType="com.abc.beans.Student"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;/insert&gt; &lt;insert id="insertStudentCatchId"&gt; insert into student (name,age,score) value (#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;) &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select last_insert_id() &lt;!--select @@identity--&gt; &lt;/selectKey&gt; &lt;/insert&gt; &lt;delete id="deleteStudentById" parameterType="int"&gt; delete from student where id = #&#123;id&#125; &lt;/delete&gt; &lt;update id="updateStudent"&gt; update student set name=#&#123;name&#125;,age=#&#123;age&#125;,score=#&#123;score&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--resultType不是最终需要的结果类型，而是查询出每一条数据封装的结果类型--&gt; &lt;select id="selectAllStudent" resultType="Student"&gt; select id,name,age,score from student &lt;/select&gt; &lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id = #&#123;xx&#125; &lt;/select&gt; &lt;select id="selectStudentByName" resultType="Student"&gt; &lt;!--select id,name,age,score from student where name like '%小%'--&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' &lt;!--select id,name,age,score from student where name like concat('%',#&#123;name&#125;,'%')--&gt; &lt;!--select id,name,age,score from student where name like '%$&#123;value&#125;%'--&gt; &lt;/select&gt; &lt;select id="selectStudentByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;name&#125; '%' and age &amp;lt; #&#123;age&#125; &lt;/select&gt; &lt;select id="selectStudentByCondition2" resultType="Student"&gt; &lt;!--select id,name,age,score from student where age &gt; #&#123;min&#125; and age &amp;lt; #&#123;max&#125;--&gt; select id,name,age,score from student where age &gt; #&#123;stu1.age&#125; and age &amp;lt; #&#123;stu2.age&#125; &lt;/select&gt; &lt;!-- #&#123;&#125;中可以写什么内容： 1.若传入参数为基本数据类型，可以为任意字符，起占位符的作用 2.若传入参数为对象，必须为对象的属性 3.若传入参数为map 1）如果map中的值为基础数据类型，可以放map的key 2）如果map中的值为对象，可以放map的key.属性 --&gt;&lt;/mapper&gt; 由于配置文件和持久层中有些方法命名不匹配，所以我都进行了修改，持久层代码 12345678910111213141516171819202122232425262728package com.abc.dao;import com.abc.beans.Student;import java.util.List;import java.util.Map;public interface IStudentDao &#123; void insertStudent(Student student); void deleteStudentById(int id); void insertStudentCatchId(Student student); void updateStudent(Student student); List&lt;Student&gt; selectAllStudent(); Map&lt;String, Student&gt; selectAllStudentMap(); Student selectStudentById(int id); List&lt;Student&gt; selectStudentByName(String name); List&lt;Student&gt; selectStudentByCondition(Student student); List&lt;Student&gt; selectStudentByCondition2(Map map);&#125; &nbsp;&nbsp;&nbsp;&nbsp;同时如果出现无法连接数据库等问题，请到MyBatis配置文件中修改数据库连接的信息，或者也需要去修改你自己的MySQL数据库中的数据库或者表的信息。 以上便是整个过程，如果有错误，我会及时修改。]]></content>
      <categories>
        <category>JAVAEE框架作业</category>
      </categories>
      <tags>
        <tag>JAVAEE框架作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA代理]]></title>
    <url>%2F2019%2F09%2F18%2FJAVA%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[jAVA代理代理模式​ 使用一个代理对象将对象包装起来，然后用该代理对象来取代该对象，任何对原始对象的调用都要通过代理，代理对象决定是否以及何时调用原始对象的方法 静态代理​ 要求被代理类和代理类同时实现相应的一套接口，通过代理类调用重写接口的方法，实际上调用的是原始对象的同样的方法。如下图： ​ Client调用Source的method()方法，实际上是Proxy来调用method()方法，静态代理中Source跟Proxy都要实现接口Sourceable。 实现方式创建接口 123456789package com.proxy;public interface ClientDao &#123; /** * 主体内容 */ void content();&#125; 创建实现类 1234567891011package com.proxy;public class ClientDaoImpl implements ClientDao&#123; /** * 实现的方法 */ @Override public void content() &#123; System.out.println("这是主体内容"); &#125;&#125; 创建代理类 12345678910111213141516package com.proxy;public class ClientStaticProxy implements ClientDao&#123; private ClientDao clientDao; public void setClientDao(ClientDao clientDao) &#123; this.clientDao = clientDao; &#125; @Override public void content() &#123; System.out.println("对方法增强前"); clientDao.content(); System.out.println("对方法增强后"); &#125;&#125; 测试类 1234567891011121314package com.test;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientStaticProxy clientStaticProxy = new ClientStaticProxy(); ClientDao clientDao = new ClientDaoImpl(); clientStaticProxy.setClientDao(clientDao); clientStaticProxy.content(); &#125;&#125; 结果 优点 可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截 缺点 因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增强方法，则目标对象和代理类都需要维护。 动态代理JDK代理​ 动态代理是指动态在内存中构建代理对象（需要我们指定要代理的目标对象实现的接口类型），利用JDK的API生成指定接口的对象，也称为JDK代理或者接口代理。 ​ 下面是原理图片： ​ 因为上面创建过类了，所以现在只需要创建动态代理类即可 1234567891011121314151617181920212223242526272829303132333435package com.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 动态代理类 */public class ClientAutoProxy &#123; //被代理的对象 private Object targetObject; public ClientAutoProxy(Object targetObject) &#123; this.targetObject = targetObject; &#125; public Object getProxyInstance() &#123; return Proxy.newProxyInstance( //代理对象的类加载器 targetObject.getClass().getClassLoader(), //目标对象实现的接口，因为需要根据接口动态生成对象 targetObject.getClass().getInterfaces(), //InvocationHandler:事件处理器，即对目标对象方法的执行进行处理 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("方法增强前"); Object resultValue = method.invoke(targetObject, args); System.out.println("方法增强后"); return resultValue; &#125; &#125;); &#125;&#125; 测试类 123456789101112131415package com.test;import com.proxy.ClientAutoProxy;import com.proxy.ClientDao;import com.proxy.ClientDaoImpl;import com.proxy.ClientStaticProxy;public class Test &#123; public static void main(String[] args) &#123; ClientDao clientDao = new ClientDaoImpl(); ClientAutoProxy clientAutoProxy = new ClientAutoProxy(clientDao); ClientDao clientDaoProxy = (ClientDao)clientAutoProxy.getProxyInstance(); clientDaoProxy.content(); &#125;&#125; 结果与之前一样 需要注意的地方： 1Object resultValue = method.invoke(targetObject, args); ​ 这条语句在执行的时候，一开始我把targetObject对象写成了proxy对象，导致程序进入了死循环，经百度之后，了解到，因为proxy对象表示当前代理对象，这么调用之后又会调用到SimpleInvocationHandler的invoke方法，这个就要涉及到底层原理知识了，现阶段不过多讨论。 ​ 还有就是，在测试类中，因为返回类型为Object类型的对象，所以需要强转为所需要的类型。 优点 ​ 代理对象不需要实现接口，免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需要在事件处理器中添加对方法的判断即可。 缺点 ​ 代理对象不需要实现接口，但是目标对象一定要实现接口，否则无法使用JDK动态代理。]]></content>
      <categories>
        <category>JAVA代理</category>
      </categories>
      <tags>
        <tag>JAVA代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven课上学习（一）]]></title>
    <url>%2F2019%2F09%2F18%2FMaven%E8%AF%BE%E4%B8%8A%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Maven课上学习（一）Maven概述maven特性 纯java编写： 具有跨平台特性，只需要一套程序就行 开源： 可以对源码修改 互联网思维： 分享，共享 树立自己的IP，让自己流量变大，然后使自己变得有价值 跨平台： 跨两个平台： 跨OS平台（操作系统），跨IDE平台 IDE（Integrated Development Enviroment）：用于提供程序开发环境的应用程序 不同的IDE工具创建的项目结构不同，不能互相导入项目 maven把项目结构标准化，在哪开发都能导入项目 标准化的： 项目构建标准化： 跨操作系统平台（跨OS平台） 项目结构标准化： 跨IDE平台 Maven项目本身是和IDE没有任何关系的 基于项目对象模型（POM）： pom文件可以继承，具有继承性 一般导入依赖是通过 groupId，artifactId，version，简称gav坐标 maven核心都是由插件完成的，导入坐标可以自动下载插 项目构建： maven的管理模块来生成一些必要的组件，节省人工 依赖管理，对jar包进行管理，只需要导入坐标就行 报告生成： Maven 可以生成站点报告, 可以较为方便的实现对项目的管理。 Maven工作原理 maven寻找依赖过程 本地仓库 -&gt; maven私服（阿里云或者公司内部） -&gt; maven中心仓库 依次，到各级库的范围越来越广 Maven的安装与配置官网下载maven https://maven.apache.org/download.cgi 解压到某个文件夹 例如F盘 设置环境变量 在系统变量中创建 MAVEN_HOME ，内容填Maven的目录 例如 F:\apache-maven-3.6.2-bin\apache-maven-3.6.2 然后在path中添加MAVEN_HOME的bin目录 %MAVEN_HOME%\bin; 然后在cmd中测试一下，输入 mvn -v查看版本 如果有的话就没问题了 Maven换源（这个是最重要的）setting.xml文件 这个文件在maven文件夹下的conf文件夹中，找到后用编辑器打开 需要设置两个地方： 首先是本地仓库： 找到localRepository这个标签所在位置，一般来说都是注释状态，我们把注释去掉，然后把标签内内容改成maven文件夹的绝对路径就行 接下来最重要了，更换镜像： ​ 找到mirrors标签，然后把阿里云镜像添加进去即可： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 课外内容： 英语口语发音要注意，发音正确不一定学习好，但发音错误说明一定不是好学校 tar.gz文件夹： 高度压缩过的文件夹 zip： 普遍压缩 bin文件夹： 编译过的文件，二进制文件 src： 源码，未经过编译的]]></content>
      <categories>
        <category>Maven学习</category>
      </categories>
      <tags>
        <tag>Maven学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二）]]></title>
    <url>%2F2019%2F09%2F17%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBatis学习笔记视频篇（二）紧接着上面的入门案例，这次使用注解的方式 准备​ 首先新建一个maven项目，然后将java和resources文件夹复制过来，然后test文件夹也复制过来，还有pom.xml依赖也复制过来。 ​ 紧接着将resources文件夹下的com文件夹删除 修改​ 我们首先把sqlMapConfig.xml内容修改一下 123456&lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果使用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt; &lt;mapper class="com.dao.UserDao"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 只需要把最下面的mapper换成类名即可 ​ 然后是类中添加注解 12345678910111213141516171819package com.dao;import com.pojo.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ @Select("select * from user") List&lt;User&gt; findAll();&#125; ​ 在方法名上面添加注解标签Select，代表查询语句，参数则是具体查询语句，进行测试，发现结果与xml方式时的运行结果一致。 明确： ​ 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式，不管是使用XML还是注解配置，但是MyBatis它是支持写实现类的。 ​ 因此我们下来就手写一次实现类，来试一试。 开始手写实现类还是基于第一次的xml来实现的 创建一个dao的实现类 1234567891011121314151617181920212223242526package com.dao.impl;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; findAll() &#123; //使用工厂创建session对象 SqlSession session = factory.openSession(); //使用session进行查询 List&lt;User&gt; users = session.selectList("com.dao.UserDao.findAll"); session.close(); return users; &#125;&#125; UserDao的mapper不做修改 修改测试类内容 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import com.dao.UserDao;import com.dao.impl.UserDaoImpl;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream("sqlMapConfig.xml"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂创建dao对象 UserDao userdao = new UserDaoImpl(factory); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 in.close(); &#125;&#125; 因为session转移到实现类中，所以此处只需要new一个实现类就行 实际开发中并不使用这种方式，写这个是为了告诉我们，在mapper.xml中，只靠id是无法定位到具体的方法中的，还需要我们加上namespace才能找到执行语句。 mybatis入门案例模式中的设计模式分析]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一）]]></title>
    <url>%2F2019%2F09%2F17%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MyBits学习笔记视频篇（一）框架1. 什么是框架 ​ 他是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题，例如，MyBits解决的是持久层的问题，Spring和Spring MVC 解决的是表现层的问题。 2. 使用框架的好处 ​ 框架风阻航了很多细节，是开发者可以使用极简的方式实现功能，大大提高开发效率。 三层架构​ 表现层：用于展示数据的 ​ 业务层：处理业务需求 ​ 持久层：和数据库交互的 持久层技术解决方案1. JDBC技术 ​ Connection ​ PreparedStatement ​ ResultSet 2. Spring的JdbcTemplate： ​ Spring中对jdbc的简单封装 3. Apache的DBUtils ​ 它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装 4. 以上这些都不是框架 ​ JDBC是规范 ​ Spring的JdbcTemplate和Apache的DBUtils都只是工具类 MyBatis框架概述​ mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，是开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等复杂的过程。 ​ 它使用了ORM思想，实现了结果集的封装，Object Relational Mapping 对象关系映射，简单地说，就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。 ​ 实体类中的属性和数据库表的字段名名称保持一致。 MyBatis的入门mybatis的环境搭建 ​ 首先创建一个maven项目 ​ 在pom.xml中导入相关的包 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;my_pratices_mybits_day_1&lt;/groupId&gt; &lt;artifactId&gt;my_pratices_mybits_day_1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.pojo;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 创建接口 1234567891011121314151617package com.dao;import com.pojo.User;import java.util.List;/** * 用户的持久层 */public interface UserDao &#123; /** * 查询所有操作 * @return */ List&lt;User&gt; findAll();&#125; 创建Mybatis-config.xml整体配置文件 因为我这里没有，所以创建了一个模板 创建模板过程就是： 打开idea设置中的File and Code Templates中的Files 然后点击“+”号，Name输入MyBatis-config.xml，Extendsion填写 xml 然后下面模板中添加如下代码 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 整个模板就配置完毕了，然后创建就行 在MyBatis-config.xml配置文件中写入以下代码 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置数据库的四个基本信息--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="wang123"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/UserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注意上面一定要把environments的default和environment的id都写上去 创建映射配置文件UserDao.xml 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;!--配置查询所有--&gt; &lt;select id="findAll" resultType="com.pojo.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 这个地方会报错，原因是没有写resultType参数，结果集不知道封装到哪里去。 而且那个sql语句末尾不能加“；”符号 环境搭建注意的事项： ​ 第一个是： 创建UserDao.xml和UserDao.java时名称是为了和我们之前的知识保持一致。在MyBatis中它把持久层的操作接口名称和映射文件，也叫做Mapper，所以UserDao和UserMapper是一样的。​ 第二个是： 在idea中创建目录时，他和包是不一样的，包在创建时，com.dao他是二级结构，而创建目录的时候，com.dao他是一级结构，所以必须要一层一层创建​ 第三个是：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个是：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名 ​ 第五个是：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 ​ 当我们遵从了第三，四，五点之后，我们在开发中就无须再写doa的实现类了。 创建log4j.properties 1234567891011121314151617181920212223242526272829303132333435363738394041424344# priority :debug&lt;info&lt;warn&lt;error#you cannot specify every priority with different file for log4j log4j.rootLogger=debug,stdout,info,debug,warn,error #consolelog4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern= [%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n#info loglog4j.logger.info=infolog4j.appender.info=org.apache.log4j.DailyRollingFileAppender log4j.appender.info.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.info.File=./src/com/hp/log/info.loglog4j.appender.info.Append=truelog4j.appender.info.Threshold=INFOlog4j.appender.info.layout=org.apache.log4j.PatternLayout log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#debug loglog4j.logger.debug=debuglog4j.appender.debug=org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.debug.File=./src/com/hp/log/debug.loglog4j.appender.debug.Append=truelog4j.appender.debug.Threshold=DEBUGlog4j.appender.debug.layout=org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#warn loglog4j.logger.warn=warnlog4j.appender.warn=org.apache.log4j.DailyRollingFileAppender log4j.appender.warn.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.warn.File=./src/com/hp/log/warn.loglog4j.appender.warn.Append=truelog4j.appender.warn.Threshold=WARNlog4j.appender.warn.layout=org.apache.log4j.PatternLayout log4j.appender.warn.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n#errorlog4j.logger.error=errorlog4j.appender.error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;log4j.appender.error.File = ./src/com/hp/log/error.log log4j.appender.error.Append = truelog4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n 创建测试类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.test;import com.dao.UserDao;import com.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;/** * mybatis的入门案例 */public class MyBatisTest &#123; /** * 入门案例 * @param args */ public static void main(String[] args) throws Exception&#123; //1. 读取配置文件 InputStream in = Resources.getResourceAsStream("MyBatis-config.xml"); //2.使用SqlSessionFactory工厂 //SqlSessionFactory是个接口，得找一下它的实现类 SqlSessionFactoryBuilder build = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = build.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 UserDao userdao = session.getMapper(UserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userdao.findAll(); for(User user:users)&#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 结果展示 mybatis的入门案例 ​ 第一步： 读取配置文件 ​ 第二步： 创建SqlSessionFactory工厂 ​ 第三步：创建SqlSession ​ 第四步：创建Dao接口的代理对象 ​ 第五步：执行dao中的方法 ​ 第六步：释放资源 ​ 注意事项： ​ 不要忘记在映射配置中告知mybits要封装到哪个实体类中 ​ 配置的方式：指定实体类的全限定类名]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit的基本注解]]></title>
    <url>%2F2019%2F09%2F17%2FJunit%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Junit的基本注解注解类型 注解名称 注解作用 @Before 表示在任意使用@Test注解标注的public static void 方法执行之前执行 @After 表示在任意使用@Test注解标注的public static void 方法执行之后执行 @Test 使用该注解标注的public void 方法会表示为一个测试方法，可以直接执行 @BeforeClass 表示在类中的任意public static void 方法执行之前执行 @AfterClass 表示在类中的任意public static void 方法执行之后执行 下面是测试样例： 1234567891011121314151617181920212223242526package com.test;import org.junit.*;public class BasicAnnotationTest &#123; @BeforeClass public static void beforeClass() &#123; System.out.println("这是beforeClass前置通知"); &#125; @AfterClass public static void afterClass() &#123; System.out.println("这是afterClass后置通知"); &#125; @Before public void before() &#123; System.out.println("这是before前置通知"); &#125; @After public void after() &#123; System.out.println("这是after后置通知"); &#125; @Test public void test1() &#123; System.out.println("这是test1"); &#125;&#125; 结果：]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub学习笔记]]></title>
    <url>%2F2019%2F09%2F16%2FGitHub%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[GitHub学习笔记基本概念仓库（Repository）仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目存在多个仓库。 收藏（Star）收藏项目，方便查看 复制克隆项目（Fork）点击之后，会别人的仓库完整的复制一份给你，该fork仓库之独立存在的，而且上面会有从哪个地方克隆的。 发起合并请求（Push Request）这个是基于Fork的，如果想要克隆来源的地方也更新同样的代码，然后可以点击之后，会发起合并请求，查看同意之后就可以合并了。 关注（Watch）关注项目之后，项目更新可以接受到通知 事物卡片（Issue）发现代码有BUG，但是目前没有成型代码，需要讨论时用 Github主页账号登录成功之后，点击左上角就回到github主页，显示自己的动态和关注的动态，右边显示git库 仓库主页显示项目信息，如：项目代码，版本，收藏/关注/fork情况等 创建仓库 仓库主页 仓库管理点击create new file新建文件 写好之后，填写提交的目的，原因：为了方便其他开发者知道本次添加或修改的原因 创建完毕跳转到主页 点击目的之后可以看到文件的详细描述，还有文件的修改内容 编辑文件 点击之后回来到编辑模式之下 删除文件同上面一样 上传文件 可以拖动文件也可以点击上传多个文件 下面是写上传文件的信息 搜索文件 输入文件名进行筛选 也可以按快捷键T就可以进行查找文件 下载文件]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些常用的网站]]></title>
    <url>%2F2019%2F09%2F16%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一些常用的网站链接Spring官方文档（涵盖各个版本的）https://docs.spring.io/spring/docs/ Maven仓库https://mvnrepository.com/ Json格式化网站https://www.json.cn/ 不错的java学习网站http://how2j.cn/stage/39.html CMD Markdown网站https://www.zybuluo.com/mdeditor （可以在线记录markdown文档，缺点是有些功能收费） Leetcodehttps://leetcode-cn.com/ 站长工具http://tool.chinaz.com/ 谷歌网上应用商店https://chrome.google.com/webstore/category/extensions?h1=zh 慕课网https://www.imooc.com/ 牛客https://www.nowcoder.com/ 代码托管平台Githubhttps://github.com/ 待更新。。。。。。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis配置文件整理]]></title>
    <url>%2F2019%2F09%2F16%2FMyBatis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[MyBatis配置文件整理log4j.properties123456789101112131415161718192021222324 ### 设置###log4j.rootLogger = debug,stdout,D,E ### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n ### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n ### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n mybatis模板123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--属性--&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!--设置--&gt; &lt;settings&gt; &lt;setting name="" value=""/&gt; &lt;/settings&gt; &lt;!--别名--&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!--类型处理器--&gt; &lt;typeHandlers&gt;&lt;/typeHandlers&gt; &lt;!--对象工厂--&gt; &lt;objectFactory type=""&gt;&lt;/objectFactory&gt; &lt;!--插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=""&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;!--配置环境--&gt; &lt;environments default=""&gt; &lt;!--环境变量--&gt; &lt;environment id=""&gt; &lt;!--事务管理器--&gt; &lt;transactionManager type=""&gt;&lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=""&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--数据库厂商标识--&gt; &lt;databaseIdProvider type=""&gt;&lt;/databaseIdProvider&gt; &lt;!--映射器,告诉mybatis去哪里找映射文件--&gt; &lt;mappers&gt; &lt;mapper&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper模板12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 在MyBatis中，Mapper中的namespace用于绑定Dao接口的，即面向接口编程。 它的好处在于当使用了namespace之后就可以不用写接口实现类， 业务逻辑会直接通过这个绑定寻找到相对应的SQL语句进行对应的数据处理--&gt;&lt;mapper namespace=""&gt; &lt;!--查询--&gt; &lt;select id=""&gt;&lt;/select&gt; &lt;!--增加--&gt; &lt;insert id=""&gt;&lt;/insert&gt; &lt;!--删除--&gt; &lt;delete id=""&gt;&lt;/delete&gt; &lt;!--修改--&gt; &lt;update id=""&gt;&lt;/update&gt; &lt;!--提供缓存支持--&gt; &lt;cache&gt;&lt;/cache&gt; &lt;!--参照缓存,用来引用另一个缓存--&gt; &lt;cache-ref namespace=""/&gt; &lt;!-- ParameterMap和ResultMap类似，设置入参字段映射，很少使用（不建议使用）--&gt; &lt;parameterMap id="" type=""&gt;&lt;/parameterMap&gt; &lt;!--查询结果集，映射java对象--&gt; &lt;resultMap id="" type=""&gt;&lt;/resultMap&gt;&lt;/mapper&gt; Spring整合模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSouce" class="org.apache.commons.dbcp2.BasicDataSource"&gt; &lt;!--加载数据库驱动--&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8"&gt;&lt;/property&gt; &lt;!--账户--&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;!--密码--&gt; &lt;property name="password" value="wang123"&gt;&lt;/property&gt; &lt;!--最大连接数--&gt; &lt;property name="maxTotal" value="30"&gt;&lt;/property&gt; &lt;!--最大空闲数--&gt; &lt;property name="maxIdle" value="10"&gt;&lt;/property&gt; &lt;!--初始化连接数--&gt; &lt;property name="initialSize" value="5"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--添加事务支持--&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager="txManager" /&gt; &lt;!--配置MyBatis工厂,同时指定数据源，并于MyBatis完美整合--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--指定数据源--&gt; &lt;property name="dataSource" ref="dataSouce"&gt;&lt;/property&gt; &lt;!--configLocation的属性值为MyBatis的核心配置文件--&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配 (Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口) --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!--mybatis-spring组件的扫描器--&gt; &lt;property name="basePackage" value=""&gt;&lt;/property&gt; &lt;!--注入工厂--&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring5约束头1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;/beans&gt; 整合Spring和MyBatis所使用的pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.my_priatices.aop&lt;/groupId&gt; &lt;artifactId&gt;my_priatices.aop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-dbcp2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 待更新。。。。。。]]></content>
      <categories>
        <category>MyBatis学习</category>
      </categories>
      <tags>
        <tag>MyBatis学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（三）]]></title>
    <url>%2F2019%2F09%2F12%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVAEE读书笔记（三）基于XML装配Spring提供了两种基于XML的装配方式，分别是setter注入和构造方法注入 首先创建Bean的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;/** * 复杂数据的注入 */public class ComplexUser &#123; private String name; private List&lt;String&gt; hobbyList; private Map&lt;String,String&gt; residenceMap; private Set&lt;String&gt; aliasSet; private String[] array; public ComplexUser(String name, List&lt;String&gt; hobbyList, Map&lt;String, String&gt; residenceMap, Set&lt;String&gt; aliasSet, String[] array) &#123; this.name = name; this.hobbyList = hobbyList; this.residenceMap = residenceMap; this.aliasSet = aliasSet; this.array = array; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getHobbyList() &#123; return hobbyList; &#125; public void setHobbyList(List&lt;String&gt; hobbyList) &#123; this.hobbyList = hobbyList; &#125; public Map&lt;String, String&gt; getResidenceMap() &#123; return residenceMap; &#125; public void setResidenceMap(Map&lt;String, String&gt; residenceMap) &#123; this.residenceMap = residenceMap; &#125; public Set&lt;String&gt; getAliasSet() &#123; return aliasSet; &#125; public void setAliasSet(Set&lt;String&gt; aliasSet) &#123; this.aliasSet = aliasSet; &#125; public String[] getArray() &#123; return array; &#125; public void setArray(String[] array) &#123; this.array = array; &#125; @Override public String toString() &#123; return "ComplexUser&#123;" + "name='" + name + '\'' + ", hobbyList=" + hobbyList + ", residenceMap=" + residenceMap + ", aliasSet=" + aliasSet + ", array=" + Arrays.toString(array) + '&#125;'; &#125;&#125; 配置Bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="u1" class="com.bean.ComplexUser"&gt; &lt;!--构造方法注入--&gt; &lt;constructor-arg index="0" value="myname"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;码代码&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;map&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;entry key="beijing" value="北京"&gt;&lt;/entry&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;set&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang1&lt;/value&gt; &lt;value&gt;wang&lt;/value&gt; &lt;value&gt;wang2&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="u2" class="com.bean.ComplexUser"&gt; &lt;property name="name" value="shuai"&gt;&lt;/property&gt; &lt;property name="hobbyList"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;搬砖&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="residenceMap"&gt; &lt;map&gt; &lt;entry key="jiyuan" value="济源"&gt;&lt;/entry&gt; &lt;entry key="anyang" value="安阳"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="aliasSet"&gt; &lt;set&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s2&lt;/value&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s4&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="array"&gt; &lt;array&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;你太美&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建测试类 123456789101112131415161718package com.test;import com.bean.ComplexUser;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); ComplexUser u1 = (ComplexUser)applicationContext.getBean("u1"); System.out.println(u1.toString()); ComplexUser u2 = (ComplexUser)applicationContext.getBean("u2"); System.out.println(u2.toString()); &#125;&#125; 结果 基于注解的装配因为要用到注解，所以我们来看看都有哪些基础的注解： 名称 作用 Component 代表一个组件对象，就是把普通的pojo实例到Spring容器中 Repository 此注解用于数据访问层（DAO），功能与Component相同 Service 此注解用于业务逻辑组件层（Service层），功能与Component相同 Controller 此注解用于标注一个控制器组件类（SpringMVC的Controller），功能与Component相同 AutoWired 此诸结可以对类成员变量，方法及构造方法进行标注，完成自动装配的工作。通过使用Autowired来消除setter和getter方法。默认按照Bean的类型进行装配，如果想按照名称来注入，就必须要和Qualifier搭配使用。 Resource 此注解与AutoWired相同，区别在于这个注解是按照名称来装配注入的，只有当找不到与名称匹配的名称时，才按照Bean的类型进行装配。 Qualifier 此注解要和AutoWired配合使用，Bean的实例名称有此注解的参数指定。 首先创建一个DAO层，和他的实现类，然后标上注解： TestDao 12345678910111213package com.dao;import org.springframework.stereotype.Repository;/** * 创建dao接口 */public interface TestDao &#123; /** * 保存 */ void save();&#125; TestDaoImpl 12345678910111213package com.dao.impl;import com.dao.TestDao;import org.springframework.stereotype.Repository;@Repository("testDao")public class TestDaoImpl implements TestDao &#123; @Override public void save() &#123; System.out.println("TestDao save"); &#125;&#125; TestService 1234567891011package com.servlet;import org.springframework.stereotype.Service;/** * 业务层接口 */public interface TestService &#123; void save();&#125; TestServiceImpl 1234567891011121314151617181920212223package com.servlet.impl;import com.dao.TestDao;import com.servlet.TestService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * 业务层实现类 */@Service("testService")public class TestServiceImpl implements TestService &#123; @Resource(name="testDao") private TestDao testDao; @Override public void save() &#123; testDao.save(); System.out.println("TestService save"); &#125;&#125; TestController 12345678910111213141516171819package com.controller;import com.servlet.TestService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controllerpublic class TestController &#123; @Autowired private TestService testService; public void save()&#123; testService.save(); System.out.println("TestController save"); &#125;&#125; 测试类 12345678910111213package com.test;import com.controller.TestController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); TestController testController = (TestController)applicationContext.getBean("testController"); testController.save(); &#125;&#125; 结果 课后题Bean的实例化有哪几种常见的方法？ ​ 答： 三种，构造方法，静态工厂，实例工厂 简述基于注解装配方式的基本用法？ ​ 答： 见上面的表格。 @AutoWired和@Resource有什么区别？ ​ 答：一个是按类别，一个是按名称 Bean的默认作用域是什么？ ​ 答：singleton 单例模式 使用类似于@Controller一样的注解的时候，Bean的id是什么？ ​ 答： 默认是首字母小写的类名]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F09%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[基础部分 javaSE MySQL，刚开始只需要了解一些基础的sql语句，例如增删改查，复杂一点的后面可以在学。 idea可以直接连接数据库 database，一开始可以多用用，熟悉熟悉 javaWeb：jsp（了解即可），（Servlet ，Filter，Listener），重点放在Listener 现在大多数都是异步机制和回调机制，Listener监听用的多，Filter用的少 （重点部分）SSM：Spring + MyBatis+Spring MVC Spring MVC：是Spring中的一部分 Spring：本身是一个容器 响应式编程 WebFlux，在开发中用的也不是很多，主要解决的是高并发问题，建议了解一下 Lambda表达式，基于接口实现的，建议学习 项目管理工具 Maven，得了解原理。 项目管理工具Git，也是分布式版本管理工具，然后项目要放到github上面 （重点部分）Spring Boot （快速开发框架），使用这个原因是因为SSM配置文件非常多，基本上都是样板式代码，因此必须把可重用性代码封装起来，所以这个Spring Boot必须得好好学习，重点！ 分布式开发技术（进阶部分） linux基础，因为服务器现在基本上都是搭建在无可视化界面的linux上面的 本地服务器搭建的工具（VMware（搭建虚拟机）+secureCRT（客户端）+CentOS 7 Mini版本（只有操作界面） 分布式协调服务器Zookeeper 反向代理服务器 Nginx 真正请求的服务器在后面，这个是代理集群，集群里面部署的应用都是一样的，一般都会选一个master作为主要的 正解：正向解析，把域名解析成ip地址 反解：反向代理，把ip地址解析成域名 正代：由内向外作代理 反代：由外向内做代理 分布式内存数据库Redis（NoSql非关系型数据库） 分布式消息队列Kafka，RocketMQ，RabbitMQ（ActiveMQ不用管它） 应用方面：削减峰值，并发量高的时候需要使用 分布式RPC框架Dubbo（阿里的框架）和微服务框架Spring Cloud 微服务：把服务分散开，每一个都是独立的工程，用哪个调哪个 高内聚，低耦合，便于复用 Spring Boot 一定要好好学习！！！]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>前进方向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（二）]]></title>
    <url>%2F2019%2F09%2F04%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBeanBean的配置​ Spring用于生产和管理Spring容器中的Bean。如果要使用这个工厂生产和管理Bean，需要开发者将Bean配置在Spring的配置文件中。Spring框架支持Xml和Properties两种格式的配置文件，在实际开发中常用XML格式的配置文件。 ​ &lt;bean&gt;元素的常用属性及其子元素 描述 属性或子元素名称 id Bean在BeanFactory中的唯一标识，在代码中通过BeanFactory获取Bean实例时需要以此作为索引名称 class Bean的具体实现类，使用类的名（例如dao.TestDIDaoImpl） scope 指定Bean实例的作用域 &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入，指定构造方法的参数。该元素的index属性指定参数的序号，ref属性指定对BeanFactory中其他Bean的引用关系，type属性指定参数类型，value属性指定参数的常量值 &lt;property&gt; &lt;bean&gt;元素的子元素用于设置一个属性，该元素的name属性指定Bean实例中相应的属性名称，value属性指定Bean的属性值，ref属性指定属性对BeanFactory中其他Bean的引用关系 &lt;list&gt; &lt;property&gt;元素的子元素，用于封装List或数组类型的依赖注入 &lt;map&gt; &lt;property&gt;元素的子元素，用于封装Map类型的依赖注入 &lt;set&gt; &lt;property&gt;元素的子元素，用于封装Set类型的依赖注入 &lt;entry&gt; &lt;map&gt;元素的子元素，用于设置一个键值对 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; Bean的实例化​ 在Spring框架中，如果想使用Spring容器中的Bean，也需要实例化Bean，Spring框架实例化Bean有三种方式 即，构造方法实例化、静态工厂实例化和实例工厂实例化（最常用就是构造方法实例化）。 1. 构造方法实例化 spring-config.xml配置 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg ref="accountDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="com.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910111213package com.test;import com.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); AccountService accountService = (AccountService)applicationContext.getBean("accountService"); accountService.addAccountMoney("张三",1000f); &#125;&#125; 2. 静态工厂实例化对象（开发中不使用，再次不列举使用方法）3. 实例工厂实例化对象（这个也不列举）Bean的作用域 作用域名称 描述 singleton 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例 prototype Spring容器每次获取protopyte定义的Bean，容器都将创建一个新的Bean实例 request 在一次Http请求中容器将返回一个Bean实例，不同的Http请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用 session 在一个HTTP Session 中，容器将返回同一个Bean实例。尽在Web Spring应用程序上下文中使用 application 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例，尽在Web Spring应用程序上下文中使用 websocket 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用 1. singleton作用域​ 由于singleton是bean的scope默认设置，所以写好bean之后就可以进行测试 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.test.AccountServiceImpl" scope="singleton"&gt;&lt;/bean&gt;&lt;/beans&gt; 代码如下 123456789101112131415package com.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-config.xml"); //第一个对象 AccountServiceImpl a1 = (AccountServiceImpl)applicationContext.getBean("accountService"); //第二个对象 AccountServiceImpl a2 = (AccountServiceImpl)applicationContext.getBean("accountService"); System.out.println(a1 == a2); &#125;&#125; 结果展示： 2. prototype作用域代码如上所述，然后只设置scope作用域即可 结果展示: Bean的生命周期​ 一个对象的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段，在Spring中，Bean对象周期也遵循这一过程，但是Spring提供了许多对外接口，允许开发者对3个过程（实例化、初始化、销毁）的前后做一些操作。在Spring Bean中，实例化是为Bean对象开辟空间，初始化则是对属性的初始化。 ​ Bean生命周期整个过程如下： ​ （1）根据Bean的配置情况实例化一个Bean。 ​ （2）根据Spring上下文对实例化的Bean进行依赖注入，即对Bean的属性进行初始化。 ​ （3）如果Bean实现了BeanNameAware 接口，将调用它实现的，setBeanName（String beanId）方法， 此处参数传递的是Spring配置文件中Bean的id。 ​ （4）如果Bean实现BeanFactoryAware接口，将调用它实现的setBeanFactory方法，此处参数传递的是当前Spring工厂实例的引用。 ​ （5）如果Bean实现了ApplicationContextAware接口，将调用它实现的setApplicationContext（ApplicationContext）方法，此处参数传递的是Spring上下文实例的引用。 ​ （6）如果Bean关联了BeanPostProcessor接口，将调用初始化方法postProcessBeforeInitialization（Object obj， String s）对Bean进行操作。 ​ （7）如果Bean实现了InitializingBean接口， 将调用afterPropertiesSet方法。 ​ （8）如果Bean在Spring配置文件中配置了 init-method 属性，将自动调用其配置的初始化方法。 ​ （9）如果Bean关联了BeanPostProcessor接口，将调用postProcessAfterInitialization（Object obj，String s）方法，由于是在Bean初始化结束时调用After方法，也可用于内存或缓存技术。 ​ （10）当Bean不再需要时将进入销毁阶段，如果Bean实现了DisposableBean接口，则调用其实现的destroy方法将Spring中的Bean销毁。 ​ （11）如果在配置文件中通过destory-method属性指定了Bean的销毁方法，将调用其配置的销毁方法进行销毁。 ​ 在Spring中，通过特定的接口或通过&lt;bean&gt;元素的属性设置可以对Bean的生命周期过程产生影响。 ​ 例子： ​ 创建Bean的实现类 12345678910111213package com.test;/** * @author wys */public class BeanLife &#123; public void initMyself()&#123; System.out.println(this.getClass().getName()+"执行了自定义的初始化方法"); &#125; public void destroyMyself() &#123; System.out.println(this.getClass().getName()+"执行了自定义的销毁方法"); &#125;&#125; ​ 配置Bean 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置bean，使用init-method指定初始化方法，使用destroy-method指定销毁方法--&gt; &lt;bean id="beanLife" class="com.test.BeanLife" init-method="initMyself" destroy-method="destroyMyself"&gt;&lt;/bean&gt;&lt;/beans&gt; ​ 测试生命周期 12345678910111213141516package com.test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; //初始化Spring容器，加载配置文件 //为了方便演示，用的是ClassPathXmlApplicationContext //实现声明类容器 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("spring-config.xml"); System.out.println("获得对象前"); BeanLife beanLife = (BeanLife)ctx.getBean("beanLife"); System.out.println("获得对象后"+beanLife); ctx.close(); &#125;&#125; 结果如下:]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next界面美化]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E7%9A%84next%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[设置中文首先查看一下next/theme/language中的语言类型，一般就是zh-CN或者是zh-Hans`这个类型 然后在hexo的配置文件_config.yml把写上去就行 主题风格将next中的_config.yml配置文件修改一下 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 这个把前面的#去掉换另一种就行，我觉得第三种就挺好看的。个人喜好 设置分类还是在next中的_config.yml配置文件修改 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 把对应菜单的选项注释去掉就好 然后创建目录,不同标签对应不同的代码 1$ hexo new page categories 创建完毕之后，进去修改一下 类似于categories这种的 123456---title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: "categories"--- 添加头像搜索next中的_config.yml配置文件 搜索Sidebar Avatar这个关键字，去掉avatar前面的# 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.gif 然后把头像放到指定的文件夹 设置侧边栏的的社交链接打开themes/next/_config.yml文件，搜索关键字social，然后添加社交站点名称与地址即可。 1234567891011social: GitHub: https://github.com/wyscoder|| github E-Mail: mailto:714133840@qq.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 修改底部的声明和版权主题配置文件下，搜索关键字post_copyright，enable改为true： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 去掉强力驱动 找到hexo根目录&gt;&gt;themes&gt;&gt;next&gt;&gt;layout&gt;&gt;_partials下的footer.swig文件 然后打开删除 123456789101112131415161718&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; 这部分内容就好 最后修改一下hexo中的配置文件名字就行 添加搜索功能首先安装一下搜索插件 $ npm install hexo-generator-searchdb --save 打开Hexo站点的_config.yml，添加配置 : 12345search: path: search.xml field: post format: html limit: 10000 打开themes/next/_config.yml，搜索关键字local_search，设置为true： 123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 本地站点推送到GitHub上安装插件 1$ npm install hexo-deployer-git --save 在Hexo站点的_config.yml中配置deploy： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; #your github.io.git branch: master 1$ hexo clean 1$ hexo g -d 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 我放在了侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=110 src=&quot;//music.163.com/outchain/player?type=0&amp;id=408443429&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; 就好了 添加背景动画效果 修改_layout.swig 打开 next/layout/_layout.swig 在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话 可以这么设置====&gt; 在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加代码复制功能首先找到这个目录themes/next/layout/_third-party/ 然后在此文件夹下创建名为copy-code.swig的文件，在此文件中输入以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; .copy-btn &#123; display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; &#125; .highlight-wrap .copy-btn &#123; transition: opacity .3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; &#125; .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus &#123; opacity: 1 &#125; .highlight-wrap &#123; position: relative; &#125;&lt;/style&gt;&lt;script&gt; $('.highlight').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap') $(e).after($wrap) $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text() &#125;).toArray().join('\n') var ta = document.createElement('textarea') document.body.appendChild(ta) ta.style.position = 'absolute' ta.style.top = '0px' ta.style.left = '0px' ta.value = code ta.select() ta.focus() var result = document.execCommand('copy') document.body.removeChild(ta) if(result)$(this).text('复制成功') else $(this).text('复制失败') $(this).blur() &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn') setTimeout(function () &#123; $b.text('复制') &#125;, 300) &#125;).append(e) &#125;)&lt;/script&gt; 然后返回上一层目录，即layout文件夹下，编辑_layout.swig， 在最底部，&lt;/body&gt;上面添加 1&#123;% include &apos;_third-party/copy-code.swig&apos; %&#125; 这句话接着就能用了]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO搭建博客（搭建在github上面）]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言学长给的几个教程链接 https://blog.csdn.net/u013332124/article/details/80680156 https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html#validate-next-theme https://blog.csdn.net/llmmll08/article/details/70246150 1.什么是hexo​ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 2.安装1.前提​ 必须有Node.js 和 Git, 还有Github账号，都具备之后就开始了 2.创建github pages页面 首先创建仓库（repository ），然后仓库名字必须得是 yourname.github.io 这个，比如我的github名称是wyscoder，所以仓库名称就是 wyscoder.github.io 然后记住这个仓库的git地址 https://github.com/wyscoder/wyscoder.github.io 3.安装hexo 这个是需要node.js和git作为前置的，如果没有就去下载node.js和git 接下来就只需要npm就可以完成安装了 使用这个命令进行安装hexo$ npm install -g hexo-cli 等待下载完毕就行 4. 建站 安装hexo完成之后，执行下面命令就会在指定文件夹创建需要的文件 1234node.js$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 具体参数信息请查看官方文档 https://hexo.io/zh-cn/docs/configuration package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; "name": "hexo-site", "version": "0.0.0", "private": true, "hexo": &#123; "version": "" &#125;, "dependencies": &#123; "hexo": "^3.8.0", "hexo-generator-archive": "^0.1.5", "hexo-generator-category": "^0.1.3", "hexo-generator-index": "^0.2.1", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.1", "hexo-renderer-stylus": "^0.3.3", "hexo-renderer-marked": "^0.3.2", "hexo-server": "^0.3.3" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 5.上传站点生成后,就可以开始写文章了。dos界面下,进入所在站点目录，输入hexo new [layout] &lt;title&gt;命令。hexo会自动帮你生成一个 &lt;title&gt;.md 的文件。然后你就可以在这个文件上编写你的博客内容了。 写完博客后,我们先试着在本地部署一下服务。还是在dos命令下，进入站点目录。一次输入: 123hexo clean # 清除缓存,之后会经常用到hexo g # 生成站点静态文件hexo s # 部署服务 上面是本地部署，之后就可以通过localhost:4000来访问博客了 但是如果想让别人访问你的还需要提交到git上面 打开cmd 然后输入npm install hexo-deployer-git --save安装git工具 开站点目录下面的配置文件_config.yml(用任意编辑器),配置deploy参数。一开始配置文件是这样的: 12deploy: type: 我们把它改成我们的git仓库地址。 1234deploy: type: git repository: ssh://git@github.com/wyscoder/wyscoder.github.io branch: master 修改好之后执行 123hexo clean hexo g hexo d # 部署到远程仓库 令全部执行完后。我们就可以访问我们的博客网站了。https://wyscoder.github.io 6.问题在使用hexo d提交的时候出现了几个问题 首先是你得使用git命令来设置用户和邮箱 config --global user.name "nameVal" ```12```git config --global user.email &quot;eamil@qq.com&quot; 其中我还测试了一下那个git的基本命令，都是卡在提交那一点，原因是没有密匙 如果电脑上没有ssh密匙我建议还是要安装一下 7.美化博客：使用nexT主题博客是搭建好了, 但是我们发现hexo的默认主题风格比较丑。好在hexo的主题是可定制的。所以我们可以更换别人已经做好的主题。nexT就是其中一个比较强大的主题。下面简单的教大家怎么切换到这个主题。​ 先去nexT的github页面下载nexT项目。https://github.com/iissnan/hexo-theme-next。然后放到站点目录下面的一个themes文件夹中。解压。 解压后会得到一个hexo-theme-next-master文件夹。重命名成next。 修改站点配置文件_config.yml里面的theme参数,修改值为next。 ​ 重新清除缓存,生成新的资源文件，然后部署,主题就切换成next了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVAEE读书笔记（一）]]></title>
    <url>%2F2019%2F08%2F10%2FJAVAEE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring简介1. Spring由来 目的是为了解决企业级应用开发的业务逻辑和其他各层的耦合问题 2. Spring体系结构 核心容器（Core Container） 数据访问/ 集成（Data Access/Integration）层 Web层 AOP（Aspect Oriented Programming，面向切面的编程）模块 植入（Instrumentation）模块 消息传输（Messaging） 测试（Test） Spring体系结构 SpringIOC1. Spring IOC基本概念控制反转是一个比较抽象的概念，是Spring框架的核心，用来削减计算机程序的耦合问题。 依赖注入是IOC的另外一种说法。 解释 &nbsp;&nbsp;当某个java对象需要调用另一个对象时，在传统编程模式下，调用者通常会采用 “new 被调用者” 的方式来创建对象，这种方式会增加调用者和被调用者之间的耦合性，不利于后期代码的维护。 &nbsp;&nbsp;当Spring框架出现后，对象的实例不再由调用者来创建，而是由Spring容器来创建。Spring容器会负责控制程序之间的关系，这样，控制权由调用者转移到Spring容器，控制权发生了反转，这就是Spring的控制反转。 &nbsp;&nbsp;从Spring容器角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，相当于为调用者注入他所依赖的实例，这就是Spring依赖注入。 &nbsp;&nbsp;综上所述，控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方产生或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方式是依赖注入。 2. SpringIOC容器SpringIOC容器的设计主要是基于BeanFactory和ApplicationContext两个接口。 BeanFactory(1). 概念&nbsp;&nbsp;BeanFactory由org.springframework.beans.factory.BeanFactory接口定义，它提供了完整的Ioc服务支持，是一个管理BeanFactory的工厂，主要负责初始化各种Bean。BeanFactory接口有许多实现类，比较常用的就是org.springframework.beans.factory.xml.XmlBeanFactory.这个类会根据XML来装配Bean，创建时候需要提供XML文件的绝对路径。 123456public static void main(String[] args)&#123; //初始化Spring容器，加载配置文件 BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource("绝对路径")); TestDao testDao = (TestDao)beanFactory.getBean("testDao"); testDao.sayHello();&#125; 这种写法开发中一般不常见，了解即可。 ApplicationContext&nbsp;&nbsp;ApplicationContext是BeanFactory的子接口，也称为应用上下文，org.springwork.context.ApplicationContext接口定义，ApplicationContext接口除了包含BeanFactory的所有功能外，还添加了国际化，资源访问，事件传播等内容的支持。 &nbsp;&nbsp;创建ApplicationContext接口实例通常有以下三种方式: (1). *通过ClassPathXmlApplicationContext创建 *：&nbsp;&nbsp;ClassPathXmlApplicationContext将类路径目录（src根目录）中寻找指定的XML配置文件，代码如下： 1234567public static void main(String[] args)&#123; //初始化Spring容器ApplicationContext,加载配置文件 ApplicationContext ac = ClassPathXmlApplicationContext("spring-config.xml"); //通过容器获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; (2). 通过FileSystemXmlApplicationContext创建：&nbsp;&nbsp;FileSystemXmlApplicationContext将从指定文件的绝对路径中寻找XML配置文件，找到并装载完成ApplicationContext的实例化工作。代码如下： 1234567public stsatic void main(String[] args)&#123; //初始化Spring容器ApplicationContext，加载配置文件 ApplicationContext ac = new FileSystemXmlApplication("C:\Users\hp\IdeaProjects\my_pratices_account_day_01\src\main\resources\spring-config.xml"); //获取实例对象 TestDao testDao = (TestDao)ac.getBean("testDao"); testDao.sayHello();&#125; 采用绝对路径的加载方式将导致程序的灵活性变差，一般不推荐使用。 (3). 通过Web服务器实例化ApplicationContext容器&nbsp;&nbsp;在Web服务器实例化ApplicationContext容器时，一般使用org.springframework.web.context.ContextLoaderListener的实现方式（需要导入spring-web.5.0.2.RELEASE.jar包），此方法只需在web.xml中添加如下代码： 1234567891011&lt;context-param&gt; &lt;!--加载src目录下的spring-config.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-config.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; 3. 依赖注入的类型构造方法注入&nbsp;&nbsp;Spring框架可以采用java的反射机制，通过构造方法完成依赖注入 首先创建持久层接口 1234567891011package com.test.dao;/** * 创建持久层 */public interface TestDao &#123; /** * Hello方法 */ void sayHello();&#125; 然后创建持久层实现类 1234567891011package com.test.dao.impl;import com.test.dao.TestDao;public class TestDaoImpl implements TestDao &#123; @Override public void sayHello()&#123; System.out.println("Hello World"); &#125;&#125; 创建业务层接口 12345678package com.test.service;/** * 业务层 */public interface TestService &#123; void sayHello();&#125; 创建业务层实现类 12345678910111213141516171819package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public TestServiceImpl(TestDao testDao)&#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 配置spring-config.xml 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;constructor-arg ref="testDao"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后在测试类中测试一下 1234567891011121314package com.test;import com.test.service.TestService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("spring-config.xml"); TestService testService = (TestService)ac.getBean("testService"); testService.sayHello(); &#125;&#125; 然后看一下结果 以上就是构造注入 属性的setter注入&nbsp;&nbsp;和上面创建一样，只需要更改一下TestServiceImpl中的代码和spring-config.xml就行 123456789101112131415161718192021package com.test.service.impl;import com.test.dao.TestDao;import com.test.service.TestService;/** * 业务层接口 */public class TestServiceImpl implements TestService &#123; private TestDao testDao; //使用构造方法注入 public void setTestDao(TestDao testDao) &#123; this.testDao = testDao; &#125; @Override public void sayHello() &#123; testDao.sayHello(); &#125;&#125; 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="testService" class="com.test.service.impl.TestServiceImpl"&gt; &lt;property name="testDao" ref="testDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="testDao" class="com.test.dao.impl.TestDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 4. 课后习题 举例说明IOC容器的实现方式有哪些？ 控制反转和依赖注入 spring中什么是控制反转？什么是依赖注入？使用控制反转与依赖注入的优点？ 控制反转：是一种通过描述并通过第三方去产生去获取特定对象的方式 依赖注入：使用spring框架创建对象时动态的将其所依赖的对象注入到Bean组件中。 控制反转优点： ​ 1.获取对象可以通过注解等方式获取对象，打破传统的获取方式 ​ 2.对象不再由程序本身进行创建，而是交给spring容器创建，降低了程序的耦合性 ​ 3.控制反转能做到更多的事情，例如事务控制 ​ 4.后期维护方便 依赖注入优点： ​ 1.项目开发讲究高内聚，低耦合 ​ 2.使用依赖注入可以避免使用new关键字创建对象，从而降低类与类之间的耦合度 spring框架采用java的反射机制进行依赖注入.]]></content>
      <categories>
        <category>JAVAEE读书笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
